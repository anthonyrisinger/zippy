diff --git a/.gitignore b/.gitignore
index d021ce9..6ee1a02 100644
--- a/.gitignore
+++ b/.gitignore
@@ -4,6 +4,12 @@
 *.jar
 *~
 *.so
+*.gox
+*.a
+*.dll
+*.key
+*.orig
+*.rej
 
 /uwsgi
 /uwsgibuild.*
@@ -12,3 +18,11 @@
 /t/ring/target
 
 core/dot_h.c
+
++# coverity
++/cov-int/
++uwsgi.tar.xz
+
+/build/
+/dist/
+/uWSGI.egg-info/
diff --git a/CONTRIBUTORS b/CONTRIBUTORS
index c796cc0..f331222 100644
--- a/CONTRIBUTORS
+++ b/CONTRIBUTORS
@@ -1,7 +1,7 @@
 - this is a incomplete list of all the contributors of the project -
 
 Roberto De Ioris, Unbit, <roberto@unbit.it>
-Riccardo Magliocchetti, Unbit, <riccardo@unbit.it>
+Riccardo Magliocchetti
 Yann Malet, Lincoln Loop
 Simon Litchfield
 Masahiro Honma, <hiratara@cpan.org>
@@ -28,3 +28,6 @@ Ryan Petrello
 Danila Shtan <danila@shtan.ru>
 Ævar Arnfjörð Bjarmason
 Yu Zhao (getcwd)
+Mathieu Dupuy
+Mike Kaplinskiy
+Adriano Di Luzio (adriano@unbit.it)
diff --git a/apache2/mod_proxy_uwsgi.c b/apache2/mod_proxy_uwsgi.c
index c361be0..533950c 100644
--- a/apache2/mod_proxy_uwsgi.c
+++ b/apache2/mod_proxy_uwsgi.c
@@ -67,15 +67,20 @@ static int uwsgi_canon(request_rec *r, char *url)
     }
     url += sizeof(UWSGI_SCHEME); /* Keep slashes */
 
-    err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);
-    if (err) {
-        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
+    // is it a unix socket ?
+    if (strlen(url) == 2) {
+	*sport = 0;
+    }
+    else {
+        err = ap_proxy_canon_netloc(r->pool, &url, NULL, NULL, &host, &port);
+        if (err) {
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r,
                       "error parsing URL %s: %s", url, err);
-        return HTTP_BAD_REQUEST;
+            return HTTP_BAD_REQUEST;
+        }
+	apr_snprintf(sport, sizeof(sport), ":%u", port);
     }
 
-    apr_snprintf(sport, sizeof(sport), ":%u", port);
-
     if (ap_strchr(host, ':')) { /* if literal IPv6 address */
         host = apr_pstrcat(r->pool, "[", host, "]", NULL);
     }
@@ -253,6 +258,43 @@ static request_rec *ap_proxy_make_fake_req(conn_rec *c, request_rec *r)
 
     return rp;
 }
+
+static apr_status_t ap_proxy_buckets_lifetime_transform(request_rec *r,
+        apr_bucket_brigade *from, apr_bucket_brigade *to)
+{
+    apr_bucket *e;
+    apr_bucket *new;
+    const char *data;
+    apr_size_t bytes;
+    apr_status_t rv = APR_SUCCESS;
+
+    apr_brigade_cleanup(to);
+    for (e = APR_BRIGADE_FIRST(from);
+         e != APR_BRIGADE_SENTINEL(from);
+         e = APR_BUCKET_NEXT(e)) {
+        if (!APR_BUCKET_IS_METADATA(e)) {
+            apr_bucket_read(e, &data, &bytes, APR_BLOCK_READ);
+            new = apr_bucket_transient_create(data, bytes, r->connection->bucket_alloc);
+            APR_BRIGADE_INSERT_TAIL(to, new);
+        }
+        else if (APR_BUCKET_IS_FLUSH(e)) {
+            new = apr_bucket_flush_create(r->connection->bucket_alloc);
+            APR_BRIGADE_INSERT_TAIL(to, new);
+        }
+        else if (APR_BUCKET_IS_EOS(e)) {
+            new = apr_bucket_eos_create(r->connection->bucket_alloc);
+            APR_BRIGADE_INSERT_TAIL(to, new);
+        }
+        else {
+            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(00964)
+                          "Unhandled bucket type of type %s in"
+                          " proxy_buckets_lifetime_transform", e->type->name);
+            apr_bucket_delete(e);
+            rv = APR_EGENERAL;
+        }
+    }
+    return rv;
+}
 #endif
 
 
@@ -263,6 +305,7 @@ static int uwsgi_response(request_rec *r, proxy_conn_rec *backend, proxy_server_
 	const char *buf;
 	char *value, *end;
 	int len;
+	int backend_broke = 1;
 	apr_status_t rc;
 	conn_rec *c = r->connection;
 	apr_off_t readbytes;
@@ -274,6 +317,7 @@ static int uwsgi_response(request_rec *r, proxy_conn_rec *backend, proxy_server_
 	rp->proxyreq = PROXYREQ_RESPONSE;
 
 	apr_bucket_brigade *bb = apr_brigade_create(r->pool, c->bucket_alloc);
+	apr_bucket_brigade *pass_bb = apr_brigade_create(r->pool, c->bucket_alloc);
 
 	len = ap_getline(buffer, sizeof(buffer), rp, 1);
 
@@ -325,8 +369,8 @@ static int uwsgi_response(request_rec *r, proxy_conn_rec *backend, proxy_server_
 		rv = ap_get_brigade(rp->input_filters, bb,
                                         AP_MODE_READBYTES, mode,
                                         conf->io_buffer_size);
-		if (APR_STATUS_IS_EAGAIN(rv)
-                        || (rv == APR_SUCCESS && APR_BRIGADE_EMPTY(bb))) {
+		if (mode == APR_NONBLOCK_READ && (APR_STATUS_IS_EAGAIN(rv)
+                        || (rv == APR_SUCCESS && APR_BRIGADE_EMPTY(bb)))) {
 			e = apr_bucket_flush_create(c->bucket_alloc);
 			APR_BRIGADE_INSERT_TAIL(bb, e);
 			if (ap_pass_brigade(r->output_filters, bb) || c->aborted) {
@@ -342,21 +386,37 @@ static int uwsgi_response(request_rec *r, proxy_conn_rec *backend, proxy_server_
 		else if (rv != APR_SUCCESS) {
 			ap_proxy_backend_broke(r, bb);
 			ap_pass_brigade(r->output_filters, bb);
+			backend_broke = 1;
+			break;
 		}
 
 		mode = APR_NONBLOCK_READ;
 		apr_brigade_length(bb, 0, &readbytes);
 		backend->worker->s->read += readbytes;
-		ap_pass_brigade(r->output_filters, bb);
+
+		if (APR_BRIGADE_EMPTY(bb)) {
+                        apr_brigade_cleanup(bb);
+                        break;
+                }
+
+		ap_proxy_buckets_lifetime_transform(r, bb, pass_bb);
+
+		ap_pass_brigade(r->output_filters, pass_bb);
 		apr_brigade_cleanup(bb);
+		apr_brigade_cleanup(pass_bb);
 	}
+
 	e = apr_bucket_eos_create(c->bucket_alloc);
 	APR_BRIGADE_INSERT_TAIL(bb, e);
         ap_pass_brigade(r->output_filters, bb);
 
 	apr_brigade_cleanup(bb);
 
-    return OK;
+	if (c->aborted || backend_broke) {
+        	return DONE;
+        }
+
+	return OK;
 }
 
 static int uwsgi_handler(request_rec *r, proxy_worker *worker,
diff --git a/buildconf/all.ini b/buildconf/all.ini
index 2410a7d..7d2a223 100644
--- a/buildconf/all.ini
+++ b/buildconf/all.ini
@@ -1,3 +1,3 @@
 [uwsgi]
-main_plugin = python,gevent,psgi,lua,php,rack,jvm,jwsgi,ring,mono,transformation_toupper,coroae,v8,cgi,xslt,webdav,ssi,ldap,gccgo,rados,pypy,zabbix,curl_cron,tornado,tuntap,pty,mongrel2,alarm_curl,router_radius,airbrake
+main_plugin = python,gevent,psgi,lua,php,rack,jvm,jwsgi,ring,mono,transformation_toupper,coroae,v8,cgi,xslt,webdav,ssi,ldap,gccgo,rados,pypy,zabbix,curl_cron,tornado,tuntap,pty,mongrel2,alarm_curl,router_radius,airbrake,gridfs
 inherit = base
diff --git a/contrib/pypy/uwsgi_pypy_greenlets.py b/contrib/pypy/uwsgi_pypy_greenlets.py
index f915caf..7843f17 100644
--- a/contrib/pypy/uwsgi_pypy_greenlets.py
+++ b/contrib/pypy/uwsgi_pypy_greenlets.py
@@ -54,7 +54,7 @@ def uwsgi_pypy_greenlet_switch(wsgi_req):
     # update current running greenlet
     lib.uwsgi.wsgi_req = wsgi_req
 
-if lib.uwsgi.async <= 1:
+if lib.uwsgi.async < 1:
     raise Exception("pypy greenlets require async mode !!!")
 lib.uwsgi.schedule_to_main = uwsgi_pypy_greenlet_switch
 lib.uwsgi.schedule_to_req = uwsgi_pypy_greenlet_schedule
diff --git a/contrib/uwsgi.class b/contrib/uwsgi.class
deleted file mode 100644
index be15f4d6e62c49ba522fcb2e95aa6e58214cba43..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 5634
zcma)A3w%@68ULSqZ*p&w+cpif5TQ_zM_Wn*IIFgZmJ(=$HYH8L3R*&YZ9~%}CO1$}
zL40iZm@m`~pZJ*d{hFrKBD%Supl;61ZB9|=+|*5-ZgXycW8b-XG_*zi74Es`d%w>2
zo!tHZdwLImd2E&iXJbnaR^uZ6w$(y!7h7=&E>&=ug6~?e5Z{xrO~K_B<lqVg=Wy(m
z9DWri{=ST>6<lM14cE%J&Vn)6BI9}s3bCC7Z;){#UvIKtJbqxs53z%@-OLGYQE)3?
zZ?ocd+@WA6U++|K7hmsIa1UR9WWjvgtDui>?o)6-UmuY1pam7!!XFPQc$lw`D0o!C
zW8AdI6+FS|e#{?FDtL;o2?hOp-KAha#?xHxAb&i<fxE4E27CD9SsBl989!0*Q@%dW
z(LdvM{+vJdau;9Vuoo@ZhyC1}mlV9rNnhdOe!-pmrGi)a`YZ1CYZm+(zu|AMbLQVF
z_#Iz=uiy>N^#=uS%6Lo00R~G?I3Cg?;Xp`durFKZU+;GY{h>~0vmOnEI%^or^8=xP
zzJNh2EnC4L)rC7WhWurLkk%OQS*t~T{<T4ZNSutJq|^}7>x^m9^+8Q{HYeA*aOm7X
zXAKvT+pPQByBquwgOj``GhDsxT0{?oLopd|lhTfGQ#eNAyu-zH>3YOjPmh#buXbKs
zi|IAPw2mZ;MM$_t2FQ4a!PF66qLF+xzOs3VyWSt_2x?IyDDTSnBh?ty7L^qhlZ^Ld
z{7J_9Wcb>Ry4Due{2f8^o?&*<IA<X2T;$jN?ocGIQ`|IvPfgiqq0EVG@JE`v!ckHz
zl{S|(ljF_dc(h$x9N;0e#5cq`1C=}pD%OA==b%kR2Q(Fb#$RN7pyES(!~lkg;b>>2
zKjLri(kk0YIa%bdbT_W>EOmJ+Rs0oyW0=Y%4P~MwMB6}+rz;a~hRQmBC=}L90-^Qc
zZmq<KM=G`@dRH_Y@9d&gOW~v3u#Z)If=^Za9iOQPp_|IVD4Y;aceuTq2R0`dZubYf
zD2bfobB1DrghI8Df>;}k`Zs#wdM02D<I{K^%4`(p|A&fy;$IBovWc?dt>O#(n-hLX
z+2geTQE@&lQ1M?JWXSWnmbbW?eQgacU%h9MibMEV#=9yG^I)ok^R~7%`@HVPB`Ut+
zFl)2RyTavdYpiW>srX+usLA8?sW?KeGcZQ3r%0Q;9-pVqvrJ`zL7vvx;&rP`<e;SS
zS*L4ZJP_>AqAHV^iG-a-5|f(hyzVBSp_~HQRO_p6b2l#bsLae2TD`6YkI&UsyJ(SD
zWimcenUd0Iz+1>5mE~}dTIXr>xf*?KzSbs}$}ISdf{}(Tb2TpU)iV?rF*VF`hjguz
z45C0DRGF2jRQW2)WqB&gXEp}g5NWbMsH}kNG1dEgO>HW(voR_gOQpdIxqu=bq;WiX
zU$F5qbExb%HbKQkY$9(<R5p<nt85aRtg;fGCZU>OQ`l6M9nYrGu~XS}HbZ4ISt-47
z0#j{sotvTwd`i@-Ln<p{<@_y5IOFUvOyVXE)%@^2FoGae>RAV3OuEM0o-F9}ua}!@
zLku&%i7wfP7^WOen6e|g@EHmXQ{s9c=yZkRJzCVyTO@hBY9S?~Q`1vi$>z#1xir~#
zhWtN@fV%mFQMIP|^M*t=`g^D&jZFz0HWMr{-5=FsD+78L8JX&WS%qCwcGfZA)c(2M
zZkiQM{wV3tHA>!$(L{{aLCrxe)XA07Fmf{#jl$>VBgQe*nX@BmjGuhcpADqellGFj
zQ#OX;#Uql{XXp@T(Pkltbo`LcYy>xF`mypdOq*pxG@xsl31PUBgz=^sqh>(nG-!HP
zxFc!W^0*e=m^_L!o(ReFtwoc`8`?J+BS+E0Y0|<{_ox%fN+Oz~VLjX)4kiVr3Y)qZ
zO=W*1qJ>Cxdhi{U@)7w;wKob)PAtAQW?U%JLVLnA1Ufn>_uNXa#`i5TUJE?pRFAqA
z(tR5vRD--;Qh;Tt>~orW8pBCXDK3t5R)(JyQl8)Ck2Qp&nk%UFkWiwg;-UJqhO}Ni
z1sq=Kp0(?=cAc25dbow0j@J2OWQrWsB0+yUy%m+#)r}fKo}r{^<hGGco;sTMvA`xS
z!2tQf4AYKP6WPT>_bHn5&g7hTrsurV@Y3z^g~LH|M>;nc-avzV^!iJtWq4)tsx-wS
zL4IW`9rYBg8j(*5hZ6BeV;YT#V;pZPlAIV-q3+k?yj=Yq9qC}q97W4W72Ga~->@iD
zrK=XY-TauFjG$#8M51t#WMC<o)C?`D%+v;{ZcqMpszz$Z6uMlWO+Qqq#qzrsy~*@W
zS2237rQHmI)A)g<ydN}ro`UeWLEX+_gaZ^v^v3w5jrN?U4<h{mE6Zo~Lo81~8i0wR
zq2dLY?dFCGyPSZs1G$69X|-GWVSSd<*wq2#3fPOO<yl)&SpFo01oEW2p=1mYzzwK`
zm7cjUA)o$ibmK2T5$u>uZ)Nm$62@UM{U}%t2UcJr&LwIK#KS0((P^(h7wsi7JwX50
zp*v;%@hS7=@>v!A$RF<S6qqs9U^Np%&|vQQw#+k#dFD~f0>4itHJd*mY(AN^e-O4-
zdqIJ9Uq9@PgBa7=kFnL#APQR@Qa_5SP5gCs0^|6`Jc#jp<LJk6)pErECNNYhVpWdA
zRBp@b$HWAR9VYvv1SS(?)&NQvD4yHXm^6fAZE6~7pF;G6n#w38(~^wzK8(?TOzs2e
z5)C!wHfu)0@fnTNMlc!>L*o$r^bGwBhFzFBOjjCcaOG#TlxDcfMrbi0!?aLwW&G+*
zI!KCc$I_&avkW29nha)5CQyT@phV0jj6qascP3DormIX~4oU9A!fZJi-ZT>tO!;~O
zUhaG0B%-WP&P_U*Itm%7$-UuVP9`Aph&CytDqB;Ew<E)xG${p6-~_|^Z!qp?tG<)8
ziUgfFBJ>7?2fB(E&<RH~o|IuE?65Q&5YBjVhH<DUPsuP6b{L}p;f&Rcz8##-H4asO
z4KWU4erpolk5dy^P;DU^hb3DK-%XaPa)|6SIz<*%ZFN`%a5}>dT%6j}GCYTc3DgnJ
zRGumd`y#3Zht)RQ)|P;a-i>k?I%Ho<#uGTpVI9C?;b^Bau*rQ#HaX06#FjYB<qlH<
z_31Pwfs(_VfV(hf2lB}DGw6O`-i4)Nm0IqQ`?0J#*O6;C-wSgemK3TtqlC5%#L-xt
zSK-K$=Iw%K08Ij<Dzy(&3Avn95Ymyi$Fvh;iAJ2q=?35x(RbwG0vmQK)wyC-o<nxz
zinL9jxhk)aj*-ow5Tr0K0bk#d_j&U)dNq51IxH}ox^*Rr;H1Gbm)_=~1}CD9I`v|l
zLVda#XA-2FKJu)`0&K-;*oM<_9cpn8eaCqMF6s;Qcph%-#~C<)rSy5Afqwlq;vhWC
zh9))%URH)?HU~adhZfd|m8=zKvNdRB0i4C+SjBF@YW57;*sEB>-bM%e92z@}fFNR>
zkcV!e5J6!EdITrV6RHsvY7rCap$qMZ3+JO(xEdRU9k@Wa2NwztVzaOZTZDbsD!hh^
zg#)-mcpsMvU*a-Rz&6o}%f%vGAr|9GaSpB$YjBOY2-k`pTqmx;^<o#ciyLr*xEVK!
zTXBncIc^oN!foPBxLw?VJH-32Q+yS7il5;w$%MP5Li9-!aGz9;`=vQ}P&x^ZNb~Wi
zv;<E`XW&W6i>IVkB&5~YCHXNRb>nHN7lYFI*ez|w9%&n%m9D{a(rwr)?Zk^xANENP
z;3XO>FH5`einI@}8*_3M3Xf30Ei%F~A~MdCL7$80W0h|Fi_2I~_X5))CY2P=JA|dh
zhtPHMA-KNcEE{OP9>TV{hapg43urgxASMZ4AxB0prHBvS^z;<?&*RkS?WNHx5$=T4
z%xjpHK+A$+n`I|2U28>g0xSBCd{SXwnZTL$Ry&pOS@u=N@>sgkFo~`(z#DWid6TN`
zExHRFpo)736YwtK-ZQ+*=eGcb{5gzVc90m-SAif|Lf=v7Lcnh_b7{xzDVShWHf=wZ
kp1s=_Of0@=`$Gg|#vLTjxa#o9{UKC*M9>QfCt&mc0VqV6K>z>%

diff --git a/core/async.c b/core/async.c
index 41651fd..c3da5cd 100644
--- a/core/async.c
+++ b/core/async.c
@@ -21,7 +21,7 @@ extern struct uwsgi_server uwsgi;
 
 // this is called whenever a new connection is ready, but there are no cores to handle it
 void uwsgi_async_queue_is_full(time_t now) {
-	if (now > uwsgi.async_queue_is_full) {
+	if (now > uwsgi.async_queue_is_full && uwsgi.async_warn_if_queue_full) {
 		uwsgi_log_verbose("[DANGER] async queue is full !!!\n");
 		uwsgi.async_queue_is_full = now;
 	}
@@ -165,7 +165,7 @@ static void async_expire_timeouts(uint64_t now) {
 
 int async_add_fd_read(struct wsgi_request *wsgi_req, int fd, int timeout) {
 
-	if (uwsgi.async < 2 || !uwsgi.async_waiting_fd_table){ 
+	if (uwsgi.async < 1 || !uwsgi.async_waiting_fd_table){ 
 		uwsgi_log_verbose("ASYNC call without async mode !!!\n");
 		return -1;
 	}
@@ -257,7 +257,7 @@ static int async_wait_fd_read2(int fd0, int fd1, int timeout, int *fd) {
 
 void async_add_timeout(struct wsgi_request *wsgi_req, int timeout) {
 
-	if (uwsgi.async < 2 || !uwsgi.rb_async_timeouts) {
+	if (uwsgi.async < 1 || !uwsgi.rb_async_timeouts) {
 		uwsgi_log_verbose("ASYNC call without async mode !!!\n");
 		return;
 	}
@@ -272,7 +272,7 @@ void async_add_timeout(struct wsgi_request *wsgi_req, int timeout) {
 
 int async_add_fd_write(struct wsgi_request *wsgi_req, int fd, int timeout) {
 
-	if (uwsgi.async < 2 || !uwsgi.async_waiting_fd_table) {
+	if (uwsgi.async < 1 || !uwsgi.async_waiting_fd_table) {
 		uwsgi_log_verbose("ASYNC call without async mode !!!\n");
 		return -1;
 	}
@@ -369,7 +369,8 @@ void async_schedule_to_req_green(void) {
 			uwsgi.schedule_fix(wsgi_req);
 		}
                 // switch after each yield
-                uwsgi.schedule_to_main(wsgi_req);
+		if (uwsgi.schedule_to_main)
+                	uwsgi.schedule_to_main(wsgi_req);
         }
 
 #ifdef UWSGI_ROUTING
@@ -384,7 +385,6 @@ end:
         wsgi_req->async_status = UWSGI_OK;
 	uwsgi.async_queue_unused_ptr++;
         uwsgi.async_queue_unused[uwsgi.async_queue_unused_ptr] = wsgi_req;
-	
 }
 
 static int uwsgi_async_wait_milliseconds_hook(int timeout) {
@@ -406,7 +406,7 @@ static int uwsgi_async_wait_milliseconds_hook(int timeout) {
 
 void async_loop() {
 
-	if (uwsgi.async < 2) {
+	if (uwsgi.async < 1) {
 		uwsgi_log("the async loop engine requires async mode (--async <n>)\n");
 		exit(1);
 	}
@@ -481,7 +481,12 @@ void async_loop() {
 
 			// signals are executed in the main stack... in the future we could have dedicated stacks for them
 			if (uwsgi.signal_socket > -1 && (interesting_fd == uwsgi.signal_socket || interesting_fd == uwsgi.my_signal_socket)) {
-				uwsgi_receive_signal(interesting_fd, "worker", uwsgi.mywid);
+				uwsgi.wsgi_req = find_first_available_wsgi_req();
+                                if (uwsgi.wsgi_req == NULL) {
+                                	uwsgi_async_queue_is_full((time_t)now);
+                                        continue; 
+                                }
+				uwsgi_receive_signal(uwsgi.wsgi_req, interesting_fd, "worker", uwsgi.mywid);
 				continue;
 			}
 
diff --git a/core/buffer.c b/core/buffer.c
index 7dff31e..e880069 100644
--- a/core/buffer.c
+++ b/core/buffer.c
@@ -128,7 +128,16 @@ int uwsgi_buffer_append_json(struct uwsgi_buffer *ub, char *buf, size_t len) {
 	// need to escape \ and "
 	size_t i;
 	for(i=0;i<len;i++) {
-		if (buf[i] == '"') {
+		if (buf[i] == '\t') {
+			if (uwsgi_buffer_append(ub, "\\t", 2)) return -1;
+		}
+		else if (buf[i] == '\n') {
+			if (uwsgi_buffer_append(ub, "\\n", 2)) return -1;
+		}
+		else if (buf[i] == '\r') {
+			if (uwsgi_buffer_append(ub, "\\r", 2)) return -1;
+		}
+		else if (buf[i] == '"') {
 			if (uwsgi_buffer_append(ub, "\\\"", 2)) return -1;
 		}
 		else if (buf[i] == '\\') {
@@ -141,6 +150,32 @@ int uwsgi_buffer_append_json(struct uwsgi_buffer *ub, char *buf, size_t len) {
 	return 0;
 }
 
+int uwsgi_buffer_append_xml(struct uwsgi_buffer *ub, char *buf, size_t len) {
+        // need to escape \ and "
+        size_t i;
+        for(i=0;i<len;i++) {
+                if (buf[i] == '"') {
+                        if (uwsgi_buffer_append(ub, "&quot;", 6)) return -1;
+                }
+                else if (buf[i] == '\'') {
+                        if (uwsgi_buffer_append(ub, "&apos;", 6)) return -1;
+                }
+                else if (buf[i] == '<') {
+                        if (uwsgi_buffer_append(ub, "&lt;", 4)) return -1;
+                }
+                else if (buf[i] == '>') {
+                        if (uwsgi_buffer_append(ub, "&gt;", 4)) return -1;
+                }
+                else if (buf[i] == '&') {
+                        if (uwsgi_buffer_append(ub, "&amp;", 5)) return -1;
+                }
+                else {
+                        if (uwsgi_buffer_append(ub, buf+i, 1)) return -1;
+                }
+        }
+        return 0;
+}
+
 int uwsgi_buffer_u16le(struct uwsgi_buffer *ub, uint16_t num) {
 	uint8_t buf[2];
 	buf[0] = (uint8_t) (num & 0xff);
@@ -409,3 +444,10 @@ void uwsgi_buffer_map(struct uwsgi_buffer *ub, char *buf, size_t len) {
 	ub->pos = len;
 	ub->len = len;
 }
+
+int uwsgi_buffer_httpdate(struct uwsgi_buffer *ub, time_t t) {
+	char http_last_modified[49];
+        int size = uwsgi_http_date(t, http_last_modified);
+	if (size <= 0) return -1;
+	return uwsgi_buffer_append(ub, http_last_modified, size);
+}
diff --git a/core/cache.c b/core/cache.c
index df8b728..c45d069 100644
--- a/core/cache.c
+++ b/core/cache.c
@@ -331,6 +331,14 @@ void uwsgi_cache_init(struct uwsgi_cache *uc) {
 		int cache_fd;
 		struct stat cst;
 
+        if (uc->store_delete && !stat(uc->store, &cst) && ((size_t) cst.st_size != uc->filesize || !S_ISREG(cst.st_mode))) {
+            uwsgi_log("Removing invalid cache store file: %s\n", uc->store);
+            if (unlink(uc->store) != 0) {
+                uwsgi_log("Cannot remove invalid cache store file: %s\n", uc->store);
+                exit(1);
+            }
+        }
+
 		if (stat(uc->store, &cst)) {
 			uwsgi_log("creating a new cache store file: %s\n", uc->store);
 			cache_fd = open(uc->store, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
@@ -733,16 +741,22 @@ int uwsgi_cache_set2(struct uwsgi_cache *uc, char *key, uint16_t keylen, char *v
 		else {
 			uci->first_block = uwsgi_cache_find_free_blocks(uc, vallen);
 			if (uci->first_block == 0xffffffffffffffffLLU) {
-				if (!uc->ignore_full)
-					uwsgi_log("*** DANGER cache \"%s\" is FULL !!! ***\n", uc->name);
+				if (!uc->ignore_full) {
+					if (uc->purge_lru)
+                                        	uwsgi_log("LRU item will be purged from cache \"%s\"\n", uc->name);
+					else
+						uwsgi_log("*** DANGER cache \"%s\" is FULL !!! ***\n", uc->name);
+				}
                                 uc->full++;
 				uc->unused_blocks_stack_ptr++;
+				if (uc->purge_lru && uc->lru_head)
+                                	uwsgi_cache_del2(uc, NULL, 0, uc->lru_head, UWSGI_CACHE_FLAG_LOCAL);
                                 goto end;
 			}
 			// mark used blocks;
 			uint64_t needed_blocks = cache_mark_blocks(uc, uci->first_block, vallen);
 			// optimize the scan
-			if (uc->blocks_bitmap_pos + needed_blocks > uc->blocks) {
+			if (uci->first_block + needed_blocks >= uc->blocks) {
                         	uc->blocks_bitmap_pos = 0;
                         }
                         else {
@@ -837,16 +851,22 @@ int uwsgi_cache_set2(struct uwsgi_cache *uc, char *key, uint16_t keylen, char *v
 			uint64_t old_first_block = uci->first_block;
 			uci->first_block = uwsgi_cache_find_free_blocks(uc, vallen);
                         if (uci->first_block == 0xffffffffffffffffLLU) {
-				if (!uc->ignore_full)
-					uwsgi_log("*** DANGER cache \"%s\" is FULL !!! ***\n", uc->name);
+				if (!uc->ignore_full) {
+                                        if (uc->purge_lru)
+                                                uwsgi_log("LRU item will be purged from cache \"%s\"\n", uc->name);
+                                        else
+                                                uwsgi_log("*** DANGER cache \"%s\" is FULL !!! ***\n", uc->name);
+                                }
                                 uc->full++;
 				uci->first_block = old_first_block;
+				if (uc->purge_lru && uc->lru_head)
+                                        uwsgi_cache_del2(uc, NULL, 0, uc->lru_head, UWSGI_CACHE_FLAG_LOCAL);
                                 goto end;
                         }
                         // mark used blocks;
                         uint64_t needed_blocks = cache_mark_blocks(uc, uci->first_block, vallen);
                         // optimize the scan
-                        if (uc->blocks_bitmap_pos + needed_blocks > uc->blocks) {
+                        if (uci->first_block + needed_blocks >= uc->blocks) {
                                 uc->blocks_bitmap_pos = 0;
                         }
                         else {
@@ -928,7 +948,7 @@ static void cache_send_udp_command(struct uwsgi_cache *uc, char *key, uint16_t k
 		iov[2].iov_base = key;
 		iov[2].iov_len = keylen;
 
-		uh.pktsize = 2 + keylen;
+		uh._pktsize = 2 + keylen;
 
 		if (cmd == 10) {
 			u_v[0] = (uint8_t) (vallen16 & 0xff);
@@ -952,7 +972,7 @@ static void cache_send_udp_command(struct uwsgi_cache *uc, char *key, uint16_t k
                 	iov[6].iov_base = es;
                 	iov[6].iov_len = es_size;
 
-			uh.pktsize += 2 + vallen16 + 2 + es_size;
+			uh._pktsize += 2 + vallen16 + 2 + es_size;
 		}
 
 		uh.modifier1 = 111;
@@ -1212,6 +1232,7 @@ struct uwsgi_cache *uwsgi_cache_create(char *arg) {
 		char *c_keysize = NULL;
 		char *c_store = NULL;
 		char *c_store_sync = NULL;
+		char *c_store_delete = NULL;
 		char *c_nodes = NULL;
 		char *c_sync = NULL;
 		char *c_udp_servers = NULL;
@@ -1236,6 +1257,8 @@ struct uwsgi_cache *uwsgi_cache_create(char *arg) {
                         "store", &c_store,
                         "store_sync", &c_store_sync,
                         "storesync", &c_store_sync,
+                        "store_delete", &c_store_delete,
+                        "storedelete", &c_store_delete,
                         "node", &c_nodes,
                         "nodes", &c_nodes,
                         "sync", &c_sync,
@@ -1299,6 +1322,8 @@ struct uwsgi_cache *uwsgi_cache_create(char *arg) {
 		if (c_use_last_modified) uc->use_last_modified = 1;
 		if (c_ignore_full) uc->ignore_full = 1;
 
+		if (c_store_delete) uc->store_delete = 1;
+
 		if (c_math_initial) uc->math_initial = strtol(c_math_initial, NULL, 10);
 
 		uc->store_sync = uwsgi.cache_store_sync;
diff --git a/core/config.c b/core/config.c
index d75b427..1869367 100644
--- a/core/config.c
+++ b/core/config.c
@@ -294,6 +294,26 @@ int uwsgi_logic_opt_if_not_plugin(char *key, char *value) {
         return 0;
 }
 
+int uwsgi_logic_opt_if_hostname(char *key, char *value) {
+
+        if (!strcmp(uwsgi.hostname, uwsgi.logic_opt_data)) {
+                add_exported_option(key, uwsgi_substitute(value, "%(_)", uwsgi.logic_opt_data), 0);
+                return 1;
+        }
+
+        return 0;
+}
+
+int uwsgi_logic_opt_if_not_hostname(char *key, char *value) {
+
+        if (strcmp(uwsgi.hostname, uwsgi.logic_opt_data)) {
+                add_exported_option(key, uwsgi_substitute(value, "%(_)", uwsgi.logic_opt_data), 0);
+                return 1;
+        }
+
+        return 0;
+}
+
 int uwsgi_count_options(struct uwsgi_option *uopt) {
 
         struct uwsgi_option *aopt;
diff --git a/core/daemons.c b/core/daemons.c
index 85af8e8..c121e47 100644
--- a/core/daemons.c
+++ b/core/daemons.c
@@ -237,7 +237,12 @@ void uwsgi_detach_daemons() {
 			time_t timeout = uwsgi_now() + (uwsgi.reload_mercy ? uwsgi.reload_mercy : 3);
 			int waitpid_status;
 			while (!kill(ud->pid, 0)) {
-				kill(-(ud->pid), ud->stop_signal);
+				if (uwsgi_instance_is_reloading && ud->reload_signal > 0) {
+					kill(-(ud->pid), ud->reload_signal);
+				}
+				else {
+					kill(-(ud->pid), ud->stop_signal);
+				}
 				sleep(1);
 				waitpid(ud->pid, &waitpid_status, WNOHANG);
 				if (uwsgi_now() >= timeout) {
@@ -292,11 +297,18 @@ void uwsgi_spawn_daemon(struct uwsgi_daemon *ud) {
 		uwsgi_close_all_sockets();
 		uwsgi_close_all_fds();
 
+		if (ud->chdir) {
+			if (chdir(ud->chdir)) {
+				uwsgi_error("uwsgi_spawn_daemon()/chdir()");
+				exit(1);
+			}
+		}
+
 #if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL) && defined(CLONE_NEWPID)
 		if (ud->ns_pid) {
 			// we need to create a new session
 			if (setsid() < 0) {
-				uwsgi_error("setsid()");
+				uwsgi_error("uwsgi_spawn_daemon()/setsid()");
 				exit(1);
 			}
 			// avoid the need to set stop_signal in attach-daemon2
@@ -497,6 +509,7 @@ void uwsgi_opt_add_daemon2(char *opt, char *value, void *none) {
 	char *d_uid = NULL;
 	char *d_gid = NULL;
 	char *d_ns_pid = NULL;
+	char *d_chdir = NULL;
 
 	char *arg = uwsgi_str(value);
 
@@ -518,6 +531,7 @@ void uwsgi_opt_add_daemon2(char *opt, char *value, void *none) {
 		"uid", &d_uid,	
 		"gid", &d_gid,	
 		"ns_pid", &d_ns_pid,	
+		"chdir", &d_chdir,	
 	NULL)) {
 		uwsgi_log("invalid --%s keyval syntax\n", opt);
 		exit(1);
@@ -565,6 +579,8 @@ void uwsgi_opt_add_daemon2(char *opt, char *value, void *none) {
 #endif
         uwsgi_ud->ns_pid = d_ns_pid ? 1 : 0;
 
+	uwsgi_ud->chdir = d_chdir;
+
 	if (d_touch) {
 		size_t i,rlen = 0;
 		char **argv = uwsgi_split_quoted(d_touch, strlen(d_touch), ";", &rlen);
diff --git a/core/emperor.c b/core/emperor.c
index 6d9cecd..19d0f71 100644
--- a/core/emperor.c
+++ b/core/emperor.c
@@ -5,7 +5,6 @@ The uWSGI Emperor
 */
 #include <uwsgi.h>
 
-
 extern struct uwsgi_server uwsgi;
 extern char **environ;
 
@@ -37,6 +36,142 @@ struct uwsgi_emperor_blacklist_item {
 
 struct uwsgi_emperor_blacklist_item *emperor_blacklist;
 
+char *vassal_attr_get(struct uwsgi_instance *c_ui, char *attr) {
+	if (!attr) return NULL;
+	struct uwsgi_dyn_dict *attrs = c_ui->attrs;
+	while(attrs) {
+		if (!strcmp(attrs->key, attr)) {
+			return attrs->value;
+		}
+		attrs = attrs->next;
+	}
+	return NULL;
+}
+
+int vassal_attr_get_multi(struct uwsgi_instance *c_ui, char *attr, int (*func)(struct uwsgi_instance *, char *, void *), void *data) {
+	if (!attr) return -1;
+        struct uwsgi_dyn_dict *attrs = c_ui->attrs;
+        while(attrs) {
+                if (!strcmp(attrs->key, attr)) {
+			if (func(c_ui, attrs->value, data)) {
+				return -1;
+			}
+                }
+                attrs = attrs->next;
+        }
+        return 0;
+}
+
+// this generates the argv for the new vassal
+static char **vassal_new_argv(struct uwsgi_instance *n_ui, int *slot_to_free) {
+
+	int counter = 4;
+	struct uwsgi_string_list *uct;
+	uwsgi_foreach(uct, uwsgi.vassals_templates_before) counter += 2;
+	uwsgi_foreach(uct, uwsgi.vassals_includes_before) counter += 2;
+	uwsgi_foreach(uct, uwsgi.vassals_set) counter += 2;
+	uwsgi_foreach(uct, uwsgi.vassals_templates) counter += 2;
+	uwsgi_foreach(uct, uwsgi.vassals_includes) counter += 2;
+
+	char **vassal_argv = uwsgi_malloc(sizeof(char *) * counter);
+	// set args
+	vassal_argv[0] = uwsgi.emperor_wrapper ? uwsgi.emperor_wrapper : uwsgi.binary_path;
+	char *wrapper_attr = vassal_attr_get(n_ui, uwsgi.emperor_wrapper_attr);
+	if (wrapper_attr) vassal_argv[0] = wrapper_attr;
+
+	// reset counter
+	counter = 1;
+
+	uwsgi_foreach(uct, uwsgi.vassals_templates_before) {
+		vassal_argv[counter] = "--inherit";
+		vassal_argv[counter + 1] = uct->value;
+		counter += 2;
+	}
+
+	uwsgi_foreach(uct, uwsgi.vassals_includes_before) {
+		vassal_argv[counter] = "--include";
+		vassal_argv[counter + 1] = uct->value;
+		counter += 2;
+	}
+
+	uwsgi_foreach(uct, uwsgi.vassals_set) {
+		vassal_argv[counter] = "--set";
+		vassal_argv[counter + 1] = uct->value;
+		counter += 2;
+	}
+
+	char *colon = NULL;
+	if (uwsgi.emperor_broodlord) {
+		colon = strchr(n_ui->name, ':');
+		if (colon) {
+			colon[0] = 0;
+		}
+	}
+	// initialize to a default value
+	vassal_argv[counter] = "--inherit";
+
+	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 4), ".xml"))
+		vassal_argv[counter] = "--xml";
+	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 4), ".ini"))
+		vassal_argv[counter] = "--ini";
+	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 4), ".yml"))
+		vassal_argv[counter] = "--yaml";
+	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 5), ".yaml"))
+		vassal_argv[counter] = "--yaml";
+	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 3), ".js"))
+		vassal_argv[counter] = "--json";
+	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 5), ".json"))
+		vassal_argv[counter] = "--json";
+	struct uwsgi_string_list *usl = uwsgi.emperor_extra_extension;
+	while (usl) {
+		if (uwsgi_endswith(n_ui->name, usl->value)) {
+			vassal_argv[counter] = "--config";
+			break;
+		}
+		usl = usl->next;
+	}
+	if (colon)
+		colon[0] = ':';
+
+	// start config filename...
+	counter++;
+
+	vassal_argv[counter] = n_ui->name;
+	if (uwsgi.emperor_magic_exec) {
+		if (!access(n_ui->name, R_OK | X_OK)) {
+			vassal_argv[counter] = uwsgi_concat2("exec://", n_ui->name);
+			if (slot_to_free)
+				*slot_to_free = counter;
+		}
+
+	}
+	else if (n_ui->use_config) {
+		vassal_argv[counter] = uwsgi_concat2("emperor://", n_ui->name);
+		if (slot_to_free)
+			*slot_to_free = counter;
+	}
+
+	// start templates,includes,inherit...
+	counter++;
+
+	uwsgi_foreach(uct, uwsgi.vassals_templates) {
+		vassal_argv[counter] = "--inherit";
+		vassal_argv[counter + 1] = uct->value;
+		counter += 2;
+	}
+
+	uwsgi_foreach(uct, uwsgi.vassals_includes) {
+		vassal_argv[counter] = "--include";
+		vassal_argv[counter + 1] = uct->value;
+		counter += 2;
+	}
+
+	vassal_argv[counter] = NULL;
+
+	return vassal_argv;
+}
+
+
 /*
 this should be placed in core/socket.c but we realized it was needed
 only after 2.0 so we cannot change uwsgi.h
@@ -116,7 +251,7 @@ struct uwsgi_emperor_blacklist_item *uwsgi_emperor_blacklist_check(char *id) {
 
 void uwsgi_emperor_blacklist_add(char *id) {
 
-	// check if the item is already in the blacklist        
+	// check if the item is already in the blacklist
 	struct uwsgi_emperor_blacklist_item *uebi = uwsgi_emperor_blacklist_check(id);
 	if (uebi) {
 		gettimeofday(&uebi->last_attempt, NULL);
@@ -211,7 +346,7 @@ int uwsgi_emperor_is_valid(char *name) {
 	return 0;
 }
 
-static char *emperor_check_on_demand_socket(char *filename) {
+static char *emperor_check_on_demand_socket(char *filename, struct uwsgi_dyn_dict *attrs) {
 	size_t len = 0;
 	if (uwsgi.emperor_on_demand_extension) {
 		char *tmp = uwsgi_concat2(filename, uwsgi.emperor_on_demand_extension);
@@ -253,7 +388,7 @@ static char *emperor_check_on_demand_socket(char *filename) {
 	else if (uwsgi.emperor_on_demand_exec) {
 		int cpipe[2];
 		if (pipe(cpipe)) {
-			uwsgi_error("emperor_check_on_demand_socket()pipe()");
+			uwsgi_error("emperor_check_on_demand_socket()/pipe()");
 			return NULL;
 		}
 		char *cmd = uwsgi_concat4(uwsgi.emperor_on_demand_exec, " \"", filename, "\"");
@@ -344,12 +479,41 @@ void uwsgi_imperial_monitor_directory(struct uwsgi_emperor_scanner *ues) {
 			}
 			// check if mtime is changed and the uWSGI instance must be reloaded
 			if (st.st_mtime > ui_current->last_mod) {
+				if (uwsgi.emperor_force_config_pipe) {
+					char *config = uwsgi_simple_file_read(de->d_name);
+					if (!config) {
+						uwsgi_log_verbose("[emperor] unable to read %s\n", de->d_name);
+						emperor_stop(ui_current);
+                                        	continue;
+					}
+					if (ui_current->config)
+                                        	free(ui_current->config);
+                                	ui_current->config = config;
+                                	ui_current->config_len = strlen(ui_current->config);
+				}
 				emperor_respawn(ui_current, st.st_mtime);
 			}
 		}
 		else {
-			char *socket_name = emperor_check_on_demand_socket(de->d_name);
-			emperor_add(ues, de->d_name, st.st_mtime, NULL, 0, t_uid, t_gid, socket_name);
+			struct uwsgi_dyn_dict *attrs = NULL;
+			if (uwsgi.emperor_collect_attributes) {
+				if (uwsgi_endswith(de->d_name, ".ini")) {
+					uwsgi_emperor_ini_attrs(de->d_name, NULL, &attrs);
+				}
+			}
+			char *socket_name = emperor_check_on_demand_socket(de->d_name, attrs);
+			if (uwsgi.emperor_force_config_pipe) {
+				char *config = uwsgi_simple_file_read(de->d_name);
+				if (config) {
+					emperor_add_with_attrs(ues, de->d_name, st.st_mtime, config, strlen(config), t_uid, t_gid, socket_name, attrs);
+				}
+				else {
+					uwsgi_log_verbose("[emperor] unable to read %s\n", de->d_name);
+				}
+			}
+			else {
+				emperor_add_with_attrs(ues, de->d_name, st.st_mtime, NULL, 0, t_uid, t_gid, socket_name, attrs);
+			}
 			if (socket_name)
 				free(socket_name);
 		}
@@ -465,14 +629,43 @@ void uwsgi_imperial_monitor_glob(struct uwsgi_emperor_scanner *ues) {
 			}
 			// check if mtime is changed and the uWSGI instance must be reloaded
 			if (st.st_mtime > ui_current->last_mod) {
+				if (uwsgi.emperor_force_config_pipe) {
+                                        char *config = uwsgi_simple_file_read(g.gl_pathv[i]);
+                                        if (!config) {
+                                                uwsgi_log_verbose("[emperor] unable to read %s\n", g.gl_pathv[i]);
+                                                emperor_stop(ui_current);
+                                                continue;
+                                        }
+                                        if (ui_current->config)
+                                                free(ui_current->config);
+                                        ui_current->config = config;
+                                        ui_current->config_len = strlen(ui_current->config);
+                                }
 				emperor_respawn(ui_current, st.st_mtime);
 			}
 		}
 		else {
-			char *socket_name = emperor_check_on_demand_socket(g.gl_pathv[i]);
-			emperor_add(ues, g.gl_pathv[i], st.st_mtime, NULL, 0, t_uid, t_gid, socket_name);
-			if (socket_name)
-				free(socket_name);
+			struct uwsgi_dyn_dict *attrs = NULL;
+                        if (uwsgi.emperor_collect_attributes) {
+                                if (uwsgi_endswith(g.gl_pathv[i], ".ini")) {
+                                        uwsgi_emperor_ini_attrs(g.gl_pathv[i], NULL, &attrs);
+                                }
+                        }
+                        char *socket_name = emperor_check_on_demand_socket(g.gl_pathv[i], attrs);
+			if (uwsgi.emperor_force_config_pipe) {
+                                char *config = uwsgi_simple_file_read(g.gl_pathv[i]);
+                                if (config) {
+                                        emperor_add_with_attrs(ues, g.gl_pathv[i], st.st_mtime, config, strlen(config), t_uid, t_gid, socket_name, attrs);
+                                }
+                                else {
+                                        uwsgi_log_verbose("[emperor] unable to read %s\n", g.gl_pathv[i]);
+                                }
+                        }
+                        else {
+                                emperor_add_with_attrs(ues, g.gl_pathv[i], st.st_mtime, NULL, 0, t_uid, t_gid, socket_name, attrs);
+                        }	
+                        if (socket_name)
+                                free(socket_name);
 		}
 
 	}
@@ -666,16 +859,12 @@ void emperor_del(struct uwsgi_instance *c_ui) {
 	}
 
 	// this will destroy the whole uWSGI instance (and workers)
-	if (c_ui->pipe[0] != -1)
-		close(c_ui->pipe[0]);
-	if (c_ui->pipe[1] != -1)
-		close(c_ui->pipe[1]);
+	if (c_ui->pipe[0] != -1) close(c_ui->pipe[0]);
+	if (c_ui->pipe[1] != -1) close(c_ui->pipe[1]);
 
 	if (c_ui->use_config) {
-		if (c_ui->pipe_config[0] != -1)
-			close(c_ui->pipe_config[0]);
-		if (c_ui->pipe_config[1] != -1)
-			close(c_ui->pipe_config[1]);
+		if (c_ui->pipe_config[0] != -1) close(c_ui->pipe_config[0]);
+		if (c_ui->pipe_config[1] != -1) close(c_ui->pipe_config[1]);
 	}
 
 	if (uwsgi.vassals_stop_hook) {
@@ -703,15 +892,20 @@ void emperor_del(struct uwsgi_instance *c_ui) {
 		free(c_ui->socket_name);
 	}
 
-	if (c_ui->config)
-		free(c_ui->config);
-
 	if (c_ui->on_demand_fd > -1) {
 		close(c_ui->on_demand_fd);
 	}
+	if (c_ui->config) free(c_ui->config);
 
-	free(c_ui);
+	struct uwsgi_dyn_dict *attr = c_ui->attrs;
+        while(attr) {
+        	struct uwsgi_dyn_dict *tmp = attr;
+                attr = attr->next;
+		if (tmp->value) free(tmp->value);
+                free(tmp);
+        }
 
+	free(c_ui);
 }
 
 void emperor_back_to_ondemand(struct uwsgi_instance *c_ui) {
@@ -737,6 +931,12 @@ void emperor_stop(struct uwsgi_instance *c_ui) {
 		return;
 	// remove uWSGI instance
 
+	// in Zeus mode we need to send
+	// the DESTROY message to all of the nodes
+	if (uwsgi.zeus) {
+		return;
+	}
+
 	if (c_ui->pid != -1) {
 		if (write(c_ui->pipe[0], "\0", 1) != 1) {
 			uwsgi_error("emperor_stop()/write()");
@@ -769,7 +969,7 @@ static void emperor_push_config(struct uwsgi_instance *c_ui) {
 
 	if (c_ui->use_config) {
 		uh.modifier1 = 115;
-		uh.pktsize = c_ui->config_len;
+		uh._pktsize = c_ui->config_len;
 		uh.modifier2 = 0;
 		if (write(c_ui->pipe_config[0], &uh, 4) != 4) {
 			uwsgi_error("[uwsgi-emperor] write() header config");
@@ -788,6 +988,12 @@ void emperor_respawn(struct uwsgi_instance *c_ui, time_t mod) {
 	if (c_ui->status > 0)
 		return;
 
+	// if in Zeus mode, we need to send
+	// the reload message to all of the nodes
+	if (uwsgi.zeus) {
+		return;
+	}
+
 	// check if we are in on_demand mode (the respawn will be ignored)
 	if (c_ui->pid == -1 && c_ui->on_demand_fd > -1) {
 		c_ui->last_mod = mod;
@@ -796,6 +1002,9 @@ void emperor_respawn(struct uwsgi_instance *c_ui, time_t mod) {
 		// reset accepting
 		c_ui->accepting = 0;
 		uwsgi_log_verbose("[emperor] updated configuration for \"on demand\" instance %s\n", c_ui->name);
+		if (uwsgi_hooks_run_and_return(uwsgi.hook_as_on_config_vassal, "as-on-config-vassal", c_ui->name, 0)) {
+			emperor_curse(c_ui);
+		}
 		return;
 	}
 
@@ -808,7 +1017,8 @@ void emperor_respawn(struct uwsgi_instance *c_ui, time_t mod) {
 	}
 
 	// push the config to the config pipe (if needed)
-	emperor_push_config(c_ui);
+	// changed in 2.1, the vassal asks for config blob
+	//emperor_push_config(c_ui);
 
 	c_ui->respawns++;
 	c_ui->last_mod = mod;
@@ -822,6 +1032,10 @@ void emperor_respawn(struct uwsgi_instance *c_ui, time_t mod) {
 }
 
 void emperor_add(struct uwsgi_emperor_scanner *ues, char *name, time_t born, char *config, uint32_t config_size, uid_t uid, gid_t gid, char *socket_name) {
+	emperor_add_with_attrs(ues, name, born, config, config_size, uid, gid, socket_name, NULL);
+}
+
+void emperor_add_with_attrs(struct uwsgi_emperor_scanner *ues, char *name, time_t born, char *config, uint32_t config_size, uid_t uid, gid_t gid, char *socket_name, struct uwsgi_dyn_dict *attrs) {
 
 	struct uwsgi_instance *c_ui = ui;
 	struct uwsgi_instance *n_ui = NULL;
@@ -912,6 +1126,8 @@ void emperor_add(struct uwsgi_emperor_scanner *ues, char *name, time_t born, cha
 	n_ui->last_loyal = 0;
 	n_ui->loyal = 0;
 
+	n_ui->attrs = attrs;
+
 	n_ui->first_run = uwsgi_now();
 	n_ui->last_run = n_ui->first_run;
 	n_ui->on_demand_fd = -1;
@@ -937,6 +1153,9 @@ void emperor_add(struct uwsgi_emperor_scanner *ues, char *name, time_t born, cha
 
 		event_queue_add_fd_read(uwsgi.emperor_queue, n_ui->on_demand_fd);
 		uwsgi_log("[uwsgi-emperor] %s -> \"on demand\" instance detected, waiting for connections on socket \"%s\" ...\n", name, socket_name);
+		if (uwsgi_hooks_run_and_return(uwsgi.hook_as_on_demand_vassal, "as-on-demand-vassal", name, 0)) {
+			emperor_del(n_ui);
+		}
 		return;
 	}
 
@@ -948,6 +1167,117 @@ void emperor_add(struct uwsgi_emperor_scanner *ues, char *name, time_t born, cha
 
 static void uwsgi_emperor_spawn_vassal(struct uwsgi_instance *);
 
+static void vassal_fork_server_parser_hook(char *key, uint16_t key_len, char *value, uint16_t value_len, void *data) {
+	pid_t *pid = (pid_t *) data;
+
+        if (!uwsgi_strncmp(key, key_len, "pid", 3)) {
+		// ignore negative values
+		if (value_len > 0 && value[0] == '-') return;
+                *pid = uwsgi_str_num(value, value_len);
+        }
+}
+
+
+/*
+	there are max 3 file descriptors we need to pass to the fork server:
+
+	n_ui->pipe[1]
+	n_ui->pipe_config[1]
+	n_ui->on_demand_fd
+
+*/
+static pid_t emperor_connect_to_fork_server(char *socket, struct uwsgi_instance *n_ui) {
+	int fd = uwsgi_connect(socket, uwsgi.socket_timeout, 0);
+	if (fd < 0) {
+		uwsgi_error("emperor_connect_to_fork_server()/uwsgi_connect()");
+		return -1;
+	}
+
+	int slot_to_free = -1;
+	char **vassal_argv = vassal_new_argv(n_ui, &slot_to_free);
+
+	struct uwsgi_buffer *ub = uwsgi_buffer_new(uwsgi.page_size);
+	// leave space for uwsgi header
+	ub->pos = 4;
+	int error = 0, counter = 0;
+	while (vassal_argv[counter]) {
+		if (!error && uwsgi_buffer_u16le(ub, strlen(vassal_argv[counter])))
+			error = 1;
+		if (!error && uwsgi_buffer_append(ub, vassal_argv[counter], strlen(vassal_argv[counter])))
+			error = 1;
+		if (counter == slot_to_free)
+			free(vassal_argv[counter]);
+		counter++;
+	}
+
+	free(vassal_argv);
+	if (error) {
+		uwsgi_log_verbose("[uwsgi-emperor] %s: unable to complete fork-server session\n", n_ui->name);
+		goto end;
+	}
+
+	// bit 0 -> pipe (0x01)
+	// bit 1 -> config_pipe (0x02)
+	// bit 2 -> on_demand (0x04)
+	uint8_t modifier2_mask = 0x01;
+	int fds[8];
+	int fds_count = 1;
+	fds[0] = n_ui->pipe[1];
+
+	// add pipe config ?
+	if (n_ui->use_config) {
+		modifier2_mask |= 0x02;
+		fds[fds_count] = n_ui->pipe_config[1];
+		fds_count++;
+	}
+
+	// add ondemand ?
+	if (n_ui->on_demand_fd > -1) {
+		modifier2_mask |= 0x04;
+		fds[fds_count] = n_ui->on_demand_fd;
+		fds_count++;
+	}
+
+	// fix uwsgi header
+	if (uwsgi_buffer_set_uh(ub, 35, modifier2_mask)) goto end;
+
+	if (uwsgi_send_fds_and_body(fd, fds, fds_count, ub->buf, ub->pos)) {
+		uwsgi_log_verbose("[uwsgi-emperor] %s: unable to complete fork-server session\n", n_ui->name);
+		goto end;
+	}
+
+	uwsgi_buffer_destroy(ub);
+
+	// now wait for the response (the pid number)
+	// the response could contain various info, currently we only need the "pid" attribute
+	size_t buf_len = uwsgi.page_size;
+	char *buf = uwsgi_malloc(buf_len);
+	uint8_t modifier1 = 0;
+	uint8_t modifier2 = 0;
+	int ret = uwsgi_read_with_realloc(fd, &buf, &buf_len, uwsgi.socket_timeout, &modifier1, &modifier2);
+	if (ret) {
+		free(buf);
+		uwsgi_log_verbose("[uwsgi-emperor] %s: unable to complete fork-server session\n", n_ui->name);
+		goto end2;
+	}
+
+	pid_t pid = -1;
+	uwsgi_hooked_parse(buf, buf_len, vassal_fork_server_parser_hook, &pid);
+	free(buf);
+
+	// close the connection
+	close(fd);
+
+	// return the pid to the Emperor
+	return pid;
+
+end:
+	uwsgi_buffer_destroy(ub);
+end2:
+	close(fd);
+	return -1;
+}
+
 int uwsgi_emperor_vassal_start(struct uwsgi_instance *n_ui) {
 
 	pid_t pid;
@@ -972,20 +1302,36 @@ int uwsgi_emperor_vassal_start(struct uwsgi_instance *n_ui) {
 		uwsgi.emperor_broodlord_num++;
 	}
 
-	// TODO pre-start hook
 
-	// a new uWSGI instance will start 
+	if (uwsgi_hooks_run_and_return(uwsgi.hook_as_emperor_before_vassal, "as-emperor-before-vassal", NULL, 0)) {
+        	emperor_del(n_ui);
+        }
+
+	if (uwsgi.zeus) {
+		uwsgi_log("[zeus] ready to spawn instance \"%s\" ...\n", n_ui->name);
+		return uwsgi_zeus_spawn_instance(n_ui);
+	}
+
+	// check for fork server
+	char *fork_server = uwsgi.emperor_use_fork_server;
+	char *fork_server_attr = vassal_attr_get(n_ui, uwsgi.emperor_fork_server_attr);
+	if (fork_server_attr) fork_server = fork_server_attr;
+	// a new uWSGI instance will start
+	if (fork_server && !uwsgi_string_list_has_item(uwsgi.vassal_fork_base, n_ui->name, strlen(n_ui->name))) {
+		// pid can only be > 0 or -1
+		n_ui->adopted = 1;
+		pid = emperor_connect_to_fork_server(fork_server, n_ui);
+	}
 #if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL) && !defined(__ia64__)
-	if (uwsgi.emperor_clone) {
+	else if (uwsgi.emperor_clone) {
 		char stack[PTHREAD_STACK_MIN];
 		pid = clone((int (*)(void *)) uwsgi_emperor_spawn_vassal, stack + PTHREAD_STACK_MIN, SIGCHLD | uwsgi.emperor_clone, (void *) n_ui);
 	}
-	else {
 #endif
+	else {
 		pid = fork();
-#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL) && !defined(__ia64__)
 	}
-#endif
+
 	if (pid < 0) {
 		uwsgi_error("uwsgi_emperor_spawn_vassal()/fork()")
 	}
@@ -1015,14 +1361,14 @@ int uwsgi_emperor_vassal_start(struct uwsgi_instance *n_ui) {
 		uwsgi_foreach(usl, uwsgi.mount_as_emperor) {
 			uwsgi_log("mounting \"%s\" (as-emperor for vassal \"%s\" pid: %d uid: %d gid: %d)...\n", usl->value, n_ui->name, n_ui->pid, n_ui->uid, n_ui->gid);
 			if (uwsgi_mount_hook(usl->value)) {
-				exit(1);
+				uwsgi_log("unable to mount %s\n", usl->value);
 			}
 		}
 
 		uwsgi_foreach(usl, uwsgi.umount_as_emperor) {
 			uwsgi_log("un-mounting \"%s\" (as-emperor for vassal \"%s\" pid: %d uid: %d gid: %d)...\n", usl->value, n_ui->name, n_ui->pid, n_ui->uid, n_ui->gid);
 			if (uwsgi_umount_hook(usl->value)) {
-				exit(1);
+				uwsgi_log("unable to umount %s\n", usl->value);
 			}
 		}
 		uwsgi_foreach(usl, uwsgi.exec_as_emperor) {
@@ -1084,6 +1430,10 @@ int uwsgi_emperor_vassal_start(struct uwsgi_instance *n_ui) {
 				func(n_ui->name, n_ui->pid, n_ui->uid, n_ui->gid);
 			}
 		}
+
+#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL)
+		uwsgi_hooks_setns_run(uwsgi.hook_as_emperor_setns, n_ui->pid, n_ui->uid, n_ui->gid);
+#endif
 		return 0;
 	}
 	else {
@@ -1093,7 +1443,20 @@ int uwsgi_emperor_vassal_start(struct uwsgi_instance *n_ui) {
 }
 
 static void uwsgi_emperor_spawn_vassal(struct uwsgi_instance *n_ui) {
+	int i;
+
+	// run plugin hooks for the vassal
+	for (i = 0; i < 256; i++) {
+                if (uwsgi.p[i]->vassal) {
+                        uwsgi.p[i]->vassal(n_ui);
+                }
+        }
 
+        for (i = 0; i < uwsgi.gp_cnt; i++) {
+                if (uwsgi.gp[i]->vassal) {
+                        uwsgi.gp[i]->vassal(n_ui);
+                }
+        }
 
 #ifdef __linux__
 	if (prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0)) {
@@ -1108,6 +1471,8 @@ static void uwsgi_emperor_spawn_vassal(struct uwsgi_instance *n_ui) {
 	}
 #endif
 
+	uwsgi_hooks_run(uwsgi.hook_as_vassal_before_drop, "as-vassal-before-drop", 1);
+
 #ifdef UWSGI_CAP
 #if defined(CAP_LAST_CAP) && defined(PR_CAPBSET_READ) && defined(PR_CAPBSET_DROP)
 	if (uwsgi.emperor_cap && uwsgi.emperor_cap_count > 0) {
@@ -1237,103 +1602,8 @@ static void uwsgi_emperor_spawn_vassal(struct uwsgi_instance *n_ui) {
 		close(n_ui->pipe_config[0]);
 	}
 
-	int counter = 4;
-	struct uwsgi_string_list *uct;
-	uwsgi_foreach(uct, uwsgi.vassals_templates_before) counter += 2;
-	uwsgi_foreach(uct, uwsgi.vassals_includes_before) counter += 2;
-	uwsgi_foreach(uct, uwsgi.vassals_set) counter += 2;
-	uwsgi_foreach(uct, uwsgi.vassals_templates) counter += 2;
-	uwsgi_foreach(uct, uwsgi.vassals_includes) counter += 2;
+	char **vassal_argv = vassal_new_argv(n_ui, NULL);
 
-	char **vassal_argv = uwsgi_malloc(sizeof(char *) * counter);
-	// set args
-	vassal_argv[0] = uwsgi.emperor_wrapper ? uwsgi.emperor_wrapper : uwsgi.binary_path;
-
-	// reset counter
-	counter = 1;
-
-	uwsgi_foreach(uct, uwsgi.vassals_templates_before) {
-		vassal_argv[counter] = "--inherit";
-		vassal_argv[counter + 1] = uct->value;
-		counter += 2;
-	}
-
-	uwsgi_foreach(uct, uwsgi.vassals_includes_before) {
-		vassal_argv[counter] = "--include";
-		vassal_argv[counter + 1] = uct->value;
-		counter += 2;
-	}
-
-	uwsgi_foreach(uct, uwsgi.vassals_set) {
-		vassal_argv[counter] = "--set";
-		vassal_argv[counter + 1] = uct->value;
-		counter += 2;
-	}
-
-	char *colon = NULL;
-	if (uwsgi.emperor_broodlord) {
-		colon = strchr(n_ui->name, ':');
-		if (colon) {
-			colon[0] = 0;
-		}
-	}
-	// initialize to a default value
-	vassal_argv[counter] = "--inherit";
-
-	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 4), ".xml"))
-		vassal_argv[counter] = "--xml";
-	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 4), ".ini"))
-		vassal_argv[counter] = "--ini";
-	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 4), ".yml"))
-		vassal_argv[counter] = "--yaml";
-	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 5), ".yaml"))
-		vassal_argv[counter] = "--yaml";
-	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 3), ".js"))
-		vassal_argv[counter] = "--json";
-	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 5), ".json"))
-		vassal_argv[counter] = "--json";
-	struct uwsgi_string_list *usl = uwsgi.emperor_extra_extension;
-	while (usl) {
-		if (uwsgi_endswith(n_ui->name, usl->value)) {
-			vassal_argv[counter] = "--config";
-			break;
-		}
-		usl = usl->next;
-	}
-	if (colon)
-		colon[0] = ':';
-
-	// start config filename...
-	counter++;
-
-	vassal_argv[counter] = n_ui->name;
-	if (uwsgi.emperor_magic_exec) {
-		if (!access(n_ui->name, R_OK | X_OK)) {
-			vassal_argv[counter] = uwsgi_concat2("exec://", n_ui->name);
-		}
-
-	}
-
-	if (n_ui->use_config) {
-		vassal_argv[counter] = uwsgi_concat2("emperor://", n_ui->name);
-	}
-
-	// start templates,includes,inherit...
-	counter++;
-
-	uwsgi_foreach(uct, uwsgi.vassals_templates) {
-		vassal_argv[counter] = "--inherit";
-		vassal_argv[counter + 1] = uct->value;
-		counter += 2;
-	}
-
-	uwsgi_foreach(uct, uwsgi.vassals_includes) {
-		vassal_argv[counter] = "--include";
-		vassal_argv[counter + 1] = uct->value;
-		counter += 2;
-	}
-
-	vassal_argv[counter] = NULL;
 
 	// disable stdin OR map it to the "on demand" socket
 	if (n_ui->on_demand_fd > -1) {
@@ -1350,7 +1620,6 @@ static void uwsgi_emperor_spawn_vassal(struct uwsgi_instance *n_ui) {
 	}
 
 	// close all of the unneded fd
-	int i;
 	for (i = 3; i < (int) uwsgi.max_fd; i++) {
 		if (uwsgi_fd_is_safe(i))
 			continue;
@@ -1377,6 +1646,7 @@ static void uwsgi_emperor_spawn_vassal(struct uwsgi_instance *n_ui) {
 
 	uwsgi_hooks_run(uwsgi.hook_as_vassal, "as-vassal", 1);
 
+	struct uwsgi_string_list *usl = NULL;
 	uwsgi_foreach(usl, uwsgi.mount_as_vassal) {
 		uwsgi_log("mounting \"%s\" (as-vassal)...\n", usl->value);
 		if (uwsgi_mount_hook(usl->value)) {
@@ -1429,10 +1699,32 @@ static void uwsgi_emperor_spawn_vassal(struct uwsgi_instance *n_ui) {
 		func(n_ui->name, n_ui->uid, n_ui->gid);
 	}
 
+	char *force_chdir = vassal_attr_get(n_ui, uwsgi.emperor_chdir_attr);
+	if (force_chdir) {
+		if (chdir(force_chdir)) {
+			uwsgi_error("--emperor-chdir-attr/chdir()");
+			exit(UWSGI_EXILE_CODE);
+		}
+	}
+
+	// ->vassal_before_exec
+	for (i = 0; i < 256; i++) {
+                if (uwsgi.p[i]->vassal_before_exec) {
+                        uwsgi.p[i]->vassal_before_exec(n_ui, vassal_argv);
+                }
+        }
+
+        for (i = 0; i < uwsgi.gp_cnt; i++) {
+                if (uwsgi.gp[i]->vassal_before_exec) {
+                        uwsgi.gp[i]->vassal_before_exec(n_ui, vassal_argv);
+                }
+        }
+
 	// start !!!
 	if (execvp(vassal_argv[0], vassal_argv)) {
 		uwsgi_error("execvp()");
 	}
+	uwsgi_log("[emperor] binary path: %s\n", vassal_argv[0]);
 	uwsgi_log("[emperor] is the uwsgi binary in your system PATH ?\n");
 	// never here
 	exit(UWSGI_EXILE_CODE);
@@ -1588,6 +1880,20 @@ static void emperor_cleanup() {
 
 void emperor_loop() {
 
+#if defined(__linux__) && defined(PR_SET_CHILD_SUBREAPER)
+        if (uwsgi.emperor_use_fork_server || uwsgi.emperor_subreaper || uwsgi.emperor_fork_server_attr) {
+                if (prctl(PR_SET_CHILD_SUBREAPER, 1, 0, 0, 0)) {
+                        uwsgi_error("uwsgi_fork_server()/fork()");
+                        exit(1);
+                }
+        }
+#else
+	if (uwsgi.emperor_use_fork_server || uwsgi.emperor_subreaper || uwsgi.emperor_fork_server_attr) {
+		uwsgi_log("*** DANGER: your kernel misses PR_SET_CHILD_SUBREAPER feature, required by the fork server ***\n");
+		uwsgi_log("*** your Emperor will not be able to correctly wait() on vassals ***\n");
+	}
+#endif
+
 	// monitor a directory
 
 	struct uwsgi_instance ui_base;
@@ -1738,6 +2044,8 @@ void emperor_loop() {
 			if (ui_current) {
 				char byte;
 				ssize_t rlen = read(interesting_fd, &byte, 1);
+				// retry if needed
+				if (rlen < 0 && uwsgi_is_again()) continue;
 				if (rlen <= 0) {
 					// SAFE
 					event_queue_del_fd(uwsgi.emperor_queue, interesting_fd, event_queue_read());
@@ -1761,7 +2069,7 @@ void emperor_loop() {
 						ui_current->last_heartbeat = uwsgi_now();
 					}
 					else if (byte == 22) {
-						// command 22 changes meaning when in "on_demand" mode  
+						// command 22 changes meaning when in "on_demand" mode
 						if (ui_current->on_demand_fd != -1) {
 							emperor_back_to_ondemand(ui_current);
 						}
@@ -1874,6 +2182,7 @@ recheck:
 				uwsgi_error("waitpid()");
 			}
 		}
+
 		ui_current = ui;
 		while (ui_current->ui_next) {
 			ui_current = ui_current->ui_next;
@@ -1896,17 +2205,17 @@ recheck:
 							socket_name = uwsgi_str(ui_current->socket_name);
 						}
 						emperor_add(ui_current->scanner, ui_current->name, ui_current->last_mod, config, ui_current->config_len, ui_current->uid, ui_current->gid, socket_name);
-						// temporarily set frequency to 0, so we can eventually fast-restart the instance
 						emperor_del(ui_current);
-						freq = 0;
+						// temporarily set frequency to 1, so we can eventually fast-restart the instance
+						freq = 1;
 					}
 					break;
 				}
 				else if (ui_current->status == 1) {
 					// remove 'marked for dead' instance
 					emperor_del(ui_current);
-					// temporarily set frequency to 0, so we can eventually fast-restart the instance
-					freq = 0;
+					// temporarily set frequency to 1, so we can eventually fast-restart the instance
+					freq = 1;
 					break;
 				}
 				// back to on_demand mode ...
@@ -1924,14 +2233,18 @@ recheck:
 					ui_current->ready = 0;
 					ui_current->accepting = 0;
 					uwsgi_log("[uwsgi-emperor] %s -> back to \"on demand\" mode, waiting for connections on socket \"%s\" ...\n", ui_current->name, ui_current->socket_name);
+					if (uwsgi_hooks_run_and_return(uwsgi.hook_as_on_demand_vassal, "as-on-demand-vassal", ui_current->name, 0)) {
+						emperor_del(ui_current);
+						freq = 1;
+					}
 					break;
 				}
 			}
 			else if (ui_current->cursed_at > 0) {
 				if (ui_current->pid == -1) {
 					emperor_del(ui_current);
-					// temporarily set frequency to 0, so we can eventually fast-restart the instance
-					freq = 0;
+					// temporarily set frequency to 1, so we can eventually fast-restart the instance
+					freq = 1;
 					break;
 				}
 				else if (now - ui_current->cursed_at >= uwsgi.emperor_curse_tolerance) {
@@ -2065,6 +2378,9 @@ void emperor_send_stats(int fd) {
 		if (uwsgi_stats_keyval_comma(us, "on_demand", c_ui->socket_name ? c_ui->socket_name : ""))
 			goto end0;
 
+		if (uwsgi_stats_keylong_comma(us, "adopted", (unsigned long long) c_ui->adopted))
+			goto end0;
+
 		if (uwsgi_stats_keylong_comma(us, "uid", (unsigned long long) c_ui->uid))
 			goto end0;
 		if (uwsgi_stats_keylong_comma(us, "gid", (unsigned long long) c_ui->gid))
@@ -2073,6 +2389,31 @@ void emperor_send_stats(int fd) {
 		if (uwsgi_stats_keyval_comma(us, "monitor", c_ui->scanner->arg))
 			goto end0;
 
+		if (uwsgi_stats_key(us, "attrs"))
+                        goto end0;
+
+		if (uwsgi_stats_list_open(us))
+			goto end0;
+
+		struct uwsgi_dyn_dict *attrs = c_ui->attrs;
+		while(attrs) {
+			if (attrs->next) {
+				if (uwsgi_stats_keyval_comma(us, attrs->key, attrs->value))
+                        		goto end0;
+			}
+			else {
+				if (uwsgi_stats_keyval(us, attrs->key, attrs->value))
+                        		goto end0;
+			}
+			attrs = attrs->next;
+		}
+
+		if (uwsgi_stats_list_close(us))
+			goto end0;
+
+		if (uwsgi_stats_comma(us))
+                                goto end0;
+
 		if (uwsgi_stats_keylong(us, "respawns", (unsigned long long) c_ui->respawns))
 			goto end0;
 
@@ -2211,7 +2552,7 @@ void uwsgi_check_emperor() {
 				sleep(1);
 				continue;
 			}
-			int count = 2;
+			int count = 3;
 			int *fds = uwsgi_attach_fd(proxy_fd, &count, "uwsgi-emperor", 13);
 			if (fds && count > 0) {
 				char *env_emperor_fd = uwsgi_num2str(fds[0]);
@@ -2224,17 +2565,42 @@ void uwsgi_check_emperor() {
 					goto next;
 				}
 				free(env_emperor_fd);
-				if (count > 1) {
-					char *env_emperor_fd_config = uwsgi_num2str(fds[1]);
-					if (setenv("UWSGI_EMPEROR_FD_CONFIG", env_emperor_fd_config, 1)) {
-						uwsgi_error("uwsgi_check_emperor()/setenv(UWSGI_EMPEROR_FD_CONFIG)");
-						free(env_emperor_fd_config);
-						int i;
-						for (i = 0; i < count; i++)
+				int i;
+				for(i=1;i<count;i++) {
+					if (fds[i] < 0) continue;
+
+					char *socket_name = uwsgi_getsockname(fds[i]);
+					if (!socket_name) {
+						int j;
+                                                for (j = 0; j < count; j++)
+                                                        close(fds[j]);
+                                                goto next;
+					}
+					if (socket_name[0] != 0) {
+						// map the socket to fd0
+						if (fds[i] != 0) {
+							if (dup2(fds[i], 0) < 0) {
+								uwsgi_error("uwsgi_check_emperor()/dup2()");
+								int j;
+                                                		for (j = 0; j < count; j++)
+                                                        		close(fds[j]);
+                                                		goto next;
+							}
 							close(fds[i]);
-						goto next;
+						}
+					}
+					else {
+						char *env_emperor_fd_config = uwsgi_num2str(fds[i]);
+						if (setenv("UWSGI_EMPEROR_FD_CONFIG", env_emperor_fd_config, 1)) {
+							uwsgi_error("uwsgi_check_emperor()/setenv(UWSGI_EMPEROR_FD_CONFIG)");
+							free(env_emperor_fd_config);
+							int j;
+							for (j = 0; j < count; j++)
+								close(fds[j]);
+							goto next;
+						}
+						free(env_emperor_fd_config);
 					}
-					free(env_emperor_fd_config);
 				}
 				break;
 			}
@@ -2261,6 +2627,34 @@ next:
 
 }
 
+void uwsgi_emperor_simple_do_with_attrs(struct uwsgi_emperor_scanner *ues, char *name, char *config, time_t ts, uid_t uid, gid_t gid, char *socket_name, struct uwsgi_dyn_dict *attrs) {
+	uwsgi_emperor_simple_do(ues, name, config, ts, uid, gid, socket_name);
+	struct uwsgi_instance *ui_current = emperor_get(name);
+	// free attrs ?
+	if (!ui_current) {
+		struct uwsgi_dyn_dict *attr = attrs;
+		while(attr) {
+			struct uwsgi_dyn_dict *tmp = attr;
+			attr = attr->next;
+			if (tmp->value) free(tmp->value);
+			free(tmp);
+		}
+		return;
+	}
+
+	// if the instance has attrs mapped, let's free them
+	if (ui_current->attrs) {
+		struct uwsgi_dyn_dict *attr = ui_current->attrs;
+		while(attr) {
+			struct uwsgi_dyn_dict *tmp = attr;
+			attr = attr->next;
+			if (tmp->value) free(tmp->value);
+			free(tmp);
+		}
+	}
+	ui_current->attrs = attrs;
+}
+
 void uwsgi_emperor_simple_do(struct uwsgi_emperor_scanner *ues, char *name, char *config, time_t ts, uid_t uid, gid_t gid, char *socket_name) {
 
 	if (!uwsgi_emperor_is_valid(name))
@@ -2322,7 +2716,17 @@ void uwsgi_emperor_simple_do(struct uwsgi_emperor_scanner *ues, char *name, char
 
 void uwsgi_master_manage_emperor() {
 	char byte;
+#ifdef UWSGI_EVENT_USE_PORT
+	// special cose for port event system
+	// place the socket in non-blocking mode
+        uwsgi_socket_nb(uwsgi.emperor_fd);
+#endif
 	ssize_t rlen = read(uwsgi.emperor_fd, &byte, 1);
+#ifdef UWSGI_EVENT_USE_PORT
+	// special cose for port event system
+	// and place back in blocking mode
+        uwsgi_socket_b(uwsgi.emperor_fd);
+#endif
 	if (rlen > 0) {
 		uwsgi_log_verbose("received message %d from emperor\n", byte);
 		// remove me
@@ -2342,6 +2746,12 @@ void uwsgi_master_manage_emperor() {
 			uwsgi_unblock_signal(SIGHUP);
 		}
 	}
+#ifdef UWSGI_EVENT_USE_PORT
+        // special cose for port event system
+	else if (rlen < 0 && uwsgi_is_again()) {
+		return;
+	}
+#endif
 	else {
 		uwsgi_error("uwsgi_master_manage_emperor()/read()");
 		uwsgi_log("lost connection with my emperor !!!\n");
@@ -2355,19 +2765,21 @@ void uwsgi_master_manage_emperor() {
 
 }
 
-void uwsgi_master_manage_emperor_proxy() {
+void uwsgi_master_manage_emperor_proxy(int server_fd, int emperor_fd, int emperor_fd_config, int socket_fd) {
 
 	struct sockaddr_un epsun;
 	socklen_t epsun_len = sizeof(struct sockaddr_un);
 
-	int ep_client = accept(uwsgi.emperor_fd_proxy, (struct sockaddr *) &epsun, &epsun_len);
+	int ep_client = accept(server_fd, (struct sockaddr *) &epsun, &epsun_len);
 	if (ep_client < 0) {
 		uwsgi_error("uwsgi_master_manage_emperor_proxy()/accept()");
 		return;
 	}
 
 	int num_fds = 1;
-	if (uwsgi.emperor_fd_config > -1)
+	if (emperor_fd_config > -1)
+		num_fds++;
+	if (socket_fd > -1)
 		num_fds++;
 
 	struct msghdr ep_msg;
@@ -2397,9 +2809,15 @@ void uwsgi_master_manage_emperor_proxy() {
 
 	unsigned char *ep_fd_ptr = CMSG_DATA(cmsg);
 
-	memcpy(ep_fd_ptr, &uwsgi.emperor_fd, sizeof(int));
-	if (num_fds > 1) {
-		memcpy(ep_fd_ptr + sizeof(int), &uwsgi.emperor_fd_config, sizeof(int));
+	memcpy(ep_fd_ptr, &emperor_fd, sizeof(int));
+	if (emperor_fd_config > -1) {
+		ep_fd_ptr += sizeof(int);
+		memcpy(ep_fd_ptr, &emperor_fd_config, sizeof(int));
+	}
+
+	if (socket_fd > -1) {
+		ep_fd_ptr += sizeof(int);
+		memcpy(ep_fd_ptr, &socket_fd, sizeof(int));
 	}
 
 	if (sendmsg(ep_client, &ep_msg, 0) < 0) {
diff --git a/core/errors.c b/core/errors.c
index 8df221e..e487985 100644
--- a/core/errors.c
+++ b/core/errors.c
@@ -45,6 +45,14 @@ void uwsgi_403(struct wsgi_request *wsgi_req) {
 	uwsgi_response_write_body_do(wsgi_req, "Forbidden", 9);
 }
 
+void uwsgi_405(struct wsgi_request *wsgi_req) {
+        if (uwsgi_response_prepare_headers(wsgi_req, "405 Method Not Allowed", 22)) return;
+        if (uwsgi_response_add_connection_close(wsgi_req)) return;
+        if (error_page(wsgi_req, uwsgi.error_page_403)) return;
+        if (uwsgi_response_add_content_type(wsgi_req, "text/plain", 10)) return;
+        uwsgi_response_write_body_do(wsgi_req, "Method Not Allowed", 18);
+}
+
 void uwsgi_redirect_to_slash(struct wsgi_request *wsgi_req) {
 
 	char *redirect = NULL;
diff --git a/core/event.c b/core/event.c
index cc98cdf..36751a6 100644
--- a/core/event.c
+++ b/core/event.c
@@ -414,11 +414,11 @@ int event_queue_wait_multi(int eq, int timeout, void *events, int nevents) {
 	}
 
 	if (ret < 0) {
-		if (errno != ETIME) {
-			uwsgi_error("port_getn()");
-			return -1;
-		}
-		return 0;
+		if (errno == ETIME) return 0;
+                if (errno != EINTR) {
+                        uwsgi_error("port_getn()");
+                }
+                return -1;
 	}
 
 	uint_t i;
@@ -452,6 +452,7 @@ int event_queue_wait(int eq, int timeout, int *interesting_fd) {
 	else {
 		ret = port_get(eq, &pe, NULL);
 	}
+
 	if (ret < 0) {
 		if (errno == ETIME) return 0;
 		if (errno != EINTR) {
@@ -947,7 +948,7 @@ int event_queue_wait(int eq, int timeout, int *interesting_fd) {
 	struct timespec ts;
 	struct kevent ev;
 
-	if (timeout <= 0) {
+	if (timeout < 0) {
 		ret = kevent(eq, NULL, 0, &ev, 1, NULL);
 	}
 	else {
diff --git a/core/exceptions.c b/core/exceptions.c
index 63c1371..fc6fe1c 100644
--- a/core/exceptions.c
+++ b/core/exceptions.c
@@ -46,7 +46,7 @@ extern struct uwsgi_server uwsgi;
 
 struct uwsgi_buffer *uwsgi_exception_handler_object(struct wsgi_request *wsgi_req) {
 	struct uwsgi_buffer *ub = uwsgi_buffer_new(4096);
-	if (uwsgi_buffer_append_keyval(ub, "vars", 4, wsgi_req->buffer,wsgi_req->uh->pktsize)) goto error;
+	if (uwsgi_buffer_append_keyval(ub, "vars", 4, wsgi_req->buffer, wsgi_req->len)) goto error;
 	if (uwsgi.p[wsgi_req->uh->modifier1]->backtrace) {
                 struct uwsgi_buffer *bt = uwsgi.p[wsgi_req->uh->modifier1]->backtrace(wsgi_req);
 		if (bt) {
@@ -280,7 +280,7 @@ notavail4:
 
         if (uwsgi_buffer_append(ub, "\n\n", 2)) goto error;
 
-	if (uwsgi_hooked_parse(wsgi_req->buffer, wsgi_req->uh->pktsize, append_vars_to_ubuf, ub)) {
+	if (uwsgi_hooked_parse(wsgi_req->buffer, wsgi_req->len, append_vars_to_ubuf, ub)) {
 		goto error;
 	}
 
diff --git a/core/fifo.c b/core/fifo.c
index 0ccfcc0..d1a9818 100644
--- a/core/fifo.c
+++ b/core/fifo.c
@@ -80,6 +80,7 @@ void uwsgi_master_fifo_prepare() {
 
 	uwsgi_fifo_table['-'] = uwsgi_cheaper_decrease;
 	uwsgi_fifo_table['+'] = uwsgi_cheaper_increase;
+	uwsgi_fifo_table['B'] = vassal_sos; 
 	uwsgi_fifo_table['c'] = uwsgi_chain_reload;
 	uwsgi_fifo_table['C'] = uwsgi_go_cheap;
 	uwsgi_fifo_table['E'] = emperor_rescan;
@@ -131,6 +132,7 @@ int uwsgi_master_fifo_manage(int fd) {
 	}
 	// fifo destroyed, recreate it
 	else if (rlen == 0) {
+		event_queue_del_fd(uwsgi.master_queue, uwsgi.master_fifo_fd, event_queue_read());
 		close(fd);
 		uwsgi.master_fifo_fd = uwsgi_master_fifo();
 		event_queue_add_fd_read(uwsgi.master_queue, uwsgi.master_fifo_fd);
diff --git a/core/fork_server.c b/core/fork_server.c
new file mode 100644
index 0000000..5a0baaa
--- /dev/null
+++ b/core/fork_server.c
@@ -0,0 +1,226 @@
+#include <uwsgi.h>
+
+extern struct uwsgi_server uwsgi;
+
+/*
+
+on connection retrieve the uid,gid and pid of the connecting process, in addition to up to 3
+file descriptors (emperor pipe, emperor pipe_config, on_demand socket dup()'ed to 0)
+
+if authorized, double fork, get the pid of the second child and exit()
+its parent (this will force the Emperor to became its subreaper).
+
+from now on, we can consider the new child as a full-featured vassal
+
+*/
+
+#define VASSAL_HAS_CONFIG 0x02
+#define VASSAL_HAS_ON_DEMAND 0x04
+
+static void parse_argv_hook(uint16_t item, char *value, uint16_t vlen, void *data) {
+	struct uwsgi_string_list **usl = (struct uwsgi_string_list **) data;
+	uwsgi_string_new_list(usl, uwsgi_concat2n(value, vlen, "", 0));
+}
+
+
+void uwsgi_fork_server(char *socket) {
+	// map fd 0 to /dev/null to avoid mess
+	uwsgi_remap_fd(0, "/dev/null");
+
+	int fd = bind_to_unix(socket, uwsgi.listen_queue, uwsgi.chmod_socket, uwsgi.abstract_socket);
+	if (fd < 0) exit(1);
+
+	// automatically receive credentials (TODO make something useful with them, like checking the pid is from the Emperor)
+	if (uwsgi_socket_passcred(fd)) exit(1);
+
+	// initialize the event queue
+	int eq = event_queue_init();
+	if (uwsgi.has_emperor) {
+		event_queue_add_fd_read(eq, uwsgi.emperor_fd);
+	}
+	event_queue_add_fd_read(eq, fd);
+
+	// now start waiting for connections
+	for(;;) {
+		int interesting_fd = -1;
+		int rlen = event_queue_wait(eq, -1, &interesting_fd);
+		if (rlen <= 0) continue;
+		if (uwsgi.has_emperor && interesting_fd == uwsgi.emperor_fd) {
+			char byte;
+        		ssize_t rlen = read(uwsgi.emperor_fd, &byte, 1);
+        		if (rlen > 0) {
+                		uwsgi_log_verbose("received message %d from emperor\n", byte);
+			}
+			exit(0);
+		}
+		if (interesting_fd != fd) continue;
+		struct sockaddr_un client_src;
+        	socklen_t client_src_len = 0;
+        	int client_fd = accept(fd, (struct sockaddr *) &client_src, &client_src_len);
+        	if (client_fd < 0) {
+                	uwsgi_error("uwsgi_fork_server()/accept()");
+			continue;
+        	}
+		char hbuf[4];
+		pid_t ppid = -1;
+		uid_t uid = -1;
+		gid_t gid = -1;
+		int fds_count = 8;
+		size_t remains = 4;
+		// we can receive upto 8 fds (generally from 1 to 3)
+		int fds[8];
+		// we only read 4 bytes header
+		ssize_t len = uwsgi_recv_cred_and_fds(client_fd, hbuf, remains, &ppid, &uid, &gid, fds, &fds_count);
+		uwsgi_log_verbose("[uwsgi-fork-server] connection from pid: %d uid: %d gid:%d fds:%d\n", ppid, uid, gid, fds_count);
+		if (len <= 0 || fds_count < 1) {
+			uwsgi_error("uwsgi_fork_server()/recvmsg()");
+			goto end;
+		}
+		remains -= len;
+	
+		if (uwsgi_read_nb(client_fd, hbuf + (4-remains), remains, uwsgi.socket_timeout)) {
+			uwsgi_error("uwsgi_fork_server()/uwsgi_read_nb()");
+			goto end;
+		}
+
+		struct uwsgi_header *uh = (struct uwsgi_header *) hbuf;
+		// this memory area must be freed in the right place !!!
+		char *body_argv = uwsgi_malloc(uh->_pktsize);
+		if (uwsgi_read_nb(client_fd, body_argv, uh->_pktsize, uwsgi.socket_timeout)) {
+			free(body_argv);
+                        uwsgi_error("uwsgi_fork_server()/uwsgi_read_nb()");
+                        goto end;
+                }
+
+		pid_t pid = fork();
+		if (pid < 0) {
+			free(body_argv);
+			int i;
+			for(i=0;i<fds_count;i++) close(fds[i]);
+			// error on fork()
+			uwsgi_error("uwsgi_fork_server()/fork()");
+			goto end;		
+		}
+		else if (pid > 0) {
+			free(body_argv);
+			// close inherited decriptors 
+			int i;
+			for(i=0;i<fds_count;i++) close(fds[i]);
+			// wait for child death...
+			waitpid(pid, NULL, 0);
+			goto end;
+		}
+		else {
+			// close Emperor channels
+			// we do not close others file desctiptor as lot
+			// of funny tricks could be accomplished with them
+			if (uwsgi.has_emperor) {
+				close(uwsgi.emperor_fd);
+				if (uwsgi.emperor_fd_config > -1) close(uwsgi.emperor_fd_config);
+			}
+			
+			// set EMPEROR_FD and FD_CONFIG env vars	
+			char *uef = uwsgi_num2str(fds[0]);
+        		if (setenv("UWSGI_EMPEROR_FD", uef, 1)) {
+                		uwsgi_error("uwsgi_fork_server()/setenv()");
+                		exit(1);
+        		}
+        		free(uef);
+
+			int pipe_config = -1;
+			int on_demand = -1;
+
+			if (uh->modifier2 & VASSAL_HAS_CONFIG && fds_count > 1) {
+				pipe_config = fds[1];	
+				char *uef = uwsgi_num2str(pipe_config);
+				if (setenv("UWSGI_EMPEROR_FD_CONFIG", uef, 1)) {
+                                	uwsgi_error("uwsgi_fork_server()/setenv()");
+                                	exit(1);
+                        	}
+                        	free(uef);
+			}
+
+			if (uh->modifier2 & VASSAL_HAS_ON_DEMAND && fds_count > 1) {
+				if (pipe_config > -1) {
+					if (fds_count > 2) {
+						on_demand = fds[2];
+					}
+				}
+				else {
+					on_demand = fds[1];
+				}
+			}
+			// dup the on_demand socket to 0 and close it
+			if (on_demand > -1) {
+				if (dup2(on_demand, 0) < 0) {
+					uwsgi_error("uwsgi_fork_server()/dup2()");
+					exit(1);
+				}
+				close(on_demand);
+			}
+
+			// now fork again and die
+			pid_t new_pid = fork();
+			if (new_pid < 0) {
+                        	uwsgi_error("uwsgi_fork_server()/fork()");
+				exit(1);
+			}
+			else if (new_pid > 0) {
+				exit(0);
+			}
+			else {
+				// send the pid to the client_fd and close it
+				struct uwsgi_buffer *ub = uwsgi_buffer_new(uwsgi.page_size);
+				// leave space for header
+				ub->pos = 4;
+				if (uwsgi_buffer_append_keynum(ub, "pid", 3, getpid())) exit(1); 
+				// fix uwsgi header
+        			if (uwsgi_buffer_set_uh(ub, 35, 0)) goto end;
+				// send_pid()
+				if (uwsgi_write_nb(client_fd, ub->buf, ub->pos, uwsgi.socket_timeout)) exit(1);
+				close(client_fd);
+				uwsgi_log("double fork() and reparenting successfull (new pid: %d)\n", getpid());
+
+
+				// now parse the uwsgi packet array and build the argv
+				struct uwsgi_string_list *usl = NULL, *usl_argv = NULL;
+				uwsgi_hooked_parse_array(body_argv, uh->_pktsize, parse_argv_hook, &usl_argv);
+				free(body_argv);
+
+				// build new argc/argv
+				uwsgi.new_argc = 0;
+				size_t procname_len = 1;
+				uwsgi_foreach(usl, usl_argv) {
+					uwsgi.new_argc++;
+					procname_len += usl->len + 1;
+				}
+
+				char *new_procname = uwsgi_calloc(procname_len);
+				
+				uwsgi.new_argv = uwsgi_calloc(sizeof(char *) * (uwsgi.new_argc + 1));
+				int counter = 0;
+				uwsgi_foreach(usl, usl_argv) {
+					uwsgi.new_argv[counter] = usl->value;
+					strcat(new_procname, usl->value);
+					strcat(new_procname, " ");
+					counter++;
+				}
+				// fix process name
+				uwsgi_set_processname(new_procname);
+				free(new_procname);
+				// this is the only step required to have a consistent environment
+				uwsgi.fork_socket = NULL;
+				// this avoids the process to re-exec itself
+				uwsgi.exit_on_reload = 1;
+				// fixup the Emperor communication
+				uwsgi_check_emperor();
+				// continue with uWSGI startup
+				return;
+			}
+		}	
+
+end:
+		close(client_fd);
+		
+	}
+}
diff --git a/core/hooks.c b/core/hooks.c
index 4f79fab..0ad8d89 100644
--- a/core/hooks.c
+++ b/core/hooks.c
@@ -540,6 +540,18 @@ static int uwsgi_hook_retryrpc(char *arg) {
 	return 0;
 }
 
+static int uwsgi_hook_wait_for_fs(char *arg) {
+	return uwsgi_wait_for_fs(arg, 0);
+}
+
+static int uwsgi_hook_wait_for_file(char *arg) {
+	return uwsgi_wait_for_fs(arg, 1);
+}
+
+static int uwsgi_hook_wait_for_dir(char *arg) {
+	return uwsgi_wait_for_fs(arg, 2);
+}
+
 void uwsgi_register_base_hooks() {
 	uwsgi_register_hook("cd", uwsgi_hook_chdir);
 	uwsgi_register_hook("chdir", uwsgi_hook_chdir);
@@ -580,61 +592,182 @@ void uwsgi_register_base_hooks() {
 	uwsgi_register_hook("rpc", uwsgi_hook_rpc);
 	uwsgi_register_hook("retryrpc", uwsgi_hook_retryrpc);
 
+	uwsgi_register_hook("wait_for_fs", uwsgi_hook_wait_for_fs);
+	uwsgi_register_hook("wait_for_file", uwsgi_hook_wait_for_file);
+	uwsgi_register_hook("wait_for_dir", uwsgi_hook_wait_for_dir);
+
 	// for testing
 	uwsgi_register_hook("exit", uwsgi_hook_exit);
 	uwsgi_register_hook("print", uwsgi_hook_print);
 	uwsgi_register_hook("log", uwsgi_hook_print);
 }
 
-void uwsgi_hooks_run(struct uwsgi_string_list *l, char *phase, int fatal) {
+int uwsgi_hooks_run_and_return(struct uwsgi_string_list *l, char *phase, char *context, int fatal) {
+	int final_ret = 0;
 	struct uwsgi_string_list *usl = NULL;
-	uwsgi_foreach(usl, l) {
-		char *colon = strchr(usl->value, ':');
-		if (!colon) {
-			uwsgi_log("invalid hook syntax, must be hook:args\n");
-			exit(1);
-		}
-		*colon = 0;
-		int private = 0;
-		char *action = usl->value;
-		// private hook ?
-		if (action[0] == '!') {
-			action++;
-			private = 1;
+	if (context) {
+		if (setenv("UWSGI_HOOK_CONTEXT", context, 1)) {
+			uwsgi_error("uwsgi_hooks_run_and_return()/setenv()");
+			return -1;
 		}
-		struct uwsgi_hook *uh = uwsgi_hook_by_name(action);
-		if (!uh) {
-			uwsgi_log("hook action not found: %s\n", action);
-			exit(1);
+	}
+        uwsgi_foreach(usl, l) {
+                char *colon = strchr(usl->value, ':');
+                if (!colon) {
+                        uwsgi_log("invalid hook syntax, must be hook:args\n");
+                        exit(1);
+                }
+                *colon = 0;
+                int private = 0;
+                char *action = usl->value;
+                // private hook ?
+                if (action[0] == '!') {
+                        action++;
+                        private = 1;
+                }
+                struct uwsgi_hook *uh = uwsgi_hook_by_name(action);
+                if (!uh) {
+                        uwsgi_log("hook action not found: %s\n", action);
+                        exit(1);
+                }
+                *colon = ':';
+
+                if (private) {
+                        uwsgi_log("running --- PRIVATE HOOK --- (%s)...\n", phase);
+                }
+                else {
+                        uwsgi_log("running \"%s\" (%s)...\n", usl->value, phase);
+                }
+
+                int ret = uh->func(colon+1);
+		if (ret != 0) {
+			if (fatal) {
+				if (context) {
+					unsetenv("UWSGI_HOOK_CONTEXT");
+				}
+				return ret;
+			}
+			final_ret = ret;
 		}
-		*colon = ':';
+        }
+
+	if (context) {
+		unsetenv("UWSGI_HOOK_CONTEXT");
+	}
 
-		if (private) {
-			uwsgi_log("running --- PRIVATE HOOK --- (%s)...\n", phase);
+	return final_ret;
+}
+
+void uwsgi_hooks_run(struct uwsgi_string_list *l, char *phase, int fatal) {
+	int ret = uwsgi_hooks_run_and_return(l, phase, NULL, fatal);
+	if (fatal && ret != 0) {
+		uwsgi_log_verbose("FATAL hook failed, destroying instance\n");
+		if (uwsgi.master_process) {
+			if (uwsgi.workers) {
+				if (uwsgi.workers[0].pid == getpid()) {
+					kill_them_all(0);
+					return;
+				}
+				else {
+                                       	if (kill(uwsgi.workers[0].pid, SIGINT)) {
+						uwsgi_error("uwsgi_hooks_run()/kill()");
+						exit(1);
+					}
+					return;
+                               	}
+			}
 		}
-		else {
-			uwsgi_log("running \"%s\" (%s)...\n", usl->value, phase);
+		exit(1);
+	}
+}
+
+#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL)
+/*
+this is a special hook, allowing the Emperor to enter a vassal
+namespace and call hooks in its namespace context.
+*/
+void uwsgi_hooks_setns_run(struct uwsgi_string_list *l, pid_t pid, uid_t uid, gid_t gid) {
+	int (*u_setns) (int, int) = (int (*)(int, int)) dlsym(RTLD_DEFAULT, "setns");
+        if (!u_setns) {
+                uwsgi_log("your system misses setns() syscall !!!\n");
+		return;
+        }
+
+	struct uwsgi_string_list *usl = NULL;
+	uwsgi_foreach(usl, l) {
+		// fist of all fork() the current process
+		pid_t new_pid = fork();
+		if (new_pid > 0) {
+			// wait for its death
+			int status;
+			if (waitpid(new_pid, &status, 0) < 0) {
+				uwsgi_error("uwsgi_hooks_setns_run()/waitpid()");
+			}
 		}
-			
-		int ret = uh->func(colon+1);
-		if (fatal && ret != 0) {
-			uwsgi_log_verbose("FATAL hook failed, destroying instance\n");
-			if (uwsgi.master_process) {
-				if (uwsgi.workers) {
-					if (uwsgi.workers[0].pid == getpid()) {
-						kill_them_all(0);
-						return;
-					}
-					else {
-                                        	if (kill(uwsgi.workers[0].pid, SIGINT)) {
-							uwsgi_error("uwsgi_hooks_run()/kill()");
-							exit(1);
-						}
-						return;
-                                	}
+		else if (new_pid == 0) {
+			// from now on, freeing memory is useless
+			// now split args to know which namespaces to join
+			char *action = strchr(usl->value, ' ');
+			if (!action) {
+				uwsgi_log("invalid setns hook syntax, must be \"namespaces_list action:...\"\n");
+				exit(1);
+			}
+			char *pidstr = uwsgi_num2str(pid);
+			char *uidstr = uwsgi_num2str(uid);
+			char *gidstr = uwsgi_num2str(gid);
+
+			char *namespaces = uwsgi_concat2n(usl->value, action-usl->value, "", 0);
+        		char *p, *ctx = NULL;
+        		uwsgi_foreach_token(namespaces, ",", p, ctx) {
+				char *procfile = uwsgi_concat4("/proc/", pidstr, "/ns/", p);
+				int fd = open(procfile, O_RDONLY);
+				if (fd < 0) {
+					uwsgi_error_open(procfile);
+					exit(1);
+				}
+				if (u_setns(fd, 0) < 0){
+					uwsgi_error("uwsgi_hooks_setns_run()/setns()");
+					exit(1);
 				}
+
+                	}
+
+			if (setenv("UWSGI_VASSAL_PID", pidstr, 1)) {
+				uwsgi_error("uwsgi_hooks_setns_run()/setenv()");
+				exit(1);
+			}
+
+			if (setenv("UWSGI_VASSAL_UID", uidstr, 1)) {
+				uwsgi_error("uwsgi_hooks_setns_run()/setenv()");
+				exit(1);
+			}
+
+			if (setenv("UWSGI_VASSAL_GID", gidstr, 1)) {
+				uwsgi_error("uwsgi_hooks_setns_run()/setenv()");
+				exit(1);
+			}
+
+			// now run the action and then exit
+			action++;
+			char *colon = strchr(action, ':');
+			if (!colon) {
+				uwsgi_log("invalid hook syntax must be action:arg\n");
+				exit(1);
 			}
-			exit(1);
+			*colon = 0;
+			struct uwsgi_hook *uh = uwsgi_hook_by_name(action);
+                	if (!uh) {
+                        	uwsgi_log("hook action not found: %s\n", action);
+                        	exit(1);
+                	}
+                	*colon = ':';
+
+                        uwsgi_log("running \"%s\" (setns)...\n", usl->value);
+                	exit(uh->func(colon+1));
+		}
+		else {
+			uwsgi_error("uwsgi_hooks_setns_run()/fork()");
 		}
 	}
 }
+#endif
diff --git a/core/ini.c b/core/ini.c
index 9069fcb..61a3c26 100644
--- a/core/ini.c
+++ b/core/ini.c
@@ -9,7 +9,7 @@ extern struct uwsgi_server uwsgi;
 
 static char *last_file = NULL;
 
-void ini_rstrip(char *line) {
+static void ini_rstrip(char *line) {
 
 	off_t i;
 
@@ -22,7 +22,7 @@ void ini_rstrip(char *line) {
 	}
 }
 
-char *ini_lstrip(char *line) {
+static char *ini_lstrip(char *line) {
 
 	off_t i;
 	char *ptr = line;
@@ -38,7 +38,7 @@ char *ini_lstrip(char *line) {
 	return ptr;
 }
 
-char *ini_get_key(char *key) {
+static char *ini_get_key(char *key) {
 
 	off_t i;
 	char *ptr = key;
@@ -54,7 +54,7 @@ char *ini_get_key(char *key) {
 	return ptr;
 }
 
-char *ini_get_line(char *ini, size_t size) {
+static char *ini_get_line(char *ini, size_t size) {
 
 	size_t i;
 	char *ptr = ini;
@@ -171,5 +171,58 @@ void uwsgi_ini_config(char *file, char *magic_table[]) {
 		colon[0] = ':';
 	}
 
+}
+
+void uwsgi_emperor_ini_attrs(char *filename, char *section_asked, struct uwsgi_dyn_dict **attrs) {
+	if (!section_asked) section_asked = "emperor";
+
+	char *ini = uwsgi_simple_file_read(filename);
+	if (!ini) return;
+
+	char *orig_ini = ini;
 
+	size_t len = strlen(ini);
+	char *section = "";
+	char *key, *val, *ini_line;
+
+	while (len) {
+                ini_line = ini_get_line(ini, len);
+                if (ini_line == NULL) {
+                        break;
+                }
+                // skip empty line
+                key = ini_lstrip(ini);
+                ini_rstrip(key);
+                if (key[0] != 0) {
+                        if (key[0] == '[') {
+                                section = key + 1;
+                                section[strlen(section) - 1] = 0;
+                        }
+                        else if (key[0] == ';' || key[0] == '#') {
+                                // this is a comment
+                        }
+                        else {
+                                // val is always valid, but (obviously) can be ignored
+                                val = ini_get_key(key);
+
+                                if (!strcmp(section, section_asked)) {
+                                        ini_rstrip(key);
+					struct uwsgi_string_list *usl = uwsgi_string_list_has_item(uwsgi.emperor_collect_attributes, key, strlen(key));
+					if (usl) {
+                                        	val = ini_lstrip(val);
+                                        	ini_rstrip(val);
+						char *value = uwsgi_str(val);
+                                        	uwsgi_dyn_dict_new(attrs, usl->value, usl->len, value, strlen(value));
+					}
+                                }
+                        }
+                }
+
+
+                len -= (ini_line - ini);
+                ini += (ini_line - ini);
+
+        }
+	
+	free(orig_ini);
 }
diff --git a/core/init.c b/core/init.c
index 6ee0159..ea4121a 100644
--- a/core/init.c
+++ b/core/init.c
@@ -61,6 +61,7 @@ struct http_status_codes hsc[] = {
 void uwsgi_init_default() {
 
 	uwsgi.cpus = 1;
+	uwsgi.new_argc = -1;
 
 	uwsgi.backtrace_depth = 64;
 	uwsgi.max_apps = 64;
@@ -105,7 +106,8 @@ void uwsgi_init_default() {
 
 	uwsgi.forkbomb_delay = 2;
 
-	uwsgi.async = 1;
+	uwsgi.async = 0;
+	uwsgi.async_warn_if_queue_full = 1;
 	uwsgi.listen_queue = 100;
 
 	uwsgi.cheaper_overload = 3;
@@ -252,9 +254,20 @@ void uwsgi_commandline_config() {
 	int i;
 
 	uwsgi.option_index = -1;
+	// required in case we want to call getopt_long from the beginning
+	optind = 0;
+
+	int argc = uwsgi.argc;
+	char **argv = uwsgi.argv;
+
+	if (uwsgi.new_argc > -1 && uwsgi.new_argv) {
+		argc = uwsgi.new_argc;
+		argv = uwsgi.new_argv;
+	}
+
 
 	char *optname;
-	while ((i = getopt_long(uwsgi.argc, uwsgi.argv, uwsgi.short_options, uwsgi.long_options, &uwsgi.option_index)) != -1) {
+	while ((i = getopt_long(argc, argv, uwsgi.short_options, uwsgi.long_options, &uwsgi.option_index)) != -1) {
 
 		if (i == '?') {
 			uwsgi_log("getopt_long() error\n");
@@ -280,9 +293,9 @@ void uwsgi_commandline_config() {
 	uwsgi_log("optind:%d argc:%d\n", optind, uwsgi.argc);
 #endif
 
-	if (optind < uwsgi.argc) {
-		for (i = optind; i < uwsgi.argc; i++) {
-			char *lazy = uwsgi.argv[i];
+	if (optind < argc) {
+		for (i = optind; i < argc; i++) {
+			char *lazy = argv[i];
 			if (lazy[0] != '[') {
 				uwsgi_opt_load(NULL, lazy, NULL);
 				// manage magic mountpoint
@@ -407,7 +420,7 @@ pid_t uwsgi_daemonize2() {
 // fix/check related options
 void sanitize_args() {
 
-        if (uwsgi.async > 1) {
+        if (uwsgi.async > 0) {
                 uwsgi.cores = uwsgi.async;
         }
 
diff --git a/core/io.c b/core/io.c
index 30334dc..dc492b0 100644
--- a/core/io.c
+++ b/core/io.c
@@ -90,7 +90,7 @@ char *uwsgi_simple_file_read(char *filename) {
 	}
 
 	if (fstat(fd, &sb)) {
-		uwsgi_error("fstat()");
+		uwsgi_error("uwsgi_simple_file_read()/fstat()");
 		close(fd);
 		goto end;
 	}
@@ -99,7 +99,7 @@ char *uwsgi_simple_file_read(char *filename) {
 
 	len = read(fd, buffer, sb.st_size);
 	if (len != sb.st_size) {
-		uwsgi_error("read()");
+		uwsgi_error("uwsgi_simple_file_read()/read()");
 		free(buffer);
 		close(fd);
 		goto end;
@@ -112,7 +112,7 @@ char *uwsgi_simple_file_read(char *filename) {
 	buffer[sb.st_size] = 0;
 	return buffer;
 end:
-	return (char *) "";
+	return NULL;
 
 }
 
@@ -277,7 +277,7 @@ static char *uwsgi_scheme_emperor(char *url, size_t *size, int add_zero) {
 		remains-=rlen;
 	}
 
-	remains = uh.pktsize;
+	remains = uh._pktsize;
 	if (!remains) {
 		uwsgi_log("[uwsgi-vassal] invalid config from %s\n", url);
 		exit(1);
@@ -300,7 +300,7 @@ static char *uwsgi_scheme_emperor(char *url, size_t *size, int add_zero) {
                 remains-=rlen;
 	}
 
-	*size = uh.pktsize + add_zero;
+	*size = uh._pktsize + add_zero;
 	return buffer;
 }
 
@@ -392,6 +392,26 @@ static char *uwsgi_scheme_call(char *url, size_t *size, int add_zero) {
         return buffer;
 }
 
+static char *uwsgi_scheme_callint(char *url, size_t *size, int add_zero) {
+        int (*func)(void) = dlsym(RTLD_DEFAULT, url);
+        if (!func) {
+                uwsgi_log("unable to find symbol %s\n", url);
+                exit(1);
+        }
+
+	char *s = uwsgi_num2str(func());
+        *size = strlen(s);
+        if (add_zero) {
+                *size += 1;
+        }
+        char *buffer = uwsgi_malloc(*size);
+        memset(buffer, 0, *size);
+        memcpy(buffer, s, strlen(s));
+	free(s);
+
+        return buffer;
+}
+
 
 static char *uwsgi_scheme_sym(char *url, size_t *size, int add_zero) {
 	void *sym_start_ptr = NULL, *sym_end_ptr = NULL;
@@ -1043,7 +1063,7 @@ readok:
         }
 
 	struct uwsgi_header *uh = (struct uwsgi_header *) buf;
-	uint16_t pktsize = uh->pktsize;
+	uint16_t pktsize = uh->_pktsize;
 	if (modifier1)
 		*modifier1 = uh->modifier1;
 	if (modifier2)
@@ -1249,6 +1269,7 @@ void uwsgi_setup_schemes() {
 	uwsgi_register_scheme("fd", uwsgi_scheme_fd);	
 	uwsgi_register_scheme("exec", uwsgi_scheme_exec);	
 	uwsgi_register_scheme("call", uwsgi_scheme_call);	
+	uwsgi_register_scheme("callint", uwsgi_scheme_callint);	
 }
 
 struct uwsgi_string_list *uwsgi_check_scheme(char *file) {
@@ -1481,3 +1502,129 @@ clear:
 #endif
 }
 
+ssize_t uwsgi_recv_cred_and_fds(int fd, char *buf, size_t buf_len, pid_t *pid, uid_t *uid, gid_t *gid, int *fds, int *fds_count) {
+#if defined(SCM_CREDENTIALS) && defined(SCM_RIGHTS)
+        ssize_t ret = -1;
+
+	size_t msg_len = CMSG_SPACE(sizeof(struct ucred)) + CMSG_SPACE(sizeof(int) * (*fds_count));
+
+	// allocate space for credentials and file descriptors
+        void *msg_control = uwsgi_calloc(msg_len);
+
+	// read into buf
+        struct iovec iov;
+        iov.iov_base = buf;
+        iov.iov_len = buf_len;
+
+        struct msghdr msg;
+        memset(&msg, 0, sizeof(msg));
+
+        msg.msg_name = NULL;
+        msg.msg_namelen = 0;
+
+        msg.msg_iov = &iov;
+        msg.msg_iovlen = 1;
+
+	// set cmsg
+        msg.msg_control = msg_control;
+        msg.msg_controllen = msg_len;
+
+        ssize_t len = recvmsg(fd, &msg, 0);
+        if (len <= 0) {
+                uwsgi_error("uwsgi_recv_cred_and_fds()/recvmsg()");
+                goto clear;
+        }
+
+	// reset the number of fds
+	*fds_count = 0;
+
+        struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
+	while(cmsg) {
+        	if (cmsg->cmsg_level != SOL_SOCKET) goto next;
+		if (cmsg->cmsg_type == SCM_RIGHTS) {
+			size_t fds_len = cmsg->cmsg_len - ((char *) CMSG_DATA(cmsg) - (char *) cmsg);			
+			memcpy(fds, CMSG_DATA(cmsg), fds_len);
+			*fds_count = fds_len/sizeof(int);
+		}
+		else if (cmsg->cmsg_type == SCM_CREDENTIALS) {
+        		struct ucred *u = (struct ucred *) CMSG_DATA(cmsg);
+        		*pid = u->pid;
+        		*uid = u->uid;
+        		*gid = u->gid;
+		}
+next:
+		cmsg=CMSG_NXTHDR(&msg,cmsg);
+        }
+
+        ret = len;
+
+clear:
+        free(msg_control);
+        return ret;
+#else
+        return -1;
+#endif
+}
+
+
+int uwsgi_send_fds_and_body(int fd, int *fds, int fds_count, char *body, size_t len) {
+
+	int ret = -1;
+
+        struct msghdr msg;
+        void *msg_control = uwsgi_malloc(CMSG_SPACE(sizeof(int) * fds_count));
+        struct iovec iov;
+        struct cmsghdr *cmsg;
+
+        iov.iov_base = body;
+        iov.iov_len = len;
+
+        msg.msg_name = NULL;
+        msg.msg_namelen = 0;
+
+        msg.msg_iov = &iov;
+        msg.msg_iovlen = 1;
+
+        msg.msg_flags = 0;
+        msg.msg_control = msg_control;
+        msg.msg_controllen = CMSG_SPACE(sizeof(int) * fds_count);
+
+        cmsg = CMSG_FIRSTHDR(&msg);
+        cmsg->cmsg_len = CMSG_LEN(sizeof(int) * fds_count);
+        cmsg->cmsg_level = SOL_SOCKET;
+        cmsg->cmsg_type = SCM_RIGHTS;
+
+        unsigned char *fd_ptr = CMSG_DATA(cmsg);
+
+        memcpy(fd_ptr, fds, sizeof(int) * fds_count);
+
+        ssize_t rlen = sendmsg(fd, &msg, 0);
+	if (rlen <= 0) {
+                uwsgi_error("uwsgi_send_fds_and_body()/sendmsg()");
+		goto end;	
+        }
+	else {
+		size_t remains = len - rlen;
+		while(remains > 0) {
+			char *buf = body + rlen;
+			ssize_t wlen = write(fd, buf, remains);
+			if (wlen == 0) goto end;
+			if (wlen < 0) {
+				if (uwsgi_is_again()) {
+					// wait for write
+					continue;
+				}
+				uwsgi_error("uwsgi_send_fds_and_body()/write()");
+				goto end;
+			}
+			rlen += wlen;
+			remains -= wlen;
+		}
+	}
+	ret = 0;
+
+end:
+        free(msg_control);
+	return ret;	
+}
+
diff --git a/core/legion.c b/core/legion.c
index 9adf27c..b767e3c 100644
--- a/core/legion.c
+++ b/core/legion.c
@@ -572,7 +572,7 @@ static void *legion_loop(void *foobar) {
 
 			d_len += d2_len;
 
-			if (d_len != uh->pktsize) {
+			if (d_len != uh->_pktsize) {
 				uwsgi_log("[uwsgi-legion] invalid packet size\n");
 				continue;
 			}
@@ -1212,6 +1212,9 @@ next:
 		legion = legion->next;
 	}
 
+	// this must be called only by the master !!!
+	if (!uwsgi.workers) return;
+	if (uwsgi.workers[0].pid != getpid()) return;
 	uwsgi_legion_announce_death();
 }
 
diff --git a/core/logging.c b/core/logging.c
index 1244160..8c1d05f 100644
--- a/core/logging.c
+++ b/core/logging.c
@@ -354,51 +354,51 @@ void uwsgi_setup_log() {
 
 static struct uwsgi_logger *setup_choosen_logger(struct uwsgi_string_list *usl) {
 	char *id = NULL;
-                char *name = usl->value;
+	char *name = usl->value;
+
+	char *space = strchr(name, ' ');
+	if (space) {
+		int is_id = 1;
+		int i;
+		for (i = 0; i < (space - name); i++) {
+			if (!isalnum((int)name[i])) {
+				is_id = 0;
+				break;
+			}
+		}
+		if (is_id) {
+			id = uwsgi_concat2n(name, space - name, "", 0);
+			name = space + 1;
+		}
+	}
 
-                char *space = strchr(name, ' ');
-                if (space) {
-                        int is_id = 1;
-                        int i;
-                        for (i = 0; i < (space - name); i++) {
-                                if (!isalnum((int)name[i])) {
-                                        is_id = 0;
-                                        break;
-                                }
-                        }
-                        if (is_id) {
-                                id = uwsgi_concat2n(name, space - name, "", 0);
-                                name = space + 1;
-                        }
-                }
+	char *colon = strchr(name, ':');
+	if (colon) {
+		*colon = 0;
+	}
 
-                char *colon = strchr(name, ':');
-                if (colon) {
-                        *colon = 0;
-                }
+	struct uwsgi_logger *choosen_logger = uwsgi_get_logger(name);
+	if (!choosen_logger) {
+		uwsgi_log("unable to find logger %s\n", name);
+		exit(1);
+	}
 
-                struct uwsgi_logger *choosen_logger = uwsgi_get_logger(name);
-                if (!choosen_logger) {
-                        uwsgi_log("unable to find logger %s\n", name);
-                        exit(1);
-                }
+	// make a copy of the logger
+	struct uwsgi_logger *copy_of_choosen_logger = uwsgi_malloc(sizeof(struct uwsgi_logger));
+	memcpy(copy_of_choosen_logger, choosen_logger, sizeof(struct uwsgi_logger));
+	choosen_logger = copy_of_choosen_logger;
+	choosen_logger->id = id;
+	choosen_logger->next = NULL;
 
-                // make a copy of the logger
-                struct uwsgi_logger *copy_of_choosen_logger = uwsgi_malloc(sizeof(struct uwsgi_logger));
-                memcpy(copy_of_choosen_logger, choosen_logger, sizeof(struct uwsgi_logger));
-                choosen_logger = copy_of_choosen_logger;
-                choosen_logger->id = id;
-                choosen_logger->next = NULL;
-
-                if (colon) {
-                        choosen_logger->arg = colon + 1;
-                        // check for empty string
-                        if (*choosen_logger->arg == 0) {
-                                choosen_logger->arg = NULL;
-                        }
-                        *colon = ':';
-                }
-		return choosen_logger;
+	if (colon) {
+		choosen_logger->arg = colon + 1;
+		// check for empty string
+		if (*choosen_logger->arg == 0) {
+			choosen_logger->arg = NULL;
+		}
+		*colon = ':';
+	}
+	return choosen_logger;
 }
 
 void uwsgi_setup_log_master(void) {
@@ -519,40 +519,46 @@ void uwsgi_check_logrotate(void) {
 	}
 }
 
-void uwsgi_log_rotate() {
-	if (!uwsgi.logfile) return;
-	char *rot_name = uwsgi.log_backupname;
-                int need_free = 0;
-                if (rot_name == NULL) {
-                        char *ts_str = uwsgi_num2str((int) uwsgi_now());
-                        rot_name = uwsgi_concat3(uwsgi.logfile, ".", ts_str);
-                        free(ts_str);
-                        need_free = 1;
-                }
-		// this will be rawly written to the logfile
-                uwsgi_logfile_write("logsize: %llu, triggering rotation to %s...\n", (unsigned long long) uwsgi.shared->logsize, rot_name);
-                if (rename(uwsgi.logfile, rot_name) == 0) {
-                        // reopen logfile and dup'it, on dup2 error, exit(1)
-                        int fd = open(uwsgi.logfile, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP);
-                        if (fd < 0) {
-				// this will be written to the original file
-                                uwsgi_error_open(uwsgi.logfile);
+void uwsgi_log_do_rotate(char *logfile, char *rotatedfile, off_t logsize, int log_fd) {
+	int need_free = 0;
+	char *rot_name = rotatedfile;
+
+	if (rot_name == NULL) {
+		char *ts_str = uwsgi_num2str((int) uwsgi_now());
+		rot_name = uwsgi_concat3(logfile, ".", ts_str);
+		free(ts_str);
+		need_free = 1;
+	}
+	// this will be rawly written to the logfile
+	uwsgi_logfile_write("logsize: %llu, triggering rotation to %s...\n", (unsigned long long) logsize, rot_name);
+	if (rename(logfile, rot_name) == 0) {
+		// reopen logfile and dup'it, on dup2 error, exit(1)
+		int fd = open(logfile, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP);
+		if (fd < 0) {
+			// this will be written to the original file
+			uwsgi_error_open(logfile);
+			exit(1);
+		}
+		else {
+			if (dup2(fd, log_fd) < 0) {
+				// this could be lost :(
+				uwsgi_error("uwsgi_log_do_rotate()/dup2()");
 				exit(1);
-                        }
-                        else {
-                                if (dup2(fd, uwsgi.original_log_fd) < 0) {
-					// this could be lost :(
-                                        uwsgi_error("uwsgi_log_rotate()/dup2()");
-					exit(1);
-                                }
-                                close(fd);
-                        }
-                }
-                else {
-                        uwsgi_error("unable to rotate log: rename()");
-                }
-                if (need_free)
-                        free(rot_name);
+			}
+			close(fd);
+		}
+	}
+	else {
+		uwsgi_error("unable to rotate log: rename()");
+	}
+	if (need_free)
+		free(rot_name);
+}
+
+void uwsgi_log_rotate() {
+	if (!uwsgi.logfile)
+		return;
+	uwsgi_log_do_rotate(uwsgi.logfile, uwsgi.log_backupname, uwsgi.shared->logsize, uwsgi.original_log_fd);
 }
 
 void uwsgi_log_reopen() {
@@ -709,12 +715,12 @@ void uwsgi_logit_simple(struct wsgi_request *wsgi_req) {
 
 	}
 
-	rlen = snprintf(logpkt, 4096, "[pid: %d|app: %d|req: %d/%llu] %.*s (%.*s) {%d vars in %d bytes} [%.*s] %.*s %.*s => generated %llu bytes in %llu %s%s(%.*s %d) %d headers in %llu bytes (%d switches on core %d)\n", (int) uwsgi.mypid, wsgi_req->app_id, app_req, (unsigned long long) uwsgi.workers[0].requests, wsgi_req->remote_addr_len, wsgi_req->remote_addr, wsgi_req->remote_user_len, wsgi_req->remote_user, wsgi_req->var_cnt, wsgi_req->uh->pktsize,
+	rlen = snprintf(logpkt, 4096, "[pid: %d|app: %d|req: %d/%llu] %.*s (%.*s) {%d vars in %llu bytes} [%.*s] %.*s %.*s => generated %llu bytes in %llu %s%s(%.*s %d) %d headers in %llu bytes (%d switches on core %d)\n", (int) uwsgi.mypid, wsgi_req->app_id, app_req, (unsigned long long) uwsgi.workers[0].requests, wsgi_req->remote_addr_len, wsgi_req->remote_addr, wsgi_req->remote_user_len, wsgi_req->remote_user, wsgi_req->var_cnt, (unsigned long long) wsgi_req->len,
 			24, time_request, wsgi_req->method_len, wsgi_req->method, wsgi_req->uri_len, wsgi_req->uri, (unsigned long long) wsgi_req->response_size, (unsigned long long) rt, tsize, via, wsgi_req->protocol_len, wsgi_req->protocol, wsgi_req->status, wsgi_req->header_cnt, (unsigned long long) wsgi_req->headers_size, wsgi_req->switches, wsgi_req->async_id);
 
 	// not enough space for logging the request, just log a (safe) minimal message
 	if (rlen > 4096) {
-		rlen = snprintf(logpkt, 4096, "[pid: %d|app: %d|req: %d/%llu] 0.0.0.0 () {%d vars in %d bytes} [%.*s] - - => generated %llu bytes in %llu %s%s(- %d) %d headers in %llu bytes (%d switches on core %d)\n", (int) uwsgi.mypid, wsgi_req->app_id, app_req, (unsigned long long) uwsgi.workers[0].requests, wsgi_req->var_cnt, wsgi_req->uh->pktsize,
+		rlen = snprintf(logpkt, 4096, "[pid: %d|app: %d|req: %d/%llu] 0.0.0.0 () {%d vars in %llu bytes} [%.*s] - - => generated %llu bytes in %llu %s%s(- %d) %d headers in %llu bytes (%d switches on core %d)\n", (int) uwsgi.mypid, wsgi_req->app_id, app_req, (unsigned long long) uwsgi.workers[0].requests, wsgi_req->var_cnt, (unsigned long long) wsgi_req->len,
 		24, time_request, (unsigned long long) wsgi_req->response_size, (unsigned long long) rt, tsize, via, wsgi_req->status, wsgi_req->header_cnt, (unsigned long long) wsgi_req->headers_size, wsgi_req->switches, wsgi_req->async_id);
 		// argh, last resort, truncate it
 		if (rlen > 4096) {
@@ -1209,7 +1215,7 @@ static ssize_t uwsgi_lf_rssM(struct wsgi_request * wsgi_req, char **buf) {
 }
 
 static ssize_t uwsgi_lf_pktsize(struct wsgi_request * wsgi_req, char **buf) {
-	*buf = uwsgi_num2str(wsgi_req->uh->pktsize);
+	*buf = uwsgi_num2str(wsgi_req->len);
 	return strlen(*buf);
 }
 
diff --git a/core/master.c b/core/master.c
index ba192db..00ae1fa 100644
--- a/core/master.c
+++ b/core/master.c
@@ -7,6 +7,7 @@ void uwsgi_update_load_counters() {
 	int i;
 	uint64_t busy_workers = 0;
 	uint64_t idle_workers = 0;
+	static time_t last_sos = 0;
 
         for (i = 1; i <= uwsgi.numproc; i++) {
                 if (uwsgi.workers[i].cheaped == 0 && uwsgi.workers[i].pid > 0) {
@@ -21,6 +22,15 @@ void uwsgi_update_load_counters() {
 
 	if (busy_workers >= (uint64_t) uwsgi.numproc) {
 		ushared->overloaded++;
+	
+		if (uwsgi.vassal_sos) {
+			if (uwsgi.current_time - last_sos > uwsgi.vassal_sos) {
+                        	uwsgi_log_verbose("asking Emperor for reinforcements (overload: %llu)...\n", (unsigned long long) ushared->overloaded);
+				vassal_sos();
+				last_sos = uwsgi.current_time;
+			}
+		}
+
 	}
 
 	ushared->busy_workers = busy_workers;
@@ -273,17 +283,23 @@ static void master_check_listen_queue() {
         if (uwsgi.vassal_sos_backlog > 0 && uwsgi.has_emperor) {
         	if (uwsgi.shared->backlog >= (uint64_t) uwsgi.vassal_sos_backlog) {
                 	// ask emperor for help
-                        char byte = 30;
-                        if (write(uwsgi.emperor_fd, &byte, 1) != 1) {
-                        	uwsgi_error("write()");
-                        }
-                        else {
-                        	uwsgi_log_verbose("asking Emperor for reinforcements (backlog: %llu)...\n", (unsigned long long) uwsgi.shared->backlog);
-                        }
+                        uwsgi_log_verbose("asking Emperor for reinforcements (backlog: %llu)...\n", (unsigned long long) uwsgi.shared->backlog);
+			vassal_sos();
                 }
 	}
 }
 
+void vassal_sos() {
+	if (!uwsgi.has_emperor) {
+		uwsgi_log("[broodlord] instance not governed by an Emperor !!!\n");
+		return;	
+	}
+	char byte = 30;
+        if (write(uwsgi.emperor_fd, &byte, 1) != 1) {
+        	uwsgi_error("vassal_sos()/write()");
+        }
+}
+
 int master_loop(char **argv, char **environ) {
 
 	struct timeval last_respawn;
@@ -948,7 +964,9 @@ next:
 		// ok a worker died...
 		uwsgi.workers[thewid].pid = 0;
 		// only to be safe :P
-		uwsgi.workers[thewid].harakiri = 0;
+		for(i=0;i<uwsgi.cores;i++) {
+			uwsgi.workers[thewid].cores[i].harakiri = 0;
+		}
 
 		// ok, if we are reloading or dying, just continue the master loop
 		// as soon as all of the workers have pid == 0, the action (exit, or reload) is triggered
diff --git a/core/master_checks.c b/core/master_checks.c
index 85700e8..7da0e53 100644
--- a/core/master_checks.c
+++ b/core/master_checks.c
@@ -40,26 +40,44 @@ int uwsgi_master_check_reload(char **argv) {
 // check for chain reload
 void uwsgi_master_check_chain() {
 	if (!uwsgi.status.chain_reloading) return;
-	int i;
-	int needed_procs = 0;
-	for(i=1;i<=uwsgi.numproc;i++) {
-                if (uwsgi.workers[i].pid > 0 && uwsgi.workers[i].cheaped == 0) {
-			needed_procs++;
-                }
-        }
-	if (uwsgi.status.chain_reloading > needed_procs) {
+
+	// we need to ensure the previous worker (if alive) is accepting new requests
+	// before going on
+	if (uwsgi.status.chain_reloading > 1) {
+		struct uwsgi_worker *previous_worker = &uwsgi.workers[uwsgi.status.chain_reloading-1];
+		// is the previous worker alive ?
+		if (previous_worker->pid > 0 && !previous_worker->cheaped) {
+			// the worker has been respawned but it is still not ready
+			if (previous_worker->accepting == 0) {
+				uwsgi_log_verbose("chain is still waiting for worker %d...\n", uwsgi.status.chain_reloading-1);
+				return;
+			}
+		}
+	}
+
+	// if all the processes are recycled, the chain is over
+	if (uwsgi.status.chain_reloading > uwsgi.numproc) {
 		uwsgi.status.chain_reloading = 0;
                 uwsgi_log_verbose("chain reloading complete\n");
+		return;
 	}
+
 	uwsgi_block_signal(SIGHUP);
-	for(i=1;i<=uwsgi.numproc;i++) {
-		// do not curse a worker until the old one is ready
-		if (uwsgi.workers[i].accepting == 0) break;
-		if (uwsgi.workers[i].pid > 0 && uwsgi.workers[i].cheaped == 0 && uwsgi.workers[i].cursed_at == 0 && i == uwsgi.status.chain_reloading) {
-			uwsgi_curse(i, SIGHUP);
+	int i;
+	for(i=uwsgi.status.chain_reloading;i<=uwsgi.numproc;i++) {
+		struct uwsgi_worker *uw = &uwsgi.workers[i];
+		if (uw->pid > 0 && !uw->cheaped && uw->accepting) {
+			// the worker could have been already cursed
+			if (uw->cursed_at == 0) {
+				uwsgi_log_verbose("chain next victim is worker %d\n", i);
+				uwsgi_curse(i, SIGHUP);
+			}
 			break;
 		}
-	}
+		else {
+			uwsgi.status.chain_reloading++;
+		}
+        }
 	uwsgi_unblock_signal(SIGHUP);
 }
 
@@ -139,21 +157,27 @@ void uwsgi_master_check_idle() {
 }
 
 int uwsgi_master_check_workers_deadline() {
-	int i;
+	int i,j;
 	int ret = 0;
 	for (i = 1; i <= uwsgi.numproc; i++) {
-		/* first check for harakiri */
-		if (uwsgi.workers[i].harakiri > 0) {
-			if (uwsgi.workers[i].harakiri < (time_t) uwsgi.current_time) {
-				trigger_harakiri(i);
-				ret = 1;
+		for(j=0;j<uwsgi.cores;j++) {
+			/* first check for harakiri */
+			if (uwsgi.workers[i].cores[j].harakiri > 0) {
+				if (uwsgi.workers[i].cores[j].harakiri < (time_t) uwsgi.current_time) {
+					uwsgi_log_verbose("HARAKIRI triggered by worker %d core %d !!!\n", i, j);
+					trigger_harakiri(i);
+					ret = 1;
+					break;
+				}
 			}
-		}
-		/* then user-defined harakiri */
-		if (uwsgi.workers[i].user_harakiri > 0) {
-			if (uwsgi.workers[i].user_harakiri < (time_t) uwsgi.current_time) {
-				trigger_harakiri(i);
-				ret = 1;
+			/* then user-defined harakiri */
+			if (uwsgi.workers[i].cores[j].user_harakiri > 0) {
+				uwsgi_log_verbose("HARAKIRI (user) triggered by worker %d core %d !!!\n", i, j);
+				if (uwsgi.workers[i].cores[j].user_harakiri < (time_t) uwsgi.current_time) {
+					trigger_harakiri(i);
+					ret = 1;
+					break;
+				}
 			}
 		}
 		// then for evil memory checkers
diff --git a/core/master_events.c b/core/master_events.c
index eac8d0d..a8bec0f 100644
--- a/core/master_events.c
+++ b/core/master_events.c
@@ -45,7 +45,7 @@ int uwsgi_master_manage_events(int interesting_fd) {
 	// emperor event ?
 	if (uwsgi.has_emperor) {
 		if (uwsgi.emperor_fd_proxy > -1 && interesting_fd == uwsgi.emperor_fd_proxy) {
-			uwsgi_master_manage_emperor_proxy();	
+			uwsgi_master_manage_emperor_proxy(uwsgi.emperor_fd_proxy, uwsgi.emperor_fd, uwsgi.emperor_fd_config, -1);	
 			return 0;
 		}
 
diff --git a/core/master_utils.c b/core/master_utils.c
index 159e2a7..b0d3d28 100644
--- a/core/master_utils.c
+++ b/core/master_utils.c
@@ -388,6 +388,8 @@ void uwsgi_reload(char **argv) {
 	int i;
 	int waitpid_status;
 
+	if (uwsgi.new_argv) argv = uwsgi.new_argv;
+
 	if (!uwsgi.master_is_reforked) {
 
 		// call a series of waitpid to ensure all processes (gateways, mules and daemons) are dead
@@ -630,7 +632,7 @@ void uwsgi_fixup_fds(int wid, int muleid, struct uwsgi_gateway *ug) {
 }
 
 int uwsgi_respawn_worker(int wid) {
-
+	int i;
 	int respawns = uwsgi.workers[wid].respawn_count;
 	// the workers is not accepting (obviously)
 	uwsgi.workers[wid].accepting = 0;
@@ -639,8 +641,10 @@ int uwsgi_respawn_worker(int wid) {
 	// ... same for update time
 	uwsgi.workers[wid].last_spawn = uwsgi.current_time;
 	// ... and memory/harakiri
-	uwsgi.workers[wid].harakiri = 0;
-	uwsgi.workers[wid].user_harakiri = 0;
+	for(i=0;i<uwsgi.cores;i++) {
+		uwsgi.workers[wid].cores[i].harakiri = 0;
+		uwsgi.workers[wid].cores[i].user_harakiri = 0;
+	}
 	uwsgi.workers[wid].pending_harakiri = 0;
 	uwsgi.workers[wid].rss_size = 0;
 	uwsgi.workers[wid].vsz_size = 0;
@@ -658,8 +662,6 @@ int uwsgi_respawn_worker(int wid) {
 	// this is required for various checks
 	uwsgi.workers[wid].delta_requests = 0;
 
-	int i;
-
 	if (uwsgi.threaded_logger) {
 		pthread_mutex_lock(&uwsgi.threaded_logger_lock);
 	}
@@ -1719,6 +1721,7 @@ void uwsgi_setns_preopen() {
         }
         while ((de = readdir(ns)) != NULL) {
                 if (strlen(de->d_name) > 0 && de->d_name[0] == '.') continue;
+		if (!strcmp(de->d_name, "user")) continue;
                 struct uwsgi_string_list *usl = NULL;
                 int found = 0;
                 uwsgi_foreach(usl, uwsgi.setns_socket_skip) {
@@ -1777,6 +1780,7 @@ void uwsgi_master_manage_setns(int fd) {
 	}
 	while ((de = readdir(ns)) != NULL) {
 		if (strlen(de->d_name) > 0 && de->d_name[0] == '.') continue;
+		if (!strcmp(de->d_name, "user")) continue;
 		struct uwsgi_string_list *usl = NULL;
 		int found = 0;
 		uwsgi_foreach(usl, uwsgi.setns_socket_skip) {
diff --git a/core/mule.c b/core/mule.c
index 8a2211c..a40a177 100644
--- a/core/mule.c
+++ b/core/mule.c
@@ -198,7 +198,7 @@ void uwsgi_mule_handler() {
 #ifdef UWSGI_DEBUG
 			uwsgi_log_verbose("master sent signal %d to mule %d\n", uwsgi_signal, uwsgi.muleid);
 #endif
-			if (uwsgi_signal_handler(uwsgi_signal)) {
+			if (uwsgi_signal_handler(NULL, uwsgi_signal)) {
 				uwsgi_log_verbose("error managing signal %d on mule %d\n", uwsgi_signal, uwsgi.muleid);
 			}
 		}
@@ -362,7 +362,7 @@ retry:
 #ifdef UWSGI_DEBUG
 					uwsgi_log_verbose("master sent signal %d to mule %d\n", uwsgi_signal, uwsgi.muleid);
 #endif
-					if (uwsgi_signal_handler(uwsgi_signal)) {
+					if (uwsgi_signal_handler(NULL, uwsgi_signal)) {
 						uwsgi_log_verbose("error managing signal %d on mule %d\n", uwsgi_signal, uwsgi.muleid);
 					}
 					// set the error condition
diff --git a/core/offload.c b/core/offload.c
index 5b8787f..0ec75bd 100644
--- a/core/offload.c
+++ b/core/offload.c
@@ -55,6 +55,9 @@ static int uwsgi_offload_enqueue(struct wsgi_request *wsgi_req, struct uwsgi_off
 		}
 		return -1;
 	}
+#ifdef UWSGI_DEBUG
+        uwsgi_log("[offload] created session %p\n", uor);
+#endif
 	return 0;
 }
 
@@ -159,6 +162,12 @@ static int u_offload_sendfile_prepare(struct wsgi_request *wsgi_req, struct uwsg
 }
 
 static void uwsgi_offload_close(struct uwsgi_thread *ut, struct uwsgi_offload_request *uor) {
+
+	// call the free function asap
+	if (uor->free) {
+		uor->free(uor);
+	}
+
 	// close the socket and the file descriptor
 	if (uor->takeover && uor->s > -1) {
 		close(uor->s);
@@ -197,12 +206,41 @@ static void uwsgi_offload_close(struct uwsgi_thread *ut, struct uwsgi_offload_re
 		uwsgi_buffer_destroy(uor->ubuf);
 	}
 
+	if (uor->ubuf1) {
+		uwsgi_buffer_destroy(uor->ubuf1);
+	}
+	if (uor->ubuf2) {
+		uwsgi_buffer_destroy(uor->ubuf2);
+	}
+	if (uor->ubuf3) {
+		uwsgi_buffer_destroy(uor->ubuf3);
+	}
+	if (uor->ubuf4) {
+		uwsgi_buffer_destroy(uor->ubuf4);
+	}
+	if (uor->ubuf5) {
+		uwsgi_buffer_destroy(uor->ubuf5);
+	}
+	if (uor->ubuf6) {
+		uwsgi_buffer_destroy(uor->ubuf6);
+	}
+	if (uor->ubuf7) {
+		uwsgi_buffer_destroy(uor->ubuf7);
+	}
+	if (uor->ubuf8) {
+		uwsgi_buffer_destroy(uor->ubuf8);
+	}
+
 	if (uor->pipe[0] != -1) {
 		close(uor->pipe[1]);
 		close(uor->pipe[0]);
 	}
 
 	free(uor);
+
+#ifdef UWSGI_DEBUG
+	uwsgi_log("[offload] destroyed session %p\n", uor);
+#endif
 }
 
 static void uwsgi_offload_append(struct uwsgi_thread *ut, struct uwsgi_offload_request *uor) {
@@ -575,6 +613,9 @@ int uwsgi_offload_run(struct wsgi_request *wsgi_req, struct uwsgi_offload_reques
 
         if (uor->takeover) {
                 wsgi_req->fd_closed = 1;
+		// avoid edge-triggered mode
+		if (wsgi_req->socket->retry)
+			wsgi_req->socket->retry[wsgi_req->async_id] = 0;
         }
 
 	if (uwsgi_offload_enqueue(wsgi_req, uor)) {
diff --git a/core/protocol.c b/core/protocol.c
index fbecacf..5e650af 100644
--- a/core/protocol.c
+++ b/core/protocol.c
@@ -46,10 +46,10 @@ int uwsgi_read_response(int fd, struct uwsgi_header *uh, int timeout, char **buf
 		break;
 	}
 
-	if (buf && uh->pktsize > 0) {
+	if (buf && uh->_pktsize > 0) {
 		if (*buf == NULL)
-			*buf = uwsgi_malloc(uh->pktsize);
-		remains = uh->pktsize;
+			*buf = uwsgi_malloc(uh->_pktsize);
+		remains = uh->_pktsize;
 		ptr = *buf;
 		ret = -1;
 		while (remains > 0) {
@@ -527,6 +527,11 @@ static int uwsgi_proto_check_22(struct wsgi_request *wsgi_req, char *key, char *
 		return 0;
 	}
 
+	if (!uwsgi_proto_key("HTTP_X_FORWARDED_PROTO", 22)) {
+                wsgi_req->scheme = buf;
+                wsgi_req->scheme_len = len;
+        }
+
 	return 0;
 }
 
@@ -573,7 +578,7 @@ int uwsgi_parse_vars(struct wsgi_request *wsgi_req) {
 	struct uwsgi_dyn_dict *udd;
 
 	ptrbuf = buffer;
-	bufferend = ptrbuf + wsgi_req->uh->pktsize;
+	bufferend = ptrbuf + wsgi_req->len;
 	int i;
 
 	/* set an HTTP 500 status as default */
@@ -1030,7 +1035,7 @@ char *uwsgi_req_append(struct wsgi_request *wsgi_req, char *key, uint16_t keylen
 		}
 	}
 
-	if ((wsgi_req->uh->pktsize + (2 + keylen + 2 + vallen)) > uwsgi.buffer_size) {
+	if ((wsgi_req->len + (2 + keylen + 2 + vallen)) > uwsgi.buffer_size) {
 		uwsgi_log("not enough buffer space to add %.*s variable, consider increasing it with the --buffer-size option\n", keylen, key);
 		return NULL;
 	}
@@ -1040,7 +1045,7 @@ char *uwsgi_req_append(struct wsgi_request *wsgi_req, char *key, uint16_t keylen
 		return NULL;
 	}
 
-	char *ptr = wsgi_req->buffer + wsgi_req->uh->pktsize;
+	char *ptr = wsgi_req->buffer + wsgi_req->len;
 
 	*ptr++ = (uint8_t) (keylen & 0xff);
 	*ptr++ = (uint8_t) ((keylen >> 8) & 0xff);
@@ -1061,7 +1066,7 @@ char *uwsgi_req_append(struct wsgi_request *wsgi_req, char *key, uint16_t keylen
         wsgi_req->hvec[wsgi_req->var_cnt].iov_len = vallen;
 	wsgi_req->var_cnt++;
 
-	wsgi_req->uh->pktsize += (2 + keylen + 2 + vallen);
+	wsgi_req->len += (2 + keylen + 2 + vallen);
 
 	return ptr;
 }
@@ -1086,7 +1091,7 @@ int uwsgi_req_append_path_info_with_index(struct wsgi_request *wsgi_req, char *i
 	wsgi_req->path_info_len += need_slash + index_len;
 
 	// 2 + 9 + 2
-	if ((wsgi_req->uh->pktsize + (13 + wsgi_req->path_info_len)) > uwsgi.buffer_size) {
+	if ((wsgi_req->len + (13 + wsgi_req->path_info_len)) > uwsgi.buffer_size) {
                 uwsgi_log("not enough buffer space to transform the PATH_INFO variable, consider increasing it with the --buffer-size option\n");
                 return -1;
         }
@@ -1097,7 +1102,7 @@ int uwsgi_req_append_path_info_with_index(struct wsgi_request *wsgi_req, char *i
         }
 
 	uint16_t keylen = 9;
-	char *ptr = wsgi_req->buffer + wsgi_req->uh->pktsize;
+	char *ptr = wsgi_req->buffer + wsgi_req->len;
 	*ptr++ = (uint8_t) (keylen & 0xff);
         *ptr++ = (uint8_t) ((keylen >> 8) & 0xff);
 
@@ -1123,7 +1128,7 @@ int uwsgi_req_append_path_info_with_index(struct wsgi_request *wsgi_req, char *i
         wsgi_req->hvec[wsgi_req->var_cnt].iov_len = wsgi_req->path_info_len;
         wsgi_req->var_cnt++;
 
-	wsgi_req->uh->pktsize += 13 + wsgi_req->path_info_len;
+	wsgi_req->len += 13 + wsgi_req->path_info_len;
 	wsgi_req->path_info = new_path_info;
 	
 	return 0;
diff --git a/core/reader.c b/core/reader.c
index 274bf6f..23d1f92 100644
--- a/core/reader.c
+++ b/core/reader.c
@@ -123,7 +123,7 @@ static int consume_body_for_readline(struct wsgi_request *wsgi_req) {
 
 	// allocate more memory if needed
 	if (wsgi_req->post_readline_size - wsgi_req->post_readline_watermark == 0) {
-		memcpy(wsgi_req->post_readline_buf, wsgi_req->post_readline_buf + wsgi_req->post_readline_pos, wsgi_req->post_readline_watermark - wsgi_req->post_readline_pos);
+		memmove(wsgi_req->post_readline_buf, wsgi_req->post_readline_buf + wsgi_req->post_readline_pos, wsgi_req->post_readline_watermark - wsgi_req->post_readline_pos);
 		wsgi_req->post_readline_watermark -= wsgi_req->post_readline_pos;
 		wsgi_req->post_readline_pos = 0;
 		// still something to use ?
@@ -477,7 +477,7 @@ int uwsgi_postbuffer_do_in_mem(struct wsgi_request *wsgi_req) {
 
         while (remains > 0) {
                 if (uwsgi.harakiri_options.workers > 0) {
-                        inc_harakiri(uwsgi.harakiri_options.workers);
+                        inc_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
                 }
 
                 ssize_t rlen = wsgi_req->socket->proto_read_body(wsgi_req, ptr, remains);
@@ -551,7 +551,7 @@ int uwsgi_postbuffer_do_in_disk(struct wsgi_request *wsgi_req) {
 
                 // during post buffering we need to constantly reset the harakiri
                 if (uwsgi.harakiri_options.workers > 0) {
-                        inc_harakiri(uwsgi.harakiri_options.workers);
+                        inc_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
                 }
 
                 // we use the already available post buffering buffer to read chunks....
diff --git a/core/routing.c b/core/routing.c
index 5cfbc1a..8daab1c 100644
--- a/core/routing.c
+++ b/core/routing.c
@@ -702,7 +702,7 @@ static int uwsgi_router_simple_math_divide(struct uwsgi_route *ur, char *arg) {
 // harakiri router
 static int uwsgi_router_harakiri_func(struct wsgi_request *wsgi_req, struct uwsgi_route *route) {
 	if (route->custom > 0) {	
-		set_user_harakiri(route->custom);
+		set_user_harakiri(wsgi_req, route->custom);
 	}
 	return UWSGI_ROUTE_NEXT;
 }
@@ -1753,6 +1753,10 @@ static char *uwsgi_route_var_uwsgi(struct wsgi_request *wsgi_req, char *key, uin
                 ret = uwsgi_num2str(uwsgi.shared->backlog);
                 *vallen = strlen(ret);
         }
+	else if (!uwsgi_strncmp(key, keylen, "rsize", 5)) {
+                ret = uwsgi_64bit2str(wsgi_req->response_size);
+                *vallen = strlen(ret);
+        }
 
 	return ret;
 }
diff --git a/core/rpc.c b/core/rpc.c
index 8f51b0f..0008483 100644
--- a/core/rpc.c
+++ b/core/rpc.c
@@ -7,6 +7,11 @@ int uwsgi_register_rpc(char *name, struct uwsgi_plugin *plugin, uint8_t args, vo
 	struct uwsgi_rpc *urpc;
 	int ret = -1;
 
+	if (!uwsgi.workers || !uwsgi.shared || !uwsgi.rpc_table_lock) {
+		uwsgi_log("RPC subsystem still not initialized\n");
+		return -1;
+	}
+
 	if (uwsgi.mywid == 0 && uwsgi.workers[0].pid != uwsgi.mypid) {
 		uwsgi_log("only the master and the workers can register RPC functions\n");
 		return -1;
@@ -140,7 +145,7 @@ char *uwsgi_do_rpc(char *node, char *func, uint8_t argc, char *argv[], uint16_t
 	// set the uwsgi header
 	uh = (struct uwsgi_header *) buffer;
 	uh->modifier1 = 173;
-	uh->pktsize = buffer_size;
+	uh->_pktsize = buffer_size;
 	uh->modifier2 = 0;
 
 	// add func to the array
@@ -193,12 +198,13 @@ char *uwsgi_do_rpc(char *node, char *func, uint8_t argc, char *argv[], uint16_t
 	close(fd);
 	*len = rlen;
 	if (*len == 0) {
-		goto error;
+		goto error2;
 	}
 	return buffer;
 
 error:
 	close(fd);
+error2:
 	free(buffer);
 	return NULL;
 
diff --git a/core/sendfile.c b/core/sendfile.c
index 9dd11ef..482460d 100644
--- a/core/sendfile.c
+++ b/core/sendfile.c
@@ -20,9 +20,18 @@ ssize_t uwsgi_sendfile_do(int sockfd, int filefd, size_t pos, size_t len) {
 	int sf_ret = sendfile(filefd, sockfd, pos, &sf_len, NULL, 0);
 	if (sf_ret == 0 || (sf_ret == -1 && errno == EAGAIN)) return sf_len;
 	return -1;
-#elif defined(__linux__) || defined(__sun__) || defined(__GNU_kFreeBSD__)
+#elif defined(__linux__) || defined(__GNU_kFreeBSD__)
 	off_t off = pos;
 	return sendfile(sockfd, filefd, &off, len);
+#elif defined(__sun__)
+	off_t off = pos;
+	ssize_t wlen = sendfile(sockfd, filefd, &off, len);
+	if (wlen < 0 && uwsgi_is_again()) {
+		if (off - pos > 0) {
+			return off-pos;
+		}
+	}
+	return wlen;
 #endif
 
 no_sendfile:
diff --git a/core/signal.c b/core/signal.c
index be20bd2..093e598 100644
--- a/core/signal.c
+++ b/core/signal.c
@@ -2,7 +2,7 @@
 
 extern struct uwsgi_server uwsgi;
 
-int uwsgi_signal_handler(uint8_t sig) {
+int uwsgi_signal_handler(struct wsgi_request *wsgi_req, uint8_t sig) {
 
 	struct uwsgi_signal_entry *use = NULL;
 
@@ -41,12 +41,12 @@ int uwsgi_signal_handler(uint8_t sig) {
 
 	// set harakiri here (if required and if i am a worker)
 
-	if (uwsgi.mywid > 0) {
+	if (uwsgi.mywid > 0 && wsgi_req) {
 		uwsgi.workers[uwsgi.mywid].sig = 1;
 		uwsgi.workers[uwsgi.mywid].signum = sig;
 		uwsgi.workers[uwsgi.mywid].signals++;
 		if (uwsgi.harakiri_options.workers > 0) {
-			set_harakiri(uwsgi.harakiri_options.workers);
+			set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
 		}
 	}
 	else if (uwsgi.muleid > 0) {
@@ -65,10 +65,10 @@ int uwsgi_signal_handler(uint8_t sig) {
 
 	int ret = uwsgi.p[use->modifier1]->signal_handler(sig, use->handler);
 
-	if (uwsgi.mywid > 0) {
+	if (uwsgi.mywid > 0 && wsgi_req) {
 		uwsgi.workers[uwsgi.mywid].sig = 0;
-		if (uwsgi.workers[uwsgi.mywid].harakiri > 0) {
-			set_harakiri(0);
+		if (uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri > 0) {
+			set_harakiri(wsgi_req, 0);
 		}
 	}
 	else if (uwsgi.muleid > 0) {
@@ -266,7 +266,7 @@ int uwsgi_remote_signal_send(char *addr, uint8_t sig) {
 	struct uwsgi_header uh;
 
 	uh.modifier1 = 110;
-	uh.pktsize = 0;
+	uh._pktsize = 0;
 	uh.modifier2 = sig;
 
         int fd = uwsgi_connect(addr, 0, 1);
@@ -405,7 +405,7 @@ void uwsgi_route_signal(uint8_t sig) {
 
 }
 
-int uwsgi_signal_wait(int signum) {
+int uwsgi_signal_wait(struct wsgi_request *wsgi_req, int signum) {
 
 	int wait_for_specific_signal = 0;
 	uint8_t uwsgi_signal = 0;
@@ -430,7 +430,7 @@ cycle:
 				uwsgi_error("read()");
 			}
 			else {
-				(void) uwsgi_signal_handler(uwsgi_signal);
+				(void) uwsgi_signal_handler(wsgi_req, uwsgi_signal);
 				if (wait_for_specific_signal) {
 					if (signum != uwsgi_signal)
 						goto cycle;
@@ -443,7 +443,7 @@ cycle:
 				uwsgi_error("read()");
 			}
 			else {
-				(void) uwsgi_signal_handler(uwsgi_signal);
+				(void) uwsgi_signal_handler(wsgi_req, uwsgi_signal);
 				if (wait_for_specific_signal) {
 					if (signum != uwsgi_signal)
 						goto cycle;
@@ -457,7 +457,7 @@ cycle:
 	return received_signal;
 }
 
-void uwsgi_receive_signal(int fd, char *name, int id) {
+void uwsgi_receive_signal(struct wsgi_request *wsgi_req, int fd, char *name, int id) {
 
 	uint8_t uwsgi_signal;
 
@@ -474,7 +474,7 @@ void uwsgi_receive_signal(int fd, char *name, int id) {
 #ifdef UWSGI_DEBUG
 		uwsgi_log_verbose("master sent signal %d to %s %d\n", uwsgi_signal, name, id);
 #endif
-		if (uwsgi_signal_handler(uwsgi_signal)) {
+		if (uwsgi_signal_handler(wsgi_req, uwsgi_signal)) {
 			uwsgi_log_verbose("error managing signal %d on %s %d\n", uwsgi_signal, name, id);
 		}
 	}
diff --git a/core/socket.c b/core/socket.c
index cbce4ec..32a1b2e 100644
--- a/core/socket.c
+++ b/core/socket.c
@@ -51,6 +51,8 @@ char *uwsgi_getsockname(int fd) {
 
 	if (!getsockname(fd, gsa.sa, &socket_type_len)) {
 		if (gsa.sa->sa_family == AF_UNIX) {
+			// unnamed socket ?
+			if (socket_type_len == sizeof(sa_family_t)) return "";
 			if (usa.sa_un.sun_path[0] == 0) {
 				return uwsgi_concat2("@", usa.sa_un.sun_path + 1);
 			}
@@ -1935,6 +1937,7 @@ void uwsgi_protocols_register() {
 	uwsgi_register_protocol("puwsgi", uwsgi_proto_puwsgi_setup);
 
 	uwsgi_register_protocol("http", uwsgi_proto_http_setup);
+	uwsgi_register_protocol("http11", uwsgi_proto_http11_setup);
 
 #ifdef UWSGI_SSL
 	uwsgi_register_protocol("suwsgi", uwsgi_proto_suwsgi_setup);
diff --git a/core/spooler.c b/core/spooler.c
index cc92c70..8f468cc 100644
--- a/core/spooler.c
+++ b/core/spooler.c
@@ -1,11 +1,13 @@
 #include "uwsgi.h"
 
+#ifdef __sun__
+#include "strings.h"
+#endif
+
 extern struct uwsgi_server uwsgi;
 
 static void spooler_readdir(struct uwsgi_spooler *, char *dir);
-#ifdef __linux__
 static void spooler_scandir(struct uwsgi_spooler *, char *dir);
-#endif
 static void spooler_manage_task(struct uwsgi_spooler *, char *, char *);
 
 // increment it whenever a signal is raised
@@ -200,11 +202,13 @@ static void spooler_req_parser_hook(char *key, uint16_t key_len, char *value, ui
 	}
 }
 
+/*
+CHANGED in 2.0.7: wsgi_req is useless !
+*/
 char *uwsgi_spool_request(struct wsgi_request *wsgi_req, char *buf, size_t len, char *body, size_t body_len) {
 
 	struct timeval tv;
 	static uint64_t internal_counter = 0;
-	int core_id = 0;
 	int fd = -1;
 	struct spooler_req sr;
 
@@ -232,10 +236,6 @@ char *uwsgi_spool_request(struct wsgi_request *wsgi_req, char *buf, size_t len,
 		}
 	}
 
-	if (wsgi_req) {
-		core_id = wsgi_req->async_id;
-	}
-
 	// this lock is for threads, the pid value in filename will avoid multiprocess races
 	uwsgi_lock(uspool->lock);
 
@@ -260,7 +260,7 @@ char *uwsgi_spool_request(struct wsgi_request *wsgi_req, char *buf, size_t len,
 		// no need to check for errors...
 		(void) mkdir(filename, 0777);
 
-		ret = snprintf(filename, filename_len, "%s/%.*s/uwsgi_spoolfile_on_%s_%d_%llu_%d_%llu_%llu", uspool->dir, (int)sr.priority_len, sr.priority, uwsgi.hostname, (int) getpid(), (unsigned long long) internal_counter, core_id,
+		ret = snprintf(filename, filename_len, "%s/%.*s/uwsgi_spoolfile_on_%s_%d_%llu_%d_%llu_%llu", uspool->dir, (int)sr.priority_len, sr.priority, uwsgi.hostname, (int) getpid(), (unsigned long long) internal_counter, rand(),
 				(unsigned long long) tv.tv_sec, (unsigned long long) tv.tv_usec);
 		if (ret <= 0 || ret >=(int)  filename_len) {
                         uwsgi_log("[uwsgi-spooler] error generating spooler filename\n");
@@ -272,8 +272,8 @@ char *uwsgi_spool_request(struct wsgi_request *wsgi_req, char *buf, size_t len,
 	else {
 		filename_len = strlen(uspool->dir) + strlen(uwsgi.hostname) + 256;
                 filename = uwsgi_malloc(filename_len);
-		int ret = snprintf(filename, filename_len, "%s/uwsgi_spoolfile_on_%s_%d_%llu_%d_%llu_%llu", uspool->dir, uwsgi.hostname, (int) getpid(), (unsigned long long) internal_counter, core_id,
-				(unsigned long long) tv.tv_sec, (unsigned long long) tv.tv_usec);
+		int ret = snprintf(filename, filename_len, "%s/uwsgi_spoolfile_on_%s_%d_%llu_%d_%llu_%llu", uspool->dir, uwsgi.hostname, (int) getpid(), (unsigned long long) internal_counter,
+				rand(), (unsigned long long) tv.tv_sec, (unsigned long long) tv.tv_usec);
 		if (ret <= 0 || ret >= (int) filename_len) {
                         uwsgi_log("[uwsgi-spooler] error generating spooler filename\n");
 			free(filename);
@@ -303,9 +303,9 @@ char *uwsgi_spool_request(struct wsgi_request *wsgi_req, char *buf, size_t len,
 	struct uwsgi_header uh;
 	uh.modifier1 = 17;
 	uh.modifier2 = 0;
-	uh.pktsize = (uint16_t) len;
+	uh._pktsize = (uint16_t) len;
 #ifdef __BIG_ENDIAN__
-	uh.pktsize = uwsgi_swap16(uh.pktsize);
+	uh._pktsize = uwsgi_swap16(uh._pktsize);
 #endif
 
 	if (write(fd, &uh, 4) != 4) {
@@ -440,11 +440,7 @@ void spooler(struct uwsgi_spooler *uspool) {
 		}
 
 		if (uwsgi.spooler_ordered) {
-#ifdef __linux__
 			spooler_scandir(uspool, NULL);
-#else
-			spooler_readdir(uspool, NULL);
-#endif
 		}
 		else {
 			spooler_readdir(uspool, NULL);
@@ -458,7 +454,7 @@ void spooler(struct uwsgi_spooler *uspool) {
 		if (event_queue_wait(spooler_event_queue, timeout, &interesting_fd) > 0) {
 			if (uwsgi.master_process) {
 				if (interesting_fd == uwsgi.shared->spooler_signal_pipe[1]) {
-					uwsgi_receive_signal(interesting_fd, "spooler", (int) getpid());
+					uwsgi_receive_signal(NULL, interesting_fd, "spooler", (int) getpid());
 				}
 			}
 		}
@@ -473,7 +469,6 @@ void spooler(struct uwsgi_spooler *uspool) {
 	}
 }
 
-#ifdef __linux__
 static void spooler_scandir(struct uwsgi_spooler *uspool, char *dir) {
 
 	struct dirent **tasklist;
@@ -482,7 +477,8 @@ static void spooler_scandir(struct uwsgi_spooler *uspool, char *dir) {
 	if (!dir)
 		dir = uspool->dir;
 
-	n = scandir(dir, &tasklist, 0, versionsort);
+	n = scandir(dir, &tasklist, 0, uwsgi_versionsort);
+
 	if (n < 0) {
 		uwsgi_error("scandir()");
 		return;
@@ -495,7 +491,6 @@ static void spooler_scandir(struct uwsgi_spooler *uspool, char *dir) {
 
 	free(tasklist);
 }
-#endif
 
 
 static void spooler_readdir(struct uwsgi_spooler *uspool, char *dir) {
@@ -543,7 +538,6 @@ void spooler_manage_task(struct uwsgi_spooler *uspool, char *dir, char *task) {
 			return;
 		}
 
-#ifdef __linux__
 		if (S_ISDIR(sf_lstat.st_mode) && uwsgi.spooler_ordered) {
 			if (chdir(task)) {
 				uwsgi_error("chdir()");
@@ -557,7 +551,6 @@ void spooler_manage_task(struct uwsgi_spooler *uspool, char *dir, char *task) {
 			}
 			return;
 		}
-#endif
 		if (!S_ISREG(sf_lstat.st_mode)) {
 			return;
 		}
@@ -594,10 +587,10 @@ void spooler_manage_task(struct uwsgi_spooler *uspool, char *dir, char *task) {
 			}
 
 #ifdef __BIG_ENDIAN__
-			uh.pktsize = uwsgi_swap16(uh.pktsize);
+			uh._pktsize = uwsgi_swap16(uh._pktsize);
 #endif
 
-			if (uwsgi_protected_read(spool_fd, spool_buf, uh.pktsize) != uh.pktsize) {
+			if (uwsgi_protected_read(spool_fd, spool_buf, uh._pktsize) != uh._pktsize) {
 				uwsgi_error("read()");
 				destroy_spool(dir, task);
 				uwsgi_protected_close(spool_fd);
@@ -605,8 +598,8 @@ void spooler_manage_task(struct uwsgi_spooler *uspool, char *dir, char *task) {
 			}
 
 			// body available ?
-			if (sf_lstat.st_size > (uh.pktsize + 4)) {
-				body_len = sf_lstat.st_size - (uh.pktsize + 4);
+			if (sf_lstat.st_size > (uh._pktsize + 4)) {
+				body_len = sf_lstat.st_size - (uh._pktsize + 4);
 				body = uwsgi_malloc(body_len);
 				if ((size_t) uwsgi_protected_read(spool_fd, body, body_len) != body_len) {
 					uwsgi_error("read()");
@@ -638,7 +631,7 @@ void spooler_manage_task(struct uwsgi_spooler *uspool, char *dir, char *task) {
 					if (uwsgi.harakiri_options.spoolers > 0) {
 						set_spooler_harakiri(uwsgi.harakiri_options.spoolers);
 					}
-					ret = uwsgi.p[i]->spooler(task, spool_buf, uh.pktsize, body, body_len);
+					ret = uwsgi.p[i]->spooler(task, spool_buf, uh._pktsize, body, body_len);
 					if (uwsgi.harakiri_options.spoolers > 0) {
 						set_spooler_harakiri(0);
 					}
diff --git a/core/ssl.c b/core/ssl.c
index a52f318..124343c 100644
--- a/core/ssl.c
+++ b/core/ssl.c
@@ -494,6 +494,13 @@ clear:
 }
 
 char *uwsgi_sanitize_cert_filename(char *base, char *key, uint16_t keylen) {
+	// stop at the first slash if mountpoints are involved
+	if (uwsgi.subscription_mountpoints) {
+		char *slash = memchr(key, '/', keylen);
+		if (slash) {
+			keylen = slash - key;
+		}
+	}
         uint16_t i;
         char *filename = uwsgi_concat4n(base, strlen(base), "/", 1, key, keylen, ".pem\0", 5);
 
diff --git a/core/static.c b/core/static.c
index 86683be..a1a0ec8 100644
--- a/core/static.c
+++ b/core/static.c
@@ -167,6 +167,9 @@ static time_t parse_http_date(char *date, uint16_t len) {
 
 }
 
+time_t uwsgi_parse_http_date(char *buf, uint16_t len) {
+	return parse_http_date(buf, len);
+}
 
 
 int uwsgi_add_expires_type(struct wsgi_request *wsgi_req, char *mime_type, int mime_type_len, struct stat *st) {
diff --git a/core/stats.c b/core/stats.c
index c54b186..22a4b93 100644
--- a/core/stats.c
+++ b/core/stats.c
@@ -569,14 +569,13 @@ static void stats_dump_var(char *k, uint16_t kl, char *v, uint16_t vl, void *dat
 
 int uwsgi_stats_dump_vars(struct uwsgi_stats *us, struct uwsgi_core *uc) {
 	if (!uc->in_request) return 0;
-	struct uwsgi_header *uh = (struct uwsgi_header *) uc->buffer;
-	uint16_t pktsize = uh->pktsize;
+	uint64_t pktsize = uc->req.len;
 	if (!pktsize) return 0;
 	char *dst = uwsgi.workers[0].cores[0].buffer;
 	memcpy(dst, uc->buffer+4, uwsgi.buffer_size);
 	// ok now check if something changed...
 	if (!uc->in_request) return 0;
-	if (uh->pktsize != pktsize) return 0;
+	if (uc->req.len != pktsize) return 0;
 	if (memcmp(dst, uc->buffer+4, uwsgi.buffer_size)) return 0;
 	// nothing changed let's dump vars
 	int ret = uwsgi_hooked_parse(dst, pktsize, stats_dump_var, us);
diff --git a/core/strings.c b/core/strings.c
index cb4667a..c14cf31 100644
--- a/core/strings.c
+++ b/core/strings.c
@@ -65,16 +65,9 @@ char *uwsgi_lower(char *str, size_t size) {
         return str;
 }
 
-// check if a string is contained in another one
+// check if a char is contained in a string
 char *uwsgi_str_contains(char *str, int slen, char what) {
-
-        int i;
-        for (i = 0; i < slen; i++) {
-                if (str[i] == what) {
-                        return str + i;
-                }
-        }
-        return NULL;
+        return memchr(str, what, slen);
 }
 
 int uwsgi_contains_n(char *s1, size_t s1_len, char *s2, size_t s2_len) {
@@ -126,15 +119,7 @@ int uwsgi_starts_with(char *src, int slen, char *dst, int dlen) {
 
 // unsized check
 int uwsgi_startswith(char *src, char *what, int wlen) {
-
-        int i;
-
-        for (i = 0; i < wlen; i++) {
-                if (src[i] != what[i])
-                        return -1;
-        }
-
-        return 0;
+        return memcmp(what, src, wlen);
 }
 
 // concatenate strings
@@ -483,3 +468,22 @@ char ** uwsgi_split_quoted(char *what, size_t what_len, char *sep, size_t *rlen)
 
 	return ret;
 }
+
+char *uwsgi_get_last_char(char *what, char c) {
+	return strrchr(what, c);
+}
+
+// Note by Mathieu Dupuy: memrchr here is better, unfortunately it is not supported
+// everywhere. The only safe option looks checking for Linux :(
+char *uwsgi_get_last_charn(char *what, size_t len, char c) {
+#if defined(__linux__)
+	return memrchr(what, c, len);
+#else
+        while (len--) {
+                if (what[len] == c)
+                        return what + len;
+        }
+        return NULL;
+#endif
+}
+
diff --git a/core/subscription.c b/core/subscription.c
index 58126bd..3d18e3e 100644
--- a/core/subscription.c
+++ b/core/subscription.c
@@ -20,6 +20,17 @@
 
 extern struct uwsgi_server uwsgi;
 
+char *uwsgi_subscription_algo_name(void *ptr) {
+	struct uwsgi_string_list *usl = uwsgi.subscription_algos;
+	while(usl) {
+		if (usl->custom_ptr == ptr) {
+			return usl->value;
+		}
+		usl = usl->next;
+	}
+	return NULL;
+}
+
 #ifdef UWSGI_SSL
 static void uwsgi_subscription_sni_check(struct uwsgi_subscribe_slot *current_slot, struct uwsgi_subscribe_req *usr) {
 	if (usr->sni_key_len > 0 && usr->sni_crt_len > 0) {
@@ -72,6 +83,8 @@ int uwsgi_subscription_credentials_check(struct uwsgi_subscribe_slot *slot, stru
 }
 
 struct uwsgi_subscribe_slot *uwsgi_get_subscribe_slot(struct uwsgi_subscribe_slot **slot, char *key, uint16_t keylen) {
+	int retried = 0;
+retry:
 
 	if (keylen > 0xff)
 		return NULL;
@@ -125,136 +138,20 @@ struct uwsgi_subscribe_slot *uwsgi_get_subscribe_slot(struct uwsgi_subscribe_slo
 			break;
 	}
 
-	return NULL;
-}
-
-// least reference count
-static struct uwsgi_subscribe_node *uwsgi_subscription_algo_lrc(struct uwsgi_subscribe_slot *current_slot, struct uwsgi_subscribe_node *node) {
-	// if node is NULL we are in the second step (in lrc mode we do not use the first step)
-	if (node)
-		return NULL;
-
-	struct uwsgi_subscribe_node *choosen_node = NULL;
-	node = current_slot->nodes;
-	uint64_t min_rc = 0;
-	while (node) {
-		if (!node->death_mark) {
-			if (min_rc == 0 || node->reference < min_rc) {
-				min_rc = node->reference;
-				choosen_node = node;
-				if (min_rc == 0 && !(node->next && node->next->reference <= node->reference && node->next->last_requests <= node->last_requests))
-					break;
-			}
-		}
-		node = node->next;
-	}
-
-	if (choosen_node) {
-		choosen_node->reference++;
-	}
-
-	return choosen_node;
-}
-
-// weighted least reference count
-static struct uwsgi_subscribe_node *uwsgi_subscription_algo_wlrc(struct uwsgi_subscribe_slot *current_slot, struct uwsgi_subscribe_node *node) {
-	// if node is NULL we are in the second step (in wlrc mode we do not use the first step)
-	if (node)
-		return NULL;
-
-	struct uwsgi_subscribe_node *choosen_node = NULL;
-	node = current_slot->nodes;
-	double min_rc = 0;
-	while (node) {
-		if (!node->death_mark) {
-			// node->weight is always >= 1, we can safely use it as divider
-			double ref = (double) node->reference / (double) node->weight;
-			double next_node_ref = 0;
-			if (node->next)
-				next_node_ref = (double) node->next->reference / (double) node->next->weight;
-
-			if (min_rc == 0 || ref < min_rc) {
-				min_rc = ref;
-				choosen_node = node;
-				if (min_rc == 0 && !(node->next && next_node_ref <= ref && node->next->last_requests <= node->last_requests))
-					break;
-			}
-		}
-		node = node->next;
-	}
-
-	if (choosen_node) {
-		choosen_node->reference++;
-	}
-
-	return choosen_node;
-}
-
-// weighted round robin algo
-static struct uwsgi_subscribe_node *uwsgi_subscription_algo_wrr(struct uwsgi_subscribe_slot *current_slot, struct uwsgi_subscribe_node *node) {
-	// if node is NULL we are in the second step
-	if (node) {
-		if (node->death_mark == 0 && node->wrr > 0) {
-			node->wrr--;
-			node->reference++;
-			return node;
-		}
-		return NULL;
-	}
-
-	// no wrr > 0 node found, reset them
-	node = current_slot->nodes;
-	uint64_t min_weight = 0;
-	while (node) {
-		if (!node->death_mark) {
-			if (min_weight == 0 || node->weight < min_weight)
-				min_weight = node->weight;
+	// if we are here and in mountpoints mode, try the domain only variant
+	if (uwsgi.subscription_mountpoints && !retried) {
+		char *slash = memchr(key, '/', keylen);
+		if (slash) {
+			keylen = slash - key;
+			retried = 1;
+			goto retry;
 		}
-		node = node->next;
 	}
 
-	// now set wrr
-	node = current_slot->nodes;
-	struct uwsgi_subscribe_node *choosen_node = NULL;
-	while (node) {
-		if (!node->death_mark) {
-			node->wrr = node->weight / min_weight;
-			choosen_node = node;
-		}
-		node = node->next;
-	}
-	if (choosen_node) {
-		choosen_node->wrr--;
-		choosen_node->reference++;
-	}
-	return choosen_node;
-}
-
-void uwsgi_subscription_set_algo(char *algo) {
-
-	if (!algo)
-		goto wrr;
-
-	if (!strcmp(algo, "wrr")) {
-		uwsgi.subscription_algo = uwsgi_subscription_algo_wrr;
-		return;
-	}
-
-	if (!strcmp(algo, "lrc")) {
-		uwsgi.subscription_algo = uwsgi_subscription_algo_lrc;
-		return;
-	}
-
-	if (!strcmp(algo, "wlrc")) {
-		uwsgi.subscription_algo = uwsgi_subscription_algo_wlrc;
-		return;
-	}
-
-wrr:
-	uwsgi.subscription_algo = uwsgi_subscription_algo_wrr;
+	return NULL;
 }
 
-struct uwsgi_subscribe_node *uwsgi_get_subscribe_node(struct uwsgi_subscribe_slot **slot, char *key, uint16_t keylen) {
+struct uwsgi_subscribe_node *uwsgi_get_subscribe_node(struct uwsgi_subscribe_slot **slot, char *key, uint16_t keylen, struct uwsgi_subscription_client *client) {
 
 	if (keylen > 0xff)
 		return NULL;
@@ -287,14 +184,14 @@ struct uwsgi_subscribe_node *uwsgi_get_subscribe_node(struct uwsgi_subscribe_slo
 			continue;
 		}
 
-		struct uwsgi_subscribe_node *choosen_node = uwsgi.subscription_algo(current_slot, node);
+		struct uwsgi_subscribe_node *choosen_node = current_slot->algo(current_slot, node, client);
 		if (choosen_node)
 			return choosen_node;
 
 		node = node->next;
 	}
 
-	return uwsgi.subscription_algo(current_slot, node);
+	return current_slot->algo(current_slot, node, client);
 }
 
 struct uwsgi_subscribe_node *uwsgi_get_subscribe_node_by_name(struct uwsgi_subscribe_slot **slot, char *key, uint16_t keylen, char *val, uint16_t vallen) {
@@ -436,6 +333,10 @@ struct uwsgi_subscribe_node *uwsgi_add_subscribe_node(struct uwsgi_subscribe_slo
 				node->cores = usr->cores;
 				node->load = usr->load;
 				node->weight = usr->weight;
+				node->backup_level = usr->backup_level;
+				if (usr->proto_len > 0) {
+					node->proto = usr->proto[0];
+				}	
 				if (!node->weight)
 					node->weight = 1;
 				node->last_requests = 0;
@@ -468,6 +369,10 @@ struct uwsgi_subscribe_node *uwsgi_add_subscribe_node(struct uwsgi_subscribe_slo
 		node->cores = usr->cores;
 		node->load = usr->load;
 		node->weight = usr->weight;
+		node->backup_level = usr->backup_level;
+		if (usr->proto_len > 0) {
+			node->proto = usr->proto[0];
+		}
 		node->unix_check = usr->unix_check;
 		if (!node->weight)
 			node->weight = 1;
@@ -488,7 +393,7 @@ struct uwsgi_subscribe_node *uwsgi_add_subscribe_node(struct uwsgi_subscribe_slo
 		}
 		node->next = NULL;
 
-		uwsgi_log("[uwsgi-subscription for pid %d] %.*s => new node: %.*s\n", (int) uwsgi.mypid, usr->keylen, usr->key, usr->address_len, usr->address);
+		uwsgi_log("[uwsgi-subscription for pid %d] %.*s => new node: %.*s (weight: %d, backup: %d)\n", (int) uwsgi.mypid, usr->keylen, usr->key, usr->address_len, usr->address, usr->weight, usr->backup_level);
 		if (node->notify[0]) {
 			char buf[1024];
 			int ret = snprintf(buf, 1024, "[subscription ack] %.*s => new node: %.*s", usr->keylen, usr->key, usr->address_len, usr->address);
@@ -539,6 +444,10 @@ struct uwsgi_subscribe_node *uwsgi_add_subscribe_node(struct uwsgi_subscribe_slo
 		current_slot->nodes->cores = usr->cores;
 		current_slot->nodes->load = usr->load;
 		current_slot->nodes->weight = usr->weight;
+		current_slot->nodes->backup_level = usr->backup_level;
+		if (usr->proto_len > 0) {
+			current_slot->nodes->proto = usr->proto[0];
+		}
 		current_slot->nodes->unix_check = usr->unix_check;
 		if (!current_slot->nodes->weight)
 			current_slot->nodes->weight = 1;
@@ -570,13 +479,16 @@ struct uwsgi_subscribe_node *uwsgi_add_subscribe_node(struct uwsgi_subscribe_slo
 		current_slot->prev = old_slot;
 		current_slot->next = NULL;
 
+		current_slot->algo = usr->algo;
+		if (!current_slot->algo) current_slot->algo = uwsgi.subscription_algo;
+
 
 		if (!slot[hash_key] || current_slot->prev == NULL) {
 			slot[hash_key] = current_slot;
 		}
 
-		uwsgi_log("[uwsgi-subscription for pid %d] new pool: %.*s (hash key: %d)\n", (int) uwsgi.mypid, usr->keylen, usr->key, current_slot->hash);
-		uwsgi_log("[uwsgi-subscription for pid %d] %.*s => new node: %.*s\n", (int) uwsgi.mypid, usr->keylen, usr->key, usr->address_len, usr->address);
+		uwsgi_log("[uwsgi-subscription for pid %d] new pool: %.*s (hash key: %d, algo: %s)\n", (int) uwsgi.mypid, usr->keylen, usr->key, current_slot->hash, uwsgi_subscription_algo_name(current_slot->algo));
+		uwsgi_log("[uwsgi-subscription for pid %d] %.*s => new node: %.*s (weight: %d, backup: %d)\n", (int) uwsgi.mypid, usr->keylen, usr->key, usr->address_len, usr->address, usr->weight, usr->backup_level);
 
 		if (current_slot->nodes->notify[0]) {
 			char buf[1024];
@@ -669,6 +581,30 @@ static void send_subscription(int sfd, char *host, char *message, uint16_t messa
 		close(fd);
 }
 
+static int uwsgi_subscription_ub_fix(struct uwsgi_buffer *ub, uint8_t modifier1, uint8_t modifier2, uint8_t cmd, char *sign) {
+	#ifdef UWSGI_SSL
+        if (sign) {
+                if (uwsgi_buffer_append_keynum(ub, "unix", 4, (uwsgi_now() + (time_t) cmd)))
+                        return -1;
+
+                unsigned int signature_len = 0;
+                char *signature = uwsgi_rsa_sign(sign, ub->buf + 4, ub->pos - 4, &signature_len);
+                if (signature && signature_len > 0) {
+                        if (uwsgi_buffer_append_keyval(ub, "sign", 4, signature, signature_len)) {
+                                free(signature);
+				return -1;
+                        }
+                        free(signature);
+                }
+        }
+#endif
+
+        // add uwsgi header
+        if (uwsgi_buffer_set_uh(ub, 224, cmd)) return -1;
+
+	return 0;
+}
+
 static struct uwsgi_buffer *uwsgi_subscription_ub(char *key, size_t keysize, uint8_t modifier1, uint8_t modifier2, uint8_t cmd, char *socket_name, char *sign, char *sni_key, char *sni_crt, char *sni_ca) {
 	struct uwsgi_buffer *ub = uwsgi_buffer_new(4096);
 
@@ -720,26 +656,7 @@ static struct uwsgi_buffer *uwsgi_subscription_ub(char *key, size_t keysize, uin
 			goto end;
 	}
 
-#ifdef UWSGI_SSL
-	if (sign) {
-		if (uwsgi_buffer_append_keynum(ub, "unix", 4, (uwsgi_now() + (time_t) cmd)))
-			goto end;
-
-		unsigned int signature_len = 0;
-		char *signature = uwsgi_rsa_sign(sign, ub->buf + 4, ub->pos - 4, &signature_len);
-		if (signature && signature_len > 0) {
-			if (uwsgi_buffer_append_keyval(ub, "sign", 4, signature, signature_len)) {
-				free(signature);
-				goto end;
-			}
-			free(signature);
-		}
-	}
-#endif
-
-	// add uwsgi header
-	if (uwsgi_buffer_set_uh(ub, 224, cmd))
-		goto end;
+	if (uwsgi_subscription_ub_fix(ub, modifier1, modifier2, cmd, sign)) goto end;
 
 	return ub;
 
@@ -861,13 +778,6 @@ int uwsgi_no_subscriptions(struct uwsgi_subscribe_slot **slot) {
 	return 1;
 }
 
-struct uwsgi_subscribe_slot **uwsgi_subscription_init_ht() {
-	if (!uwsgi.subscription_algo) {
-		uwsgi_subscription_set_algo(NULL);
-	}
-	return uwsgi_calloc(sizeof(struct uwsgi_subscription_slot *) * UMAX16);
-}
-
 void uwsgi_subscribe(char *subscription, uint8_t cmd) {
 
 	size_t subfile_size;
@@ -1014,8 +924,27 @@ void uwsgi_subscribe2(char *arg, uint8_t cmd) {
 	char *s2_sni_key = NULL;
 	char *s2_sni_crt = NULL;
 	char *s2_sni_ca = NULL;
-
-	if (uwsgi_kvlist_parse(arg, strlen(arg), ',', '=', "server", &s2_server, "key", &s2_key, "socket", &s2_socket, "addr", &s2_addr, "weight", &s2_weight, "modifier1", &s2_modifier1, "modifier2", &s2_modifier2, "sign", &s2_sign, "check", &s2_check, "sni_key", &s2_sni_key, "sni_crt", &s2_sni_crt, "sni_ca", &s2_sni_ca, NULL)) {
+	char *s2_proto = NULL;
+	char *s2_algo = NULL;
+	char *s2_backup = NULL;
+
+	if (uwsgi_kvlist_parse(arg, strlen(arg), ',', '=',
+		"server", &s2_server,
+		"key", &s2_key,
+		"socket", &s2_socket,
+		"addr", &s2_addr,
+		"weight", &s2_weight,
+		"modifier1", &s2_modifier1,
+		"modifier2", &s2_modifier2,
+		"sign", &s2_sign,
+		"check", &s2_check,
+		"sni_key", &s2_sni_key,
+		"sni_crt", &s2_sni_crt,
+		"sni_ca", &s2_sni_ca,
+		"proto", &s2_proto,
+		"algo", &s2_algo,
+		"backup", &s2_backup,
+		NULL)) {
 		return;
 	}
 
@@ -1027,8 +956,15 @@ void uwsgi_subscribe2(char *arg, uint8_t cmd) {
 			goto end;
 	}
 
+	int weight = 1;
+	int backup = 0;
+	if (uwsgi.auto_weight) weight = uwsgi.numproc * uwsgi.cores;
 	if (s2_weight) {
-		uwsgi.weight = atoi(s2_weight);
+		weight = atoi(s2_weight);
+	}
+
+	if (s2_backup) {
+		backup = atoi(s2_backup);
 	}
 
 	if (s2_socket) {
@@ -1052,7 +988,74 @@ void uwsgi_subscribe2(char *arg, uint8_t cmd) {
 		modifier2 = atoi(s2_modifier2);
 	}
 
-	uwsgi_send_subscription(s2_server, s2_key, strlen(s2_key), modifier1, modifier2, cmd, s2_addr, s2_sign, s2_sni_key, s2_sni_crt, s2_sni_ca);
+	if (s2_addr == NULL) {
+		// no socket... no subscription
+		if (!uwsgi.sockets) goto end;
+		s2_addr = uwsgi_str(uwsgi.sockets->name);
+	}
+
+        struct uwsgi_buffer *ub = uwsgi_buffer_new(uwsgi.page_size);
+        if (!ub) goto end;
+	// leave space for the header
+	ub->pos = 4;
+
+	if (uwsgi_buffer_append_keyval(ub, "key", 3, s2_key, strlen(s2_key)))
+                goto end;
+        if (uwsgi_buffer_append_keyval(ub, "address", 7, s2_addr, strlen(s2_addr)))
+                goto end;
+        if (uwsgi_buffer_append_keynum(ub, "modifier1", 9, modifier1))
+                goto end;
+        if (uwsgi_buffer_append_keynum(ub, "modifier2", 9, modifier2))
+                goto end;
+        if (uwsgi_buffer_append_keynum(ub, "cores", 5, uwsgi.numproc * uwsgi.cores))
+                goto end;
+        if (uwsgi_buffer_append_keynum(ub, "load", 4, uwsgi.shared->load))
+                goto end;
+        if (uwsgi_buffer_append_keynum(ub, "weight", 6, weight))
+        	goto end;
+        if (uwsgi_buffer_append_keynum(ub, "backup", 6, backup))
+        	goto end;
+
+        if (s2_sni_key) {
+                if (uwsgi_buffer_append_keyval(ub, "sni_key", 7, s2_sni_key, strlen(s2_sni_key)))
+                        goto end;
+        }
+
+        if (s2_sni_crt) {
+                if (uwsgi_buffer_append_keyval(ub, "sni_crt", 7, s2_sni_crt, strlen(s2_sni_crt)))
+                        goto end;
+        }
+
+        if (s2_sni_ca) {
+                if (uwsgi_buffer_append_keyval(ub, "sni_ca", 6, s2_sni_ca, strlen(s2_sni_ca)))
+                        goto end;
+        }
+
+	if (s2_proto) {
+                if (uwsgi_buffer_append_keyval(ub, "proto", 5, s2_proto, strlen(s2_proto)))
+                        goto end;
+	}
+
+	if (s2_algo) {
+                if (uwsgi_buffer_append_keyval(ub, "algo", 4, s2_algo, strlen(s2_algo)))
+                        goto end;
+	}
+
+        if (uwsgi.subscription_notify_socket) {
+                if (uwsgi_buffer_append_keyval(ub, "notify", 6, uwsgi.subscription_notify_socket, strlen(uwsgi.subscription_notify_socket)))
+                        goto end;
+        }
+        else if (uwsgi.notify_socket_fd > -1 && uwsgi.notify_socket) {
+                if (uwsgi_buffer_append_keyval(ub, "notify", 6, uwsgi.notify_socket, strlen(uwsgi.notify_socket)))
+                        goto end;
+        }
+
+        if (uwsgi_subscription_ub_fix(ub, modifier1, modifier2, cmd, s2_sign)) goto end;
+
+        send_subscription(-1, s2_server, ub->buf, ub->pos);
+
+        uwsgi_buffer_destroy(ub);
+
 end:
 	if (s2_server)
 		free(s2_server);
@@ -1072,6 +1075,18 @@ end:
 		free(s2_sign);
 	if (s2_check)
 		free(s2_check);
+	if (s2_sni_crt)
+		free(s2_sni_crt);
+	if (s2_sni_key)
+		free(s2_sni_key);
+	if (s2_sni_ca)
+		free(s2_sni_ca);
+	if (s2_proto)
+		free(s2_proto);
+	if (s2_algo)
+		free(s2_algo);
+	if (s2_backup)
+		free(s2_backup);
 }
 
 void uwsgi_subscribe_all(uint8_t cmd, int verbose) {
@@ -1099,3 +1114,241 @@ void uwsgi_subscribe_all(uint8_t cmd, int verbose) {
 	}
 
 }
+
+// iphash
+static struct uwsgi_subscribe_node *uwsgi_subscription_algo_iphash(struct uwsgi_subscribe_slot *current_slot, struct uwsgi_subscribe_node *node, struct uwsgi_subscription_client *client) {
+        // if node is NULL we are in the second step (in lrc mode we do not use the first step)
+        if (node)
+                return NULL;
+
+	// iphash does not support requests without client data
+	if (!client) return NULL;
+	if (!client->sockaddr) return NULL;
+	uint64_t count = 0;
+	// first step is counting the number of nodes
+	node = current_slot->nodes;
+	while(node) {
+		if (!node->death_mark) count++;
+		node = node->next;
+	}
+	if (count == 0) return NULL;
+
+	uint64_t hash = 0;
+
+	//hash the ip
+	if (client->sockaddr->sa.sa_family == AF_INET) {
+		hash = client->sockaddr->sa_in.sin_addr.s_addr % count;
+	}
+#ifdef AF_INET6
+	else if (client->sockaddr->sa.sa_family == AF_INET6) {
+		hash = djb33x_hash((char *)client->sockaddr->sa_in6.sin6_addr.s6_addr, 16) % count;
+	}
+#endif
+		
+	// now re-iterate until count matches;
+	count = 0;
+        struct uwsgi_subscribe_node *choosen_node = NULL;
+        node = current_slot->nodes;
+        while (node) {
+                if (!node->death_mark) {
+			if (count == hash) {
+				choosen_node = node;
+				break;
+			}
+			count++;
+                }
+                node = node->next;
+        }
+
+        if (choosen_node) {
+                choosen_node->reference++;
+        }
+
+        return choosen_node;
+}
+
+// least reference count
+static struct uwsgi_subscribe_node *uwsgi_subscription_algo_lrc(struct uwsgi_subscribe_slot *current_slot, struct uwsgi_subscribe_node *node, struct uwsgi_subscription_client *client) {
+	uint64_t backup_level = 0;
+        uint64_t has_backup = 0;
+
+        // if node is NULL we are in the second step (in lrc mode we do not use the first step)
+        if (node)
+                return NULL;
+
+        struct uwsgi_subscribe_node *choosen_node = NULL;
+retry:
+        node = current_slot->nodes;
+        uint64_t min_rc = 0;
+        while (node) {
+                if (!node->death_mark) {
+			if (node->backup_level == backup_level) {
+                        	if (min_rc == 0 || node->reference < min_rc) {
+                                	min_rc = node->reference;
+                                	choosen_node = node;
+                                	if (min_rc == 0 && !(node->next && node->next->reference <= node->reference && node->next->last_requests <= node->last_requests))
+                                        	break;
+                        	}
+			}
+			else if (node->backup_level > backup_level && (!has_backup || has_backup > node->backup_level)) {
+                                has_backup = node->backup_level;
+                        }
+                }
+                node = node->next;
+        }
+
+        if (choosen_node) {
+                choosen_node->reference++;
+        }
+	else if (has_backup) {
+                backup_level = has_backup;
+                goto retry;
+        }
+
+        return choosen_node;
+}
+
+// weighted least reference count
+static struct uwsgi_subscribe_node *uwsgi_subscription_algo_wlrc(struct uwsgi_subscribe_slot *current_slot, struct uwsgi_subscribe_node *node, struct uwsgi_subscription_client *client) {
+	uint64_t backup_level = 0;
+        uint64_t has_backup = 0;
+
+        // if node is NULL we are in the second step (in wlrc mode we do not use the first step)
+        if (node)
+                return NULL;
+
+        struct uwsgi_subscribe_node *choosen_node = NULL;
+retry:
+        node = current_slot->nodes;
+	has_backup = 0;
+        double min_rc = 0;
+        while (node) {
+                if (!node->death_mark) {
+			if (node->backup_level == backup_level) {
+                        	// node->weight is always >= 1, we can safely use it as divider
+                        	double ref = (double) node->reference / (double) node->weight;
+                        	double next_node_ref = 0;
+                        	if (node->next)
+                                	next_node_ref = (double) node->next->reference / (double) node->next->weight;
+
+                        	if (min_rc == 0 || ref < min_rc) {
+                                	min_rc = ref;
+                                	choosen_node = node;
+                                	if (min_rc == 0 && !(node->next && next_node_ref <= ref && node->next->last_requests <= node->last_requests))
+                                	        break;
+                        	}
+			}
+			else if (node->backup_level > backup_level && (!has_backup || has_backup > node->backup_level)) {
+                                has_backup = node->backup_level;
+                        }
+                }
+                node = node->next;
+        }
+
+        if (choosen_node) {
+                choosen_node->reference++;
+        }
+	else if (has_backup) {
+                backup_level = has_backup;
+                goto retry;
+        }
+
+        return choosen_node;
+}
+
+// weighted round robin algo (with backup support)
+static struct uwsgi_subscribe_node *uwsgi_subscription_algo_wrr(struct uwsgi_subscribe_slot *current_slot, struct uwsgi_subscribe_node *node, struct uwsgi_subscription_client *client) {
+	uint64_t backup_level = 0;
+	uint64_t has_backup = 0;
+        // if node is NULL we are in the second step
+        if (node) {
+                if (node->death_mark == 0 && node->wrr > 0) {
+                        node->wrr--;
+                        node->reference++;
+                        return node;
+                }
+                return NULL;
+        }
+
+        // no wrr > 0 node found, reset them
+        node = current_slot->nodes;
+        uint64_t min_weight = 0;
+        while (node) {
+                if (!node->death_mark) {
+                        if (min_weight == 0 || node->weight < min_weight)
+                                min_weight = node->weight;
+                }
+                node = node->next;
+        }
+
+        // now set wrr
+retry:
+        node = current_slot->nodes;
+	has_backup = 0;
+        struct uwsgi_subscribe_node *choosen_node = NULL;
+        while (node) {
+                if (!node->death_mark) {
+			if (node->backup_level == backup_level) {
+                        	node->wrr = node->weight / min_weight;
+                        	choosen_node = node;
+                	}
+			else if (node->backup_level > backup_level && (!has_backup || has_backup > node->backup_level)) {
+				has_backup = node->backup_level;
+			}
+		}
+                node = node->next;
+        }
+        if (choosen_node) {
+                choosen_node->wrr--;
+                choosen_node->reference++;
+        }
+	else if (has_backup) {
+		backup_level = has_backup;
+		goto retry;
+	}
+        return choosen_node;
+}
+
+void uwsgi_subscription_init_algos() {
+
+	uwsgi_register_subscription_algo("wrr", uwsgi_subscription_algo_wrr);
+	uwsgi_register_subscription_algo("lrc", uwsgi_subscription_algo_lrc);
+	uwsgi_register_subscription_algo("wlrc", uwsgi_subscription_algo_wlrc);
+	uwsgi_register_subscription_algo("iphash", uwsgi_subscription_algo_iphash);
+}
+
+void uwsgi_subscription_set_algo(char *algo) {
+	if (!uwsgi.subscription_algos) {
+		uwsgi_subscription_init_algos();
+	}
+	if (!algo)
+                goto wrr;
+	uwsgi.subscription_algo = uwsgi_subscription_algo_get(algo, strlen(algo));
+	if (uwsgi.subscription_algo) return ;
+
+wrr:
+        uwsgi.subscription_algo = uwsgi_subscription_algo_wrr;
+}
+
+// we are lazy for subscription algos, we initialize them only if needed
+struct uwsgi_subscribe_slot **uwsgi_subscription_init_ht() {
+        if (!uwsgi.subscription_algo) {
+                uwsgi_subscription_set_algo(NULL);
+        }
+        return uwsgi_calloc(sizeof(struct uwsgi_subscription_slot *) * UMAX16);
+}
+
+struct uwsgi_subscribe_node *(*uwsgi_subscription_algo_get(char *name , size_t len))(struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *) {
+	struct uwsgi_string_list *usl = NULL;
+	uwsgi_foreach(usl, uwsgi.subscription_algos) {
+		if (!uwsgi_strncmp(usl->value, usl->len, name, len)) {
+			return (struct uwsgi_subscribe_node *(*)(struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *)) usl->custom_ptr;
+		}
+	}
+	return NULL;
+}
+
+void uwsgi_register_subscription_algo(char *name, struct uwsgi_subscribe_node *(*func)(struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *)) {
+	struct uwsgi_string_list *usl = uwsgi_string_new_list(&uwsgi.subscription_algos, name);	
+	usl->custom_ptr = func;
+}
diff --git a/core/utils.c b/core/utils.c
index c4a5a82..c19b7c5 100644
--- a/core/utils.c
+++ b/core/utils.c
@@ -42,9 +42,9 @@ int check_hex(char *str, int len) {
 }
 
 // increase worker harakiri
-void inc_harakiri(int sec) {
+void inc_harakiri(struct wsgi_request *wsgi_req, int sec) {
 	if (uwsgi.master_process) {
-		uwsgi.workers[uwsgi.mywid].harakiri += sec;
+		uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri += sec;
 	}
 	else {
 		alarm(uwsgi.harakiri_options.workers + sec);
@@ -52,12 +52,13 @@ void inc_harakiri(int sec) {
 }
 
 // set worker harakiri
-void set_harakiri(int sec) {
+void set_harakiri(struct wsgi_request *wsgi_req, int sec) {
+	if (!wsgi_req) return;
 	if (sec == 0) {
-		uwsgi.workers[uwsgi.mywid].harakiri = 0;
+		uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri = 0;
 	}
 	else {
-		uwsgi.workers[uwsgi.mywid].harakiri = uwsgi_now() + sec;
+		uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri = uwsgi_now() + sec;
 	}
 	if (!uwsgi.master_process) {
 		alarm(sec);
@@ -65,7 +66,7 @@ void set_harakiri(int sec) {
 }
 
 // set user harakiri
-void set_user_harakiri(int sec) {
+void set_user_harakiri(struct wsgi_request *wsgi_req, int sec) {
 	if (!uwsgi.master_process) {
 		uwsgi_log("!!! unable to set user harakiri without the master process !!!\n");
 		return;
@@ -79,8 +80,8 @@ void set_user_harakiri(int sec) {
 			struct uwsgi_spooler *uspool = uwsgi.i_am_a_spooler;
 			uspool->user_harakiri = 0;
 		}
-		else {
-			uwsgi.workers[uwsgi.mywid].user_harakiri = 0;
+		else if (wsgi_req) {
+			uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].user_harakiri = 0;
 		}
 	}
 	else {
@@ -91,8 +92,8 @@ void set_user_harakiri(int sec) {
 			struct uwsgi_spooler *uspool = uwsgi.i_am_a_spooler;
 			uspool->user_harakiri = uwsgi_now() + sec;
 		}
-		else {
-			uwsgi.workers[uwsgi.mywid].user_harakiri = uwsgi_now() + sec;
+		else if (wsgi_req) {
+			uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].user_harakiri = uwsgi_now() + sec;
 		}
 	}
 }
@@ -699,6 +700,22 @@ void uwsgi_as_root() {
 		}
 	}
 
+	uwsgi_foreach(usl, uwsgi.wait_for_fs) {
+		if (uwsgi_wait_for_fs(usl->value, 0)) exit(1);
+	}
+
+	uwsgi_foreach(usl, uwsgi.wait_for_file) {
+		if (uwsgi_wait_for_fs(usl->value, 1)) exit(1);
+	}
+
+	uwsgi_foreach(usl, uwsgi.wait_for_dir) {
+		if (uwsgi_wait_for_fs(usl->value, 2)) exit(1);
+	}
+
+	uwsgi_foreach(usl, uwsgi.wait_for_mountpoint) {
+		if (uwsgi_wait_for_mountpoint(usl->value)) exit(1);
+	}
+
 	uwsgi_hooks_run(uwsgi.hook_as_root, "as root", 1);
 
 	uwsgi_foreach(usl, uwsgi.mount_as_root) {
@@ -1019,8 +1036,14 @@ void uwsgi_destroy_request(struct wsgi_request *wsgi_req) {
                 pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &foo);
         }
 
-        memset(wsgi_req, 0, sizeof(struct wsgi_request));
+	// reset for avoiding following requests to fail on non-uwsgi protocols
+	// thanks Marko Tiikkaja for catching it
+	wsgi_req->uh->_pktsize = 0;
 
+	// some plugins expected async_id to be defined before setup
+        int tmp_id = wsgi_req->async_id;
+        memset(wsgi_req, 0, sizeof(struct wsgi_request));
+        wsgi_req->async_id = tmp_id;
 }
 
 // finalize/close/free a request
@@ -1099,13 +1122,13 @@ void uwsgi_close_request(struct wsgi_request *wsgi_req) {
 	}
 
 	// leave harakiri mode
-	if (uwsgi.workers[uwsgi.mywid].harakiri > 0) {
-		set_harakiri(0);
+	if (uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri > 0) {
+		set_harakiri(wsgi_req, 0);
 	}
 
 	// leave user harakiri mode
-	if (uwsgi.workers[uwsgi.mywid].user_harakiri > 0) {
-		set_user_harakiri(0);
+	if (uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].user_harakiri > 0) {
+		set_user_harakiri(wsgi_req, 0);
 	}
 
 	if (!wsgi_req->do_not_account) {
@@ -1163,15 +1186,15 @@ void uwsgi_close_request(struct wsgi_request *wsgi_req) {
 
 
 	// reset request
-	wsgi_req->uh->pktsize = 0;
+	wsgi_req->uh->_pktsize = 0;
 	tmp_id = wsgi_req->async_id;
 	memset(wsgi_req, 0, sizeof(struct wsgi_request));
+	// some plugins expected async_id to be defined before setup
 	wsgi_req->async_id = tmp_id;
-
 	// yes, this is pretty useless but we cannot ensure all of the plugin have the same behaviour
 	uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 0;
 
-	if (uwsgi.max_requests > 0 && uwsgi.workers[uwsgi.mywid].delta_requests >= uwsgi.max_requests
+	if (uwsgi.max_requests > 0 && uwsgi.workers[uwsgi.mywid].delta_requests >= (uwsgi.max_requests + ((uwsgi.mywid-1) * uwsgi.max_requests_delta))
 	    && (end_of_request - (uwsgi.workers[uwsgi.mywid].last_spawn * 1000000) >= uwsgi.min_worker_lifetime * 1000000)) {
 		goodbye_cruel_world();
 	}
@@ -1362,7 +1385,7 @@ int wsgi_req_async_recv(struct wsgi_request *wsgi_req) {
 
 	// enter harakiri mode
 	if (uwsgi.harakiri_options.workers > 0) {
-		set_harakiri(uwsgi.harakiri_options.workers);
+		set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
 	}
 
 	return 0;
@@ -1394,7 +1417,7 @@ int wsgi_req_recv(int queue, struct wsgi_request *wsgi_req) {
 
 	// enter harakiri mode
 	if (uwsgi.harakiri_options.workers > 0) {
-		set_harakiri(uwsgi.harakiri_options.workers);
+		set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
 	}
 
 #ifdef UWSGI_ROUTING
@@ -1515,7 +1538,7 @@ int wsgi_req_accept(int queue, struct wsgi_request *wsgi_req) {
 
 		thunder_unlock;
 
-		uwsgi_receive_signal(interesting_fd, "worker", uwsgi.mywid);
+		uwsgi_receive_signal(wsgi_req, interesting_fd, "worker", uwsgi.mywid);
 
 		if (uwsgi.threads > 1)
 			pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &ret);
@@ -1766,9 +1789,15 @@ void *uwsgi_malloc(size_t size) {
 }
 
 void *uwsgi_calloc(size_t size) {
-
-	char *ptr = uwsgi_malloc(size);
-	memset(ptr, 0, size);
+	// thanks Mathieu Dupuy for pointing out that calloc is faster
+	// than malloc + memset
+	char *ptr = calloc(1, size);
+	if (ptr == NULL) {
+		uwsgi_error("calloc()");
+		uwsgi_log("!!! tried memory allocation of %llu bytes !!!\n", (unsigned long long) size);
+		uwsgi_backtrace(uwsgi.backtrace_depth);
+		exit(1);
+	}
 	return ptr;
 }
 
@@ -1810,7 +1839,7 @@ char *magic_sub(char *buffer, size_t len, size_t * size, char *magic_table[]) {
 	for (i = 0; i < len; i++) {
 		if (buffer[i] == '%' && (i + 1) < len && magic_table[(unsigned char) buffer[i + 1]]) {
 			old_magic_buf = magic_buf;
-			magic_buf = uwsgi_concat3n(old_magic_buf, magic_len, magic_table[(unsigned char) buffer[i + 1]], strlen(magic_table[(unsigned char) buffer[i + 1]]), buffer + i + 2, len - i);
+			magic_buf = uwsgi_concat3n(old_magic_buf, magic_len, magic_table[(unsigned char) buffer[i + 1]], strlen(magic_table[(unsigned char) buffer[i + 1]]), buffer + i + 2, len - i - 2);
 			free(old_magic_buf);
 			magic_len += strlen(magic_table[(unsigned char) buffer[i + 1]]);
 			magic_ptr = magic_buf + magic_len;
@@ -1840,24 +1869,6 @@ void init_magic_table(char *magic_table[]) {
 	magic_table['('] = "%(";
 }
 
-char *uwsgi_get_last_char(char *what, char c) {
-	size_t len = strlen(what);
-	while (len--) {
-		if (what[len] == c)
-			return what + len;
-	}
-	return NULL;
-}
-
-char *uwsgi_get_last_charn(char *what, size_t len, char c) {
-	while (len--) {
-		if (what[len] == c)
-			return what + len;
-	}
-	return NULL;
-}
-
-
 char *uwsgi_num2str(int num) {
 
 	char *str = uwsgi_malloc(11);
@@ -1889,13 +1900,7 @@ int uwsgi_long2str2n(unsigned long long num, char *ptr, int size) {
 }
 
 int is_unix(char *socket_name, int len) {
-	int i;
-	for (i = 0; i < len; i++) {
-		if (socket_name[i] == ':')
-			return 0;
-	}
-
-	return 1;
+	return !memchr(socket_name, ':', len);
 }
 
 int is_a_number(char *what) {
@@ -2209,6 +2214,12 @@ void *uwsgi_malloc_shared(size_t size) {
 
 void *uwsgi_calloc_shared(size_t size) {
 	void *ptr = uwsgi_malloc_shared(size);
+	// NOTE by Mathieu Dupuy:
+	// OSes guarantee mmap MAP_ANON memory area to be zero-filled (see man pages)
+
+	// we should trust it, but history has taught us it is better to be paranoid.
+	// Lucky enough this function is called ony in startup phases, so performance
+	// tips/tricks are irrelevant (So, le'ts call memset...)
 	memset(ptr, 0, size);
 	return ptr;
 }
@@ -3102,6 +3113,8 @@ pid_t uwsgi_fork(char *name) {
 #if defined(__linux__) || defined(__sun__)
 		int i;
 		for (i = 0; i < uwsgi.argc; i++) {
+			// stop fixing original argv if the new one is bigger
+			if (!uwsgi.orig_argv[i]) break;
 			strcpy(uwsgi.orig_argv[i], uwsgi.argv[i]);
 		}
 #endif
@@ -4457,3 +4470,90 @@ mode_t uwsgi_mode_t(char *value, int *error) {
 	return mode;
 }
 
+int uwsgi_wait_for_mountpoint(char *mountpoint) {
+        if (!uwsgi.wait_for_fs_timeout) {
+                uwsgi.wait_for_fs_timeout = 60;
+        }
+        uwsgi_log("waiting for %s (max %d seconds) ...\n", mountpoint, uwsgi.wait_for_fs_timeout);
+        int counter = 0;
+        for (;;) {
+                if (counter > uwsgi.wait_for_fs_timeout) {
+                        uwsgi_log("%s unavailable after %d seconds\n", mountpoint, counter);
+                        return -1;
+                }
+		struct stat st0;
+		struct stat st1;
+		if (stat(mountpoint, &st0)) goto retry;
+		if (!S_ISDIR(st0.st_mode)) goto retry;
+		char *relative = uwsgi_concat2(mountpoint, "/../");
+		if (stat(relative, &st1)) {
+			free(relative);
+			goto retry;
+		}
+		free(relative);
+		// useless :P
+                if (!S_ISDIR(st1.st_mode)) goto retry;
+		if (st0.st_dev == st1.st_dev) goto retry;
+                uwsgi_log_verbose("%s mounted\n", mountpoint);
+                return 0;
+retry:
+                sleep(1);
+                counter++;
+        }
+}
+
+// type -> 1 file, 2 dir, 0 both
+int uwsgi_wait_for_fs(char *filename, int type) {
+	if (!uwsgi.wait_for_fs_timeout) {
+        	uwsgi.wait_for_fs_timeout = 60;
+        }
+        uwsgi_log("waiting for %s (max %d seconds) ...\n", filename, uwsgi.wait_for_fs_timeout);
+        int counter = 0;
+        for (;;) {
+        	if (counter > uwsgi.wait_for_fs_timeout) {
+                	uwsgi_log("%s unavailable after %d seconds\n", filename, counter);
+			return -1;
+                }
+		struct stat st;
+		if (stat(filename, &st)) goto retry;
+		if (type == 1 && !S_ISREG(st.st_mode)) goto retry;
+		if (type == 2 && !S_ISDIR(st.st_mode)) goto retry;
+                uwsgi_log_verbose("%s found\n", filename);
+		return 0;
+retry:
+                sleep(1);
+                counter++;
+	}
+}
+
+#ifndef _GNU_SOURCE
+int uwsgi_versionsort(const struct dirent **da, const struct dirent **db) {
+
+        const char *a = (*da)->d_name;
+        const char *b = (*db)->d_name;
+
+        long la, lb;
+        char *endptr;
+
+        // Check if a and b are valid numbers.
+        la = strtol(a, &endptr, 10);
+        if (strcmp(endptr, "\0") || endptr == a) {
+            a = NULL;
+        }
+
+        lb = strtol(b, &endptr, 10);
+        if (strcmp(endptr, "\0") || endptr == b) {
+            b = NULL;
+        }
+
+        if (a && b) {
+            return (la < lb ? -1 : la > lb);
+        } else if (a) {
+            return -1;
+        } else if (b) {
+            return 1;
+        } else {
+            return strcmp((*da)->d_name, (*db)->d_name);
+        }
+}
+#endif
diff --git a/core/uwsgi.c b/core/uwsgi.c
index d7d8e8e..56ce724 100644
--- a/core/uwsgi.c
+++ b/core/uwsgi.c
@@ -39,14 +39,16 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"socket", required_argument, 's', "bind to the specified UNIX/TCP socket using default protocol", uwsgi_opt_add_socket, NULL, 0},
 	{"uwsgi-socket", required_argument, 's', "bind to the specified UNIX/TCP socket using uwsgi protocol", uwsgi_opt_add_socket, "uwsgi", 0},
 #ifdef UWSGI_SSL
-	{"suwsgi-socket", required_argument, 's', "bind to the specified UNIX/TCP socket using uwsgi protocol over SSL", uwsgi_opt_add_ssl_socket, "suwsgi", 0},
-	{"ssl-socket", required_argument, 's', "bind to the specified UNIX/TCP socket using uwsgi protocol over SSL", uwsgi_opt_add_ssl_socket, "suwsgi", 0},
+	{"suwsgi-socket", required_argument, 0, "bind to the specified UNIX/TCP socket using uwsgi protocol over SSL", uwsgi_opt_add_ssl_socket, "suwsgi", 0},
+	{"ssl-socket", required_argument, 0, "bind to the specified UNIX/TCP socket using uwsgi protocol over SSL", uwsgi_opt_add_ssl_socket, "suwsgi", 0},
 #endif
 
 	{"http-socket", required_argument, 0, "bind to the specified UNIX/TCP socket using HTTP protocol", uwsgi_opt_add_socket, "http", 0},
 	{"http-socket-modifier1", required_argument, 0, "force the specified modifier1 when using HTTP protocol", uwsgi_opt_set_64bit, &uwsgi.http_modifier1, 0},
 	{"http-socket-modifier2", required_argument, 0, "force the specified modifier2 when using HTTP protocol", uwsgi_opt_set_64bit, &uwsgi.http_modifier2, 0},
 
+	{"http11-socket", required_argument, 0, "bind to the specified UNIX/TCP socket using HTTP 1.1 (Keep-Alive) protocol", uwsgi_opt_add_socket, "http11", 0},
+
 #ifdef UWSGI_SSL
 	{"https-socket", required_argument, 0, "bind to the specified UNIX/TCP socket using HTTPS protocol", uwsgi_opt_add_ssl_socket, "https", 0},
 	{"https-socket-modifier1", required_argument, 0, "force the specified modifier1 when using HTTPS protocol", uwsgi_opt_set_64bit, &uwsgi.https_modifier1, 0},
@@ -71,8 +73,8 @@ static struct uwsgi_option uwsgi_base_options[] = {
 
 	{"protocol", required_argument, 0, "force the specified protocol for default sockets", uwsgi_opt_set_str, &uwsgi.protocol, 0},
 	{"socket-protocol", required_argument, 0, "force the specified protocol for default sockets", uwsgi_opt_set_str, &uwsgi.protocol, 0},
-	{"shared-socket", required_argument, 0, "create a shared sacket for advanced jailing or ipc", uwsgi_opt_add_shared_socket, NULL, 0},
-	{"undeferred-shared-socket", required_argument, 0, "create a shared sacket for advanced jailing or ipc (undeferred mode)", uwsgi_opt_add_shared_socket, NULL, 0},
+	{"shared-socket", required_argument, 0, "create a shared socket for advanced jailing or ipc", uwsgi_opt_add_shared_socket, NULL, 0},
+	{"undeferred-shared-socket", required_argument, 0, "create a shared socket for advanced jailing or ipc (undeferred mode)", uwsgi_opt_add_shared_socket, NULL, 0},
 	{"processes", required_argument, 'p', "spawn the specified number of workers/processes", uwsgi_opt_set_int, &uwsgi.numproc, 0},
 	{"workers", required_argument, 'p', "spawn the specified number of workers/processes", uwsgi_opt_set_int, &uwsgi.numproc, 0},
 	{"thunder-lock", no_argument, 0, "serialize accept() usage (if possible)", uwsgi_opt_true, &uwsgi.use_thunder_lock, 0},
@@ -120,6 +122,9 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"if-reload", no_argument, 0, "(opt logic) check for reload", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_reload, UWSGI_OPT_IMMEDIATE},
 	{"if-not-reload", no_argument, 0, "(opt logic) check for reload", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_reload, UWSGI_OPT_IMMEDIATE},
 
+	{"if-hostname", required_argument, 0, "(opt logic) check for hostname", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_hostname, UWSGI_OPT_IMMEDIATE},
+	{"if-not-hostname", required_argument, 0, "(opt logic) check for hostname", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_hostname, UWSGI_OPT_IMMEDIATE},
+
 	{"if-exists", required_argument, 0, "(opt logic) check for file/directory existance", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_exists, UWSGI_OPT_IMMEDIATE},
 	{"if-not-exists", required_argument, 0, "(opt logic) check for file/directory existance", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_not_exists, UWSGI_OPT_IMMEDIATE},
 	{"ifexists", required_argument, 0, "(opt logic) check for file/directory existance", uwsgi_opt_logic, (void *) uwsgi_logic_opt_if_exists, UWSGI_OPT_IMMEDIATE},
@@ -169,7 +174,7 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"listen", required_argument, 'l', "set the socket listen queue size", uwsgi_opt_set_int, &uwsgi.listen_queue, 0},
 	{"max-vars", required_argument, 'v', "set the amount of internal iovec/vars structures", uwsgi_opt_max_vars, NULL, 0},
 	{"max-apps", required_argument, 0, "set the maximum number of per-worker applications", uwsgi_opt_set_int, &uwsgi.max_apps, 0},
-	{"buffer-size", required_argument, 'b', "set internal buffer size", uwsgi_opt_set_16bit, &uwsgi.buffer_size, 0},
+	{"buffer-size", required_argument, 'b', "set internal buffer size", uwsgi_opt_set_64bit, &uwsgi.buffer_size, 0},
 	{"memory-report", no_argument, 'm', "enable memory report", uwsgi_opt_true, &uwsgi.logging_options.memory_report, 0},
 	{"profiler", required_argument, 0, "enable the specified profiler", uwsgi_opt_set_str, &uwsgi.profiler, 0},
 	{"cgi-mode", no_argument, 'c', "force CGI-mode for plugins supporting it", uwsgi_opt_true, &uwsgi.cgi_mode, 0},
@@ -225,11 +230,19 @@ static struct uwsgi_option uwsgi_base_options[] = {
 #if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL)
 	{"emperor-use-clone", required_argument, 0, "use clone() instead of fork() passing the specified unshare() flags", uwsgi_opt_set_unshare, &uwsgi.emperor_clone, 0},
 #endif
+	{"emperor-use-fork-server", required_argument, 0, "connect to the specified fork server instead of using plain fork() for new vassals", uwsgi_opt_set_str, &uwsgi.emperor_use_fork_server, 0},
+	{"vassal-fork-base", required_argument, 0, "use plain fork() for the specified vassal (instead of a fork-server)", uwsgi_opt_add_string_list, &uwsgi.vassal_fork_base, 0},
+	{"emperor-subreaper", no_argument, 0, "force the Emperor to be a sub-reaper (if supported)", uwsgi_opt_true, &uwsgi.emperor_subreaper, 0},
 #ifdef UWSGI_CAP
 	{"emperor-cap", required_argument, 0, "set vassals capability", uwsgi_opt_set_emperor_cap, NULL, 0},
 	{"vassals-cap", required_argument, 0, "set vassals capability", uwsgi_opt_set_emperor_cap, NULL, 0},
 	{"vassal-cap", required_argument, 0, "set vassals capability", uwsgi_opt_set_emperor_cap, NULL, 0},
 #endif
+	{"emperor-collect-attribute", required_argument, 0, "collect the specified vassal attribute from imperial monitors", uwsgi_opt_add_string_list, &uwsgi.emperor_collect_attributes, 0},
+	{"emperor-collect-attr", required_argument, 0, "collect the specified vassal attribute from imperial monitors", uwsgi_opt_add_string_list, &uwsgi.emperor_collect_attributes, 0},
+	{"emperor-fork-server-attr", required_argument, 0, "set teh vassal's attribute to get when checking for fork-server", uwsgi_opt_set_str, &uwsgi.emperor_fork_server_attr, 0},
+	{"emperor-wrapper-attr", required_argument, 0, "set the vassal's attribute to get when checking for fork-wrapper", uwsgi_opt_set_str, &uwsgi.emperor_wrapper_attr, 0},
+	{"emperor-chdir-attr", required_argument, 0, "set the vassal's attribute to get when checking for chdir", uwsgi_opt_set_str, &uwsgi.emperor_chdir_attr, 0},
 	{"imperial-monitor-list", no_argument, 0, "list enabled imperial monitors", uwsgi_opt_true, &uwsgi.imperial_monitor_list, 0},
 	{"imperial-monitors-list", no_argument, 0, "list enabled imperial monitors", uwsgi_opt_true, &uwsgi.imperial_monitor_list, 0},
 	{"vassals-inherit", required_argument, 0, "add config templates to vassals config (uses --inherit)", uwsgi_opt_add_string_list, &uwsgi.vassals_templates, 0},
@@ -238,12 +251,15 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"vassals-include-before", required_argument, 0, "include config templates to vassals config (uses --include instead of --inherit, parses before the vassal file)", uwsgi_opt_add_string_list, &uwsgi.vassals_includes_before, 0},
 	{"vassals-start-hook", required_argument, 0, "run the specified command before each vassal starts", uwsgi_opt_set_str, &uwsgi.vassals_start_hook, 0},
 	{"vassals-stop-hook", required_argument, 0, "run the specified command after vassal's death", uwsgi_opt_set_str, &uwsgi.vassals_stop_hook, 0},
+	{"vassal-sos", required_argument, 0, "ask emperor for reinforcement when overloaded", uwsgi_opt_set_int, &uwsgi.vassal_sos, 0},
 	{"vassal-sos-backlog", required_argument, 0, "ask emperor for sos if backlog queue has more items than the value specified", uwsgi_opt_set_int, &uwsgi.vassal_sos_backlog, 0},
 	{"vassals-set", required_argument, 0, "automatically set the specified option (via --set) for every vassal", uwsgi_opt_add_string_list, &uwsgi.vassals_set, 0},
 	{"vassal-set", required_argument, 0, "automatically set the specified option (via --set) for every vassal", uwsgi_opt_add_string_list, &uwsgi.vassals_set, 0},
 
 	{"heartbeat", required_argument, 0, "announce healthiness to the emperor", uwsgi_opt_set_int, &uwsgi.heartbeat, 0},
 
+	{"zeus", required_argument, 0, "enable Zeus mode", uwsgi_opt_set_str, &uwsgi.zeus, 0},
+
 	{"reload-mercy", required_argument, 0, "set the maximum time (in seconds) we wait for workers and other processes to die during reload/shutdown", uwsgi_opt_set_int, &uwsgi.reload_mercy, 0},
 	{"worker-reload-mercy", required_argument, 0, "set the maximum time (in seconds) a worker can take to reload/shutdown (default is 60)", uwsgi_opt_set_int, &uwsgi.worker_reload_mercy, 0},
 	{"mule-reload-mercy", required_argument, 0, "set the maximum time (in seconds) a mule can take to reload/shutdown (default is 60)", uwsgi_opt_set_int, &uwsgi.mule_reload_mercy, 0},
@@ -258,6 +274,7 @@ static struct uwsgi_option uwsgi_base_options[] = {
 
 	{"reaper", no_argument, 'r', "call waitpid(-1,...) after each request to get rid of zombies", uwsgi_opt_true, &uwsgi.reaper, 0},
 	{"max-requests", required_argument, 'R', "reload workers after the specified amount of managed requests", uwsgi_opt_set_64bit, &uwsgi.max_requests, 0},
+	{"max-requests-delta", required_argument, 0, "add (worker_id * delta) to the max_requests value of each worker", uwsgi_opt_set_64bit, &uwsgi.max_requests_delta, 0},
 	{"min-worker-lifetime", required_argument, 0, "number of seconds worker must run before being reloaded (default is 60)", uwsgi_opt_set_64bit, &uwsgi.min_worker_lifetime, 0},
 	{"max-worker-lifetime", required_argument, 0, "reload workers after the specified amount of seconds (default is disabled)", uwsgi_opt_set_64bit, &uwsgi.max_worker_lifetime, 0},
 
@@ -359,6 +376,8 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"setns-skip", required_argument, 0, "skip the specified entry when sending setns file descriptors", uwsgi_opt_add_string_list, &uwsgi.setns_socket_skip, 0},
 	{"setns", required_argument, 0, "join a namespace created by an external uWSGI instance", uwsgi_opt_set_str, &uwsgi.setns, 0},
 	{"setns-preopen", no_argument, 0, "open /proc/self/ns as soon as possible and cache fds", uwsgi_opt_true, &uwsgi.setns_preopen, 0},
+	{"fork-socket", required_argument, 0, "suspend the execution after early initialization and fork() at every unix socket connection", uwsgi_opt_set_str, &uwsgi.fork_socket, 0},
+	{"fork-server", required_argument, 0, "suspend the execution after early initialization and fork() at every unix socket connection", uwsgi_opt_set_str, &uwsgi.fork_socket, 0},
 #endif
 	{"jailed", no_argument, 0, "mark the instance as jailed (force the execution of post_jail hooks)", uwsgi_opt_true, &uwsgi.jailed, 0},
 #if defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)
@@ -406,6 +425,14 @@ static struct uwsgi_option uwsgi_base_options[] = {
         {"hook-as-vassal", required_argument, 0, "run the specified hook before exec()ing the vassal", uwsgi_opt_add_string_list, &uwsgi.hook_as_vassal, 0},
         {"hook-as-emperor", required_argument, 0, "run the specified hook in the emperor after the vassal has been started", uwsgi_opt_add_string_list, &uwsgi.hook_as_emperor, 0},
 
+        {"hook-as-on-demand-vassal", required_argument, 0, "run the specified hook whenever a vassal enters on-demand mode", uwsgi_opt_add_string_list, &uwsgi.hook_as_on_demand_vassal, 0},
+	{"hook-as-on-config-vassal", required_argument, 0, "run the specified hook whenever the emperor detects a config change for an on-demand vassal", uwsgi_opt_add_string_list, &uwsgi.hook_as_on_config_vassal, 0},
+
+        {"hook-as-emperor-before-vassal", required_argument, 0, "run the specified hook before the new vassal is spawned", uwsgi_opt_add_string_list, &uwsgi.hook_as_emperor_before_vassal, 0},
+        {"hook-as-vassal-before-drop", required_argument, 0, "run the specified hook into vassal, before dropping its privileges", uwsgi_opt_add_string_list, &uwsgi.hook_as_vassal_before_drop, 0},
+
+        {"hook-as-emperor-setns", required_argument, 0, "run the specified hook in the emperor entering vassal namespace", uwsgi_opt_add_string_list, &uwsgi.hook_as_emperor_setns, 0},
+
         {"hook-as-mule", required_argument, 0, "run the specified hook in each mule", uwsgi_opt_add_string_list, &uwsgi.hook_as_mule, 0},
 
         {"hook-as-gateway", required_argument, 0, "run the specified hook in each gateway", uwsgi_opt_add_string_list, &uwsgi.hook_as_gateway, 0},
@@ -456,6 +483,12 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"wait-iface", required_argument, 0, "wait for the specified network interface to come up before running root hooks", uwsgi_opt_add_string_list, &uwsgi.wait_for_interface, 0},
 	{"wait-iface-timeout", required_argument, 0, "set the timeout for wait-for-interface", uwsgi_opt_set_int, &uwsgi.wait_for_interface_timeout, 0},
 
+	{"wait-for-fs", required_argument, 0, "wait for the specified filesystem item to appear before running root hooks", uwsgi_opt_add_string_list, &uwsgi.wait_for_fs, 0},
+	{"wait-for-file", required_argument, 0, "wait for the specified file to appear before running root hooks", uwsgi_opt_add_string_list, &uwsgi.wait_for_fs, 0},
+	{"wait-for-dir", required_argument, 0, "wait for the specified directory to appear before running root hooks", uwsgi_opt_add_string_list, &uwsgi.wait_for_fs, 0},
+	{"wait-for-mountpoint", required_argument, 0, "wait for the specified mountpoint to appear before running root hooks", uwsgi_opt_add_string_list, &uwsgi.wait_for_mountpoint, 0},
+	{"wait-for-fs-timeout", required_argument, 0, "set the timeout for wait-for-fs/file/dir", uwsgi_opt_set_int, &uwsgi.wait_for_fs_timeout, 0},
+
 	{"call-asap", required_argument, 0, "call the specified function as soon as possible", uwsgi_opt_add_string_list, &uwsgi.call_asap, 0},
 	{"call-pre-jail", required_argument, 0, "call the specified function before jailing", uwsgi_opt_add_string_list, &uwsgi.call_pre_jail, 0},
 	{"call-post-jail", required_argument, 0, "call the specified function after jailing", uwsgi_opt_add_string_list, &uwsgi.call_post_jail, 0},
@@ -585,6 +618,8 @@ static struct uwsgi_option uwsgi_base_options[] = {
 
 	{"notify-socket", required_argument, 0, "enable the notification socket", uwsgi_opt_set_str, &uwsgi.notify_socket, UWSGI_OPT_MASTER},
 	{"subscription-notify-socket", required_argument, 0, "set the notification socket for subscriptions", uwsgi_opt_set_str, &uwsgi.subscription_notify_socket, UWSGI_OPT_MASTER},
+	{"subscription-mountpoints", no_argument, 0, "enable mountpoints support for subscription system", uwsgi_opt_true, &uwsgi.subscription_mountpoints, UWSGI_OPT_MASTER},
+	{"subscription-mountpoint", no_argument, 0, "enable mountpoints support for subscription system", uwsgi_opt_true, &uwsgi.subscription_mountpoints, UWSGI_OPT_MASTER},
 
 #ifdef UWSGI_SSL
 	{"legion", required_argument, 0, "became a member of a legion", uwsgi_opt_legion, NULL, UWSGI_OPT_MASTER},
@@ -646,6 +681,7 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"privileged-binary-patch-arg", required_argument, 0, "patch the uwsgi binary with a new command and arguments (before privileges drop)", uwsgi_opt_set_str, &uwsgi.privileged_binary_patch_arg, 0},
 	{"unprivileged-binary-patch-arg", required_argument, 0, "patch the uwsgi binary with a new command and arguments (after privileges drop)", uwsgi_opt_set_str, &uwsgi.unprivileged_binary_patch_arg, 0},
 	{"async", required_argument, 0, "enable async mode with specified cores", uwsgi_opt_set_int, &uwsgi.async, 0},
+	{"disable-async-warn-on-queue-full", no_argument, 0, "Disable printing 'async queue is full' warning messages.", uwsgi_opt_false, &uwsgi.async_warn_if_queue_full, 0},
 	{"max-fd", required_argument, 0, "set maximum number of file descriptors (requires root privileges)", uwsgi_opt_set_int, &uwsgi.requested_max_fd, 0},
 	{"logto", required_argument, 0, "set logfile/udp address", uwsgi_opt_set_str, &uwsgi.logfile, 0},
 	{"logto2", required_argument, 0, "log to specified file or udp address after privileges drop", uwsgi_opt_set_str, &uwsgi.logto2, 0},
@@ -899,6 +935,7 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"close-on-exec2", no_argument, 0, "set close-on-exec on server sockets (could be required for spawning processes in requests)", uwsgi_opt_true, &uwsgi.close_on_exec2, 0},
 	{"mode", required_argument, 0, "set uWSGI custom mode", uwsgi_opt_set_str, &uwsgi.mode, 0},
 	{"env", required_argument, 0, "set environment variable", uwsgi_opt_set_env, NULL, 0},
+	{"ienv", required_argument, 0, "set environment variable (IMMEDIATE version)", uwsgi_opt_set_env, NULL, UWSGI_OPT_IMMEDIATE},
 	{"envdir", required_argument, 0, "load a daemontools compatible envdir", uwsgi_opt_add_string_list, &uwsgi.envdirs, 0},
 	{"early-envdir", required_argument, 0, "load a daemontools compatible envdir ASAP", uwsgi_opt_envdir, NULL, UWSGI_OPT_IMMEDIATE},
 	{"unenv", required_argument, 0, "unset environment variable", uwsgi_opt_unset_env, NULL, 0},
@@ -1199,7 +1236,7 @@ void gracefully_kill(int signum) {
 	}
 
 	// still not found a way to gracefully reload in async mode
-	if (uwsgi.async > 1) {
+	if (uwsgi.async > 0) {
 		exit(UWSGI_RELOAD_CODE);
 	}
 
@@ -1445,7 +1482,7 @@ void what_i_am_doing() {
 #else
 				ctime_r((const time_t *) &wsgi_req->start_of_request_in_sec, ctime_storage);
 #endif
-				if (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].harakiri < uwsgi_now()) {
+				if (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri < uwsgi_now()) {
 					uwsgi_log("HARAKIRI: --- uWSGI worker %d core %d (pid: %d) WAS managing request %.*s since %.*s ---\n", (int) uwsgi.mywid, i, (int) uwsgi.mypid, wsgi_req->uri_len, wsgi_req->uri, 24, ctime_storage);
 				}
 				else {
@@ -1462,14 +1499,14 @@ void what_i_am_doing() {
 #else
 			ctime_r((const time_t *) &wsgi_req->start_of_request_in_sec, ctime_storage);
 #endif
-			if (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].harakiri < uwsgi_now()) {
+			if (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri < uwsgi_now()) {
 				uwsgi_log("HARAKIRI: --- uWSGI worker %d (pid: %d) WAS managing request %.*s since %.*s ---\n", (int) uwsgi.mywid, (int) uwsgi.mypid, wsgi_req->uri_len, wsgi_req->uri, 24, ctime_storage);
 			}
 			else {
 				uwsgi_log("SIGUSR2: --- uWSGI worker %d (pid: %d) is managing request %.*s since %.*s ---\n", (int) uwsgi.mywid, (int) uwsgi.mypid, wsgi_req->uri_len, wsgi_req->uri, 24, ctime_storage);
 			}
 		}
-		else if (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].harakiri < uwsgi_now() && uwsgi.workers[uwsgi.mywid].sig) {
+		else if (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri < uwsgi_now() && uwsgi.workers[uwsgi.mywid].sig) {
 			uwsgi_log("HARAKIRI: --- uWSGI worker %d (pid: %d) WAS handling signal %d ---\n", (int) uwsgi.mywid, (int) uwsgi.mypid, uwsgi.workers[uwsgi.mywid].signum);
 		}
 	}
@@ -1530,8 +1567,10 @@ static void vacuum(void) {
 	struct uwsgi_socket *uwsgi_sock = uwsgi.sockets;
 
 	if (uwsgi.restore_tc) {
-		if (tcsetattr(0, TCSANOW, &uwsgi.termios)) {
-			uwsgi_error("tcsetattr()");
+		if (getpid() == masterpid) {
+			if (tcsetattr(0, TCSANOW, &uwsgi.termios)) {
+				uwsgi_error("vacuum()/tcsetattr()");
+			}
 		}
 	}
 
@@ -1580,6 +1619,17 @@ static void vacuum(void) {
 next:
 				uwsgi_sock = uwsgi_sock->next;
 			}
+			if (uwsgi.stats) {
+				// is a unix socket ?
+				if (!strchr(uwsgi.stats, ':') && uwsgi.stats[0] != '@') {
+					if (unlink(uwsgi.stats)) {
+                                                uwsgi_error("unlink()");
+                                        }
+                                        else {
+                                                uwsgi_log("VACUUM: unix socket %s (stats) removed.\n", uwsgi.stats);
+                                        }
+				}
+			}
 		}
 	}
 }
@@ -1961,6 +2011,7 @@ static char *uwsgi_at_file_read(char *filename) {
 }
 
 void uwsgi_setup(int argc, char *argv[], char *envp[]) {
+
 #ifdef UWSGI_AS_SHARED_LIBRARY
 #ifdef __APPLE__
 	char ***envPtr = _NSGetEnviron();
@@ -2141,6 +2192,8 @@ void uwsgi_setup(int argc, char *argv[], char *envp[]) {
 	struct group *gr = getgrgid(getgid());
 	uwsgi.magic_table['G'] = gr ? gr->gr_name : uwsgi.magic_table['g'];
 
+configure:
+
 	// you can embed a ini file in the uWSGi binary with default options
 #ifdef UWSGI_EMBED_CONFIG
 	uwsgi_ini_config("", uwsgi.magic_table);
@@ -2165,6 +2218,14 @@ void uwsgi_setup(int argc, char *argv[], char *envp[]) {
 	// ok, the options dictionary is available, lets manage it
 	uwsgi_configure();
 
+	// stop the execution until a connection arrives on the fork socket
+	if (uwsgi.fork_socket) {
+		uwsgi_log_verbose("waiting for fork-socket connections...\n");
+		uwsgi_fork_server(uwsgi.fork_socket);
+		// if we are here a new process has been spawned
+		goto configure;
+	}
+
 	// fixup cwd
 	if (uwsgi.force_cwd) uwsgi.cwd = uwsgi.force_cwd;
 
@@ -2518,6 +2579,7 @@ int uwsgi_start(void *v_argv) {
 	}
 
 	if (uwsgi.chdir) {
+		uwsgi_log("chdir() to %s\n", uwsgi.chdir);
 		if (chdir(uwsgi.chdir)) {
 			uwsgi_error("chdir()");
 			exit(1);
@@ -2629,7 +2691,7 @@ int uwsgi_start(void *v_argv) {
 		}
 	}
 
-	if (uwsgi.async > 1) {
+	if (uwsgi.async > 0) {
 		if ((unsigned long) uwsgi.max_fd < (unsigned long) uwsgi.async) {
 			uwsgi_log_initial("- your current max open files limit is %lu, this is lower than requested async cores !!! -\n", (unsigned long) uwsgi.max_fd);
 			uwsgi.rl.rlim_cur = uwsgi.async;
@@ -2883,8 +2945,23 @@ unsafe:
 		uwsgi_log("your server socket listen backlog is limited to %d connections\n", uwsgi.listen_queue);
 #endif
 
+
 	uwsgi_log("your mercy for graceful operations on workers is %d seconds\n", uwsgi.worker_reload_mercy);
 
+	uwsgi_log("your request buffer size is %llu bytes\n", (unsigned long long) uwsgi.buffer_size);
+	if (!uwsgi.__buffer_size) {
+		if (uwsgi.buffer_size > 0xffff) {
+			uwsgi_log("your request buffer size for old plugins has been limited to 64k\n");
+			uwsgi.__buffer_size = 0xffff;
+		}
+		else {
+			uwsgi.__buffer_size = uwsgi.buffer_size;
+		}
+	}
+	else {
+		uwsgi_log("your request buffer size for old plugins is %u bytes\n", uwsgi.__buffer_size);
+	}
+
 	if (uwsgi.crons) {
 		struct uwsgi_cron *ucron = uwsgi.crons;
 		while (ucron) {
@@ -2937,7 +3014,7 @@ unsafe:
 			uwsgi_log("*** Operational MODE: threaded ***\n");
 		}
 	}
-	else if (uwsgi.async > 1) {
+	else if (uwsgi.async > 0) {
 		if (uwsgi.numproc > 1) {
 			uwsgi_log("*** Operational MODE: preforking+async ***\n");
 		}
@@ -3305,7 +3382,7 @@ void uwsgi_worker_run() {
 	// some apps could be mounted only on specific workers
 	uwsgi_init_worker_mount_apps();
 
-	if (uwsgi.async > 1) {
+	if (uwsgi.async > 0) {
 		// a stack of unused cores
         	uwsgi.async_queue_unused = uwsgi_malloc(sizeof(struct wsgi_request *) * uwsgi.async);
 
@@ -3342,6 +3419,7 @@ void uwsgi_worker_run() {
 	}
 
 	if (uwsgi.chdir2) {
+		uwsgi_log("chdir() to %s\n", uwsgi.chdir2);
 		if (chdir(uwsgi.chdir2)) {
 			uwsgi_error("chdir()");
 			exit(1);
@@ -3415,7 +3493,10 @@ void uwsgi_ignition() {
         if (uwsgi.has_emperor && uwsgi.mywid == 1) {
                 char byte = 5;
                 if (write(uwsgi.emperor_fd, &byte, 1) != 1) {
-                        uwsgi_error("write()");
+                        uwsgi_error("emperor-i-am-ready-to-accept/write()");
+			uwsgi_log_verbose("lost communication with the Emperor, goodbye...\n");
+			gracefully_kill_them_all(0);
+			exit(1);
                 }
         }
 
@@ -3445,7 +3526,7 @@ void uwsgi_ignition() {
 		uwsgi_log("your loop engine died. R.I.P.\n");
 	}
 	else {
-		if (uwsgi.async < 2) {
+		if (uwsgi.async < 1) {
 			simple_loop();
 		}
 		else {
@@ -3783,7 +3864,8 @@ void uwsgi_opt_false(char *opt, char *value, void *key) {
 }
 
 void uwsgi_opt_set_immediate_gid(char *opt, char *value, void *none) {
-        gid_t gid = atoi(value);
+        gid_t gid = 0;
+	if (is_a_number(value)) gid = atoi(value);
 	if (gid == 0) {
 		struct group *ugroup = getgrnam(value);
                 if (ugroup)
@@ -3812,7 +3894,8 @@ void uwsgi_opt_set_immediate_gid(char *opt, char *value, void *none) {
 
 
 void uwsgi_opt_set_immediate_uid(char *opt, char *value, void *none) {
-	uid_t uid = atoi(value);
+	uid_t uid = 0;
+	if (is_a_number(value)) uid = atoi(value);
 	if (uid == 0) {
 		struct passwd *upasswd = getpwnam(value);
                 if (upasswd)
@@ -3859,7 +3942,8 @@ void uwsgi_opt_set_int(char *opt, char *value, void *key) {
 }
 
 void uwsgi_opt_uid(char *opt, char *value, void *key) {
-	uid_t uid = atoi(value);
+	uid_t uid = 0;
+	if (is_a_number(value)) uid = atoi(value);
 	if (!uid) {
 		struct passwd *p = getpwnam(value);
 		if (p) {
@@ -3877,7 +3961,8 @@ void uwsgi_opt_uid(char *opt, char *value, void *key) {
 }
 
 void uwsgi_opt_gid(char *opt, char *value, void *key) {
-        gid_t gid = atoi(value);
+        gid_t gid = 0;
+	if (is_a_number(value)) gid = atoi(value);
         if (!gid) {
                 struct group *g = getgrnam(value);
                 if (g) {
@@ -4178,15 +4263,13 @@ void uwsgi_opt_print(char *opt, char *value, void *str) {
 }
 
 void uwsgi_opt_set_uid(char *opt, char *value, void *none) {
-
-	uwsgi.uid = atoi(value);
+	if (is_a_number(value)) uwsgi.uid = atoi(value);
 	if (!uwsgi.uid)
 		uwsgi.uidname = value;
 }
 
 void uwsgi_opt_set_gid(char *opt, char *value, void *none) {
-
-	uwsgi.gid = atoi(value);
+	if (is_a_number(value)) uwsgi.gid = atoi(value);
 	if (!uwsgi.gid)
 		uwsgi.gidname = value;
 }
diff --git a/core/webdav.c b/core/webdav.c
new file mode 100644
index 0000000..9f78cda
--- /dev/null
+++ b/core/webdav.c
@@ -0,0 +1,110 @@
+#include <uwsgi.h>
+
+extern struct uwsgi_server uwsgi;
+
+/*
+
+The following functions are useful to implement simil-webdav support in plugins.
+
+Most of them are not fully webdav compliant, but will work on the vast majority of clients.
+
+*/
+
+// a multi-status response (207) will return an xml with a list
+// of <D:response> stanzas
+
+struct uwsgi_buffer *uwsgi_webdav_multistatus_new() {
+	struct uwsgi_buffer *ub = uwsgi_buffer_new(uwsgi.page_size);
+	if (uwsgi_buffer_append(ub, "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n", 40)) goto error;
+	if (uwsgi_buffer_append(ub, "<D:multistatus xmlns:D=\"DAV:\">\n", 31)) goto error;
+	return ub;
+error:
+	uwsgi_buffer_destroy(ub);
+	return NULL;
+}
+
+int uwsgi_webdav_multistatus_close(struct uwsgi_buffer *ub) {
+	if (uwsgi_buffer_append(ub, "</D:multistatus>\n", 17)) return -1;
+	return 0;
+}
+
+int uwsgi_webdav_multistatus_response_new(struct uwsgi_buffer *ub) {
+	if (uwsgi_buffer_append(ub, "<D:response>\n", 13)) return -1;
+        return 0;
+}
+
+int uwsgi_webdav_multistatus_response_close(struct uwsgi_buffer *ub) {
+	if (uwsgi_buffer_append(ub, "</D:response>\n", 14)) return -1;
+        return 0;
+}
+
+int uwsgi_webdav_multistatus_propstat_new(struct uwsgi_buffer *ub) {
+	if (uwsgi_buffer_append(ub, "<D:propstat>\n", 13)) return -1;
+        return 0;
+}
+
+int uwsgi_webdav_multistatus_propstat_close(struct uwsgi_buffer *ub) {
+	if (uwsgi_buffer_append(ub, "</D:propstat>\n", 14)) return -1;
+        return 0;
+}
+
+int uwsgi_webdav_multistatus_prop_new(struct uwsgi_buffer *ub) {
+	if (uwsgi_buffer_append(ub, "<D:prop>\n", 9)) return -1;
+        return 0;
+}
+
+int uwsgi_webdav_multistatus_prop_close(struct uwsgi_buffer *ub) {
+	if (uwsgi_buffer_append(ub, "</D:prop>\n", 10)) return -1;
+        return 0;
+}
+
+// shortcut for adding a propfind-response item
+int uwsgi_webdav_propfind_item_add(struct uwsgi_buffer *ub, char *href, uint16_t href_len, uint64_t cl, time_t mtime, char *ctype, uint16_t ctype_len, char *displayname, uint16_t displayname_len, char *etag, uint16_t etag_len) {
+	if (uwsgi_webdav_multistatus_response_new(ub)) return -1;
+	if (uwsgi_buffer_append(ub, "<D:href>", 8)) return -1;
+	if (uwsgi_buffer_append(ub, href, href_len)) return -1;
+	if (uwsgi_buffer_append(ub, "</D:href>\n", 10)) return -1;
+	if (uwsgi_webdav_multistatus_propstat_new(ub)) return -1;
+	if (uwsgi_webdav_multistatus_prop_new(ub)) return -1;
+
+	if (href[href_len-1] == '/') {
+		if (uwsgi_buffer_append(ub, "<D:resourcetype><D:collection/></D:resourcetype>\n", 49)) return -1;
+	}
+	else {
+		// getcontentlength
+		if (uwsgi_buffer_append(ub, "<D:getcontentlength>", 20)) return -1;
+		if (uwsgi_buffer_num64(ub, cl)) return -1;
+		if (uwsgi_buffer_append(ub, "</D:getcontentlength>\n", 22)) return -1;
+	}
+
+	// getlastmodified
+	if (mtime > 0) {
+		if (uwsgi_buffer_append(ub, "<D:getlastmodified>", 19)) return -1;	
+		if (uwsgi_buffer_httpdate(ub, mtime)) return -1;
+		if (uwsgi_buffer_append(ub, "</D:getlastmodified>\n", 21)) return -1;	
+	}
+
+	// displayname
+	if (displayname_len > 0) {
+		if (uwsgi_buffer_append(ub, "<D:displayname>\n", 16)) return -1;
+		if (uwsgi_buffer_append_xml(ub, displayname, displayname_len)) return -1;
+		if (uwsgi_buffer_append(ub, "</D:displayname>\n", 17)) return -1;
+	}
+
+	if (ctype_len > 0) {
+		if (uwsgi_buffer_append(ub, "<D:getcontenttype>", 18)) return -1;
+		if (uwsgi_buffer_append(ub, ctype, ctype_len)) return -1;
+		if (uwsgi_buffer_append(ub, "</D:getcontenttype>\n", 20)) return -1;
+	}
+
+	if (etag_len > 0) {
+		if (uwsgi_buffer_append(ub, "<D:getetag>\n", 12)) return -1;
+		if (uwsgi_buffer_append_xml(ub, displayname, displayname_len)) return -1;
+		if (uwsgi_buffer_append(ub, "</D:getetag>\n", 13)) return -1;
+	}
+
+	if (uwsgi_webdav_multistatus_prop_close(ub)) return -1;
+	if (uwsgi_webdav_multistatus_propstat_close(ub)) return -1;
+	if (uwsgi_webdav_multistatus_response_close(ub)) return -1;
+	return 0;
+}
diff --git a/core/zeus.c b/core/zeus.c
index 3f738ab..f17dcb0 100644
--- a/core/zeus.c
+++ b/core/zeus.c
@@ -1,3 +1,5 @@
+#include <uwsgi.h>
+
 /*
 
 	*** WORK IN PROGRESS ***
@@ -16,11 +18,11 @@
 
 
 	# unencrypted mode
-	uwsgi --zeus "192.168.173.17:4040 /etc/uwsgi/vassals"
+	uwsgi --zeus 192.168.173.17:4040 --emperor /etc/uwsgi/vassals
 	# crypted mode
-	uwsgi --zeus "192.168.173.17:4040,foobar.crt,foobar.key /etc/uwsgi/vassals"
+	uwsgi --zeus 192.168.173.17:4040,foobar.crt,foobar.key --emperor /etc/uwsgi/vassals
 	# crypted + authentication mode
-	uwsgi --zeus "192.168.173.17:4040,foobar.crt,foobar.key,clients.pem /etc/uwsgi/vassals"
+	uwsgi --zeus 192.168.173.17:4040,foobar.crt,foobar.key,clients.pem --emperor /etc/uwsgi/vassals
 
 
 	to connect an Emperor to Zeus
@@ -64,3 +66,23 @@
 	11 -> VASSAL_DESTROYED {name: 'foobar.ini'} [the choosen emperor -> zeus]
 
 */
+
+/*
+	check how many nodes the instace needs (default 1)
+*/
+
+int uwsgi_zeus_spawn_instance(struct uwsgi_instance *ui) {
+	int i, nodes = 1;
+	char *how_many_nodes = vassal_attr_get(ui, "zeus-nodes");
+	if (how_many_nodes) {	
+		nodes = atoi(how_many_nodes);
+	}
+	for(i=0;i<nodes;i++) {
+		// now start analyzing nodes, the one with most
+		// free slots will be used
+
+		// send NEW_VASSAL request to the node,
+		// if it answers with ACCEPTED_VASSAL 
+	}
+	return 0;
+}
diff --git a/plugins/asyncio/asyncio.c b/plugins/asyncio/asyncio.c
index 14be58f..3d857bb 100644
--- a/plugins/asyncio/asyncio.c
+++ b/plugins/asyncio/asyncio.c
@@ -205,7 +205,7 @@ static PyObject *py_uwsgi_asyncio_accept(PyObject *self, PyObject *args) {
 
         // enter harakiri mode
         if (uwsgi.harakiri_options.workers > 0) {
-                set_harakiri(uwsgi.harakiri_options.workers);
+                set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
         }
 
 	uwsgi.async_proto_fd_table[wsgi_req->fd] = wsgi_req;
@@ -312,9 +312,7 @@ static void asyncio_loop() {
 	uwsgi.wait_write_hook = uwsgi_asyncio_wait_write_hook;
 	uwsgi.wait_read_hook = uwsgi_asyncio_wait_read_hook;
 
-	uwsgi.schedule_fix = uwsgi_asyncio_schedule_fix;
-
-	if (uwsgi.async < 2) {
+	if (uwsgi.async < 1) {
 		uwsgi_log("the asyncio loop engine requires async mode (--async <n>)\n");
 		exit(1);
 	}
@@ -323,6 +321,13 @@ static void asyncio_loop() {
                 uwsgi_log("*** DANGER *** asyncio mode without coroutine/greenthread engine loaded !!!\n");
         }
 
+	if (!uwsgi.schedule_to_req) {
+		uwsgi.schedule_to_req = async_schedule_to_req_green;
+	}
+	else {
+		uwsgi.schedule_fix = uwsgi_asyncio_schedule_fix;
+	}
+
 	PyObject *asyncio = PyImport_ImportModule("asyncio");
 	if (!asyncio) uwsgi_pyexit;
 	
diff --git a/plugins/cache/cache.c b/plugins/cache/cache.c
index c0da1fc..2e9100b 100644
--- a/plugins/cache/cache.c
+++ b/plugins/cache/cache.c
@@ -208,10 +208,10 @@ static int uwsgi_cache_request(struct wsgi_request *wsgi_req) {
         switch(wsgi_req->uh->modifier2) {
                 case 0:
                         // get
-                        if (wsgi_req->uh->pktsize > 0) {
-                                value = uwsgi_cache_magic_get(wsgi_req->buffer, wsgi_req->uh->pktsize, &vallen, NULL, NULL);
+                        if (wsgi_req->uh->_pktsize > 0) {
+                                value = uwsgi_cache_magic_get(wsgi_req->buffer, wsgi_req->uh->_pktsize, &vallen, NULL, NULL);
                                 if (value) {
-                                        wsgi_req->uh->pktsize = vallen;
+                                        wsgi_req->uh->_pktsize = vallen;
 					if (uwsgi_response_write_body_do(wsgi_req, (char *)&wsgi_req->uh, 4)) { free(value) ; return -1;}
 					uwsgi_response_write_body_do(wsgi_req, value, vallen);
 					free(value);
@@ -220,10 +220,10 @@ static int uwsgi_cache_request(struct wsgi_request *wsgi_req) {
                         break;
                 case 1:
                         // set
-                        if (wsgi_req->uh->pktsize > 0) {
+                        if (wsgi_req->uh->_pktsize > 0) {
 				// max 3 items
                                 argc = 3;
-                                if (!uwsgi_parse_array(wsgi_req->buffer, wsgi_req->uh->pktsize, argv, argvs, &argc)) {
+                                if (!uwsgi_parse_array(wsgi_req->buffer, wsgi_req->uh->_pktsize, argv, argvs, &argc)) {
                                         if (argc > 1) {
 						uwsgi_cache_magic_set(argv[0], argvs[0], argv[1], argvs[1], 0, 0, NULL);
                                         }
@@ -232,30 +232,30 @@ static int uwsgi_cache_request(struct wsgi_request *wsgi_req) {
                         break;
                 case 2:
                         // del
-                        if (wsgi_req->uh->pktsize > 0) {
-                                uwsgi_cache_magic_del(wsgi_req->buffer, wsgi_req->uh->pktsize, NULL);
+                        if (wsgi_req->uh->_pktsize > 0) {
+                                uwsgi_cache_magic_del(wsgi_req->buffer, wsgi_req->uh->_pktsize, NULL);
                         }
                         break;
                 case 3:
                 case 4:
                         // dict
-                        if (wsgi_req->uh->pktsize > 0) {
-                                uwsgi_hooked_parse(wsgi_req->buffer, wsgi_req->uh->pktsize, cache_simple_command, (void *) wsgi_req);
+                        if (wsgi_req->uh->_pktsize > 0) {
+                                uwsgi_hooked_parse(wsgi_req->buffer, wsgi_req->uh->_pktsize, cache_simple_command, (void *) wsgi_req);
                         }
                         break;
                 case 5:
                         // get (uwsgi + stream)
-                        if (wsgi_req->uh->pktsize > 0) {
-                                value = uwsgi_cache_magic_get(wsgi_req->buffer, wsgi_req->uh->pktsize, &vallen, NULL, NULL);
+                        if (wsgi_req->uh->_pktsize > 0) {
+                                value = uwsgi_cache_magic_get(wsgi_req->buffer, wsgi_req->uh->_pktsize, &vallen, NULL, NULL);
                                 if (value) {
-                                        wsgi_req->uh->pktsize = 0;
+                                        wsgi_req->uh->_pktsize = 0;
                                         wsgi_req->uh->modifier2 = 1;
 					if (uwsgi_response_write_body_do(wsgi_req, (char *)&wsgi_req->uh, 4)) { free(value) ;return -1;}
 					uwsgi_response_write_body_do(wsgi_req, value, vallen);
 					free(value);
                                 }
                                 else {
-                                        wsgi_req->uh->pktsize = 0;
+                                        wsgi_req->uh->_pktsize = 0;
                                         wsgi_req->uh->modifier2 = 0;
 					uwsgi_response_write_body_do(wsgi_req, (char *)&wsgi_req->uh, 4);
 					free(value);
@@ -265,8 +265,8 @@ static int uwsgi_cache_request(struct wsgi_request *wsgi_req) {
 		case 6:
 			// dump
 			uc = uwsgi.caches;
-			if (wsgi_req->uh->pktsize > 0) {
-				uc = uwsgi_cache_by_namelen(wsgi_req->buffer, wsgi_req->uh->pktsize);
+			if (wsgi_req->uh->_pktsize > 0) {
+				uc = uwsgi_cache_by_namelen(wsgi_req->buffer, wsgi_req->uh->_pktsize);
 			}
 
 			if (!uc) break;
@@ -299,9 +299,9 @@ static int uwsgi_cache_request(struct wsgi_request *wsgi_req) {
 			uwsgi_buffer_destroy(cache_dump);
 			break;
 		case 17:
-			if (wsgi_req->uh->pktsize == 0) break;
+			if (wsgi_req->uh->_pktsize == 0) break;
 			memset(&ucmc, 0, sizeof(struct uwsgi_cache_magic_context));
-			if (uwsgi_hooked_parse(wsgi_req->buffer, wsgi_req->uh->pktsize, uwsgi_cache_magic_context_hook, &ucmc)) {
+			if (uwsgi_hooked_parse(wsgi_req->buffer, wsgi_req->uh->_pktsize, uwsgi_cache_magic_context_hook, &ucmc)) {
 				break;
 			}
 			manage_magic_context(wsgi_req, &ucmc);
diff --git a/plugins/cgi/cgi_plugin.c b/plugins/cgi/cgi_plugin.c
index 2dcaa90..0c7d3eb 100644
--- a/plugins/cgi/cgi_plugin.c
+++ b/plugins/cgi/cgi_plugin.c
@@ -480,7 +480,7 @@ static int uwsgi_cgi_request(struct wsgi_request *wsgi_req) {
 	char *script_name = NULL;
 
 	/* Standard CGI request */
-	if (!wsgi_req->uh->pktsize) {
+	if (!wsgi_req->len) {
 		uwsgi_log("Empty CGI request. skip.\n");
 		return -1;
 	}
@@ -731,7 +731,7 @@ clear2:
 
 		// now wait for process exit/death
 		// in async mode we need a trick...
-		if (uwsgi.async > 1) {
+		if (uwsgi.async > 0) {
 			pid_t diedpid = waitpid(cgi_pid, &waitpid_status, WNOHANG);
 			if (diedpid < 0) {
                                	uwsgi_error("waitpid()");
diff --git a/plugins/corerouter/corerouter.c b/plugins/corerouter/corerouter.c
index 134c967..de254c9 100644
--- a/plugins/corerouter/corerouter.c
+++ b/plugins/corerouter/corerouter.c
@@ -110,6 +110,10 @@ void uwsgi_cr_peer_del(struct corerouter_peer *peer) {
 	if (peer->out && peer->out_need_free) {
 		uwsgi_buffer_destroy(peer->out);
 	}
+
+	if (peer->free_key) {
+		free(peer->key);
+	}
 	free(peer);
 }
 
@@ -291,6 +295,16 @@ void corerouter_manage_subscription(char *key, uint16_t keylen, char *val, uint1
 		usr->notify = val;
                 usr->notify_len = vallen;
 	}
+	else if (!uwsgi_strncmp("algo", 4, key, keylen)) {
+                usr->algo = uwsgi_subscription_algo_get(val, vallen);
+        }
+	else if (!uwsgi_strncmp("backup", 6, key, keylen)) {
+		usr->backup_level = uwsgi_str_num(val, vallen);
+        }
+	else if (!uwsgi_strncmp("proto", 5, key, keylen)) {
+                usr->proto = val;
+                usr->proto_len = vallen;
+        }
 }
 
 void corerouter_close_peer(struct uwsgi_corerouter *ucr, struct corerouter_peer *peer) {
@@ -310,7 +324,6 @@ void corerouter_close_peer(struct uwsgi_corerouter *ucr, struct corerouter_peer
         }
 
 	if (peer->failed) {
-		
 		if (peer->soopt) {
                         if (!ucr->quiet)
                                 uwsgi_log("[uwsgi-%s] unable to connect() to node \"%.*s\" (%d retries): %s\n", ucr->short_name, (int) peer->instance_address_len, peer->instance_address, peer->retries, strerror(peer->soopt));
@@ -1052,6 +1065,7 @@ void corerouter_send_stats(struct uwsgi_corerouter *ucr) {
 #ifdef UWSGI_SSL
 				if (uwsgi_stats_keylong_comma(us, "sni_enabled", (unsigned long long) s_slot->sni_enabled)) goto end0;
 #endif
+				if (uwsgi_stats_keyval_comma(us, "algo", uwsgi_subscription_algo_name(s_slot->algo))) goto end0;
 
 				if (uwsgi_stats_key(us , "nodes")) goto end0;
 				if (uwsgi_stats_list_open(us)) goto end0;
@@ -1075,6 +1089,8 @@ void corerouter_send_stats(struct uwsgi_corerouter *ucr) {
 					if (uwsgi_stats_keylong_comma(us, "cores", (unsigned long long) s_node->cores)) goto end0;
 					if (uwsgi_stats_keylong_comma(us, "load", (unsigned long long) s_node->load)) goto end0;
 					if (uwsgi_stats_keylong_comma(us, "weight", (unsigned long long) s_node->weight)) goto end0;
+					if (uwsgi_stats_keylong_comma(us, "backup", (unsigned long long) s_node->backup_level)) goto end0;
+					if (uwsgi_stats_keyvaln_comma(us, "proto", &s_node->proto, 1)) goto end0;
 					if (uwsgi_stats_keylong_comma(us, "wrr", (unsigned long long) s_node->wrr)) goto end0;
 					if (uwsgi_stats_keylong_comma(us, "ref", (unsigned long long) s_node->reference)) goto end0;
 					if (uwsgi_stats_keylong_comma(us, "failcnt", (unsigned long long) s_node->failcnt)) goto end0;
diff --git a/plugins/corerouter/cr.h b/plugins/corerouter/cr.h
index a67a156..901c5b4 100644
--- a/plugins/corerouter/cr.h
+++ b/plugins/corerouter/cr.h
@@ -190,6 +190,11 @@ struct corerouter_peer {
 	struct corerouter_peer *next;
 
 	int current_timeout;
+
+	// maps 1:1 with subscription proto
+	char proto;
+
+	int free_key;
 };
 
 struct uwsgi_corerouter {
@@ -271,7 +276,7 @@ struct uwsgi_corerouter {
         char *resubscribe_bind;
 
 	size_t buffer_size;
-
+	int fallback_on_no_key;
 };
 
 // a session is started when a client connect to the router
diff --git a/plugins/corerouter/cr_map.c b/plugins/corerouter/cr_map.c
index 066031e..9d9908f 100644
--- a/plugins/corerouter/cr_map.c
+++ b/plugins/corerouter/cr_map.c
@@ -48,11 +48,18 @@ int uwsgi_cr_map_use_pattern(struct uwsgi_corerouter *ucr, struct corerouter_pee
 
 int uwsgi_cr_map_use_subscription(struct uwsgi_corerouter *ucr, struct corerouter_peer *peer) {
 
-	peer->un = uwsgi_get_subscribe_node(ucr->subscriptions, peer->key, peer->key_len);
+	struct uwsgi_subscription_client usc;
+	usc.fd = peer->session->main_peer->fd;
+	usc.sockaddr = &peer->session->client_sockaddr;
+	usc.cookie = NULL;
+
+	peer->un = uwsgi_get_subscribe_node(ucr->subscriptions, peer->key, peer->key_len, &usc);
 	if (peer->un && peer->un->len) {
 		peer->instance_address = peer->un->name;
 		peer->instance_address_len = peer->un->len;
 		peer->modifier1 = peer->un->modifier1;
+		peer->modifier2 = peer->un->modifier2;
+		peer->proto = peer->un->proto;
 	}
 	else if (ucr->cheap && !ucr->i_am_cheap && uwsgi_no_subscriptions(ucr->subscriptions)) {
 		uwsgi_gateway_go_cheap(ucr->name, ucr->queue, &ucr->i_am_cheap);
@@ -68,12 +75,17 @@ int uwsgi_cr_map_use_subscription_dotsplit(struct uwsgi_corerouter *ucr, struct
 	// max 5 split, reduce DOS attempts
 	int count = 5;
 
+	struct uwsgi_subscription_client usc;
+	usc.fd = peer->session->main_peer->fd;
+	usc.sockaddr = &peer->session->client_sockaddr;
+	usc.cookie = NULL;
+
 split:
 	if (!count) return 0;
 #ifdef UWSGI_DEBUG
 	uwsgi_log("trying with %.*s\n", name_len, name);
 #endif
-        peer->un = uwsgi_get_subscribe_node(ucr->subscriptions, name, name_len);
+        peer->un = uwsgi_get_subscribe_node(ucr->subscriptions, name, name_len, &usc);
 	if (!peer->un) {
 		char *next = memchr(name+1, '.', name_len-1);
 		if (next) {
@@ -88,6 +100,8 @@ split:
                 peer->instance_address = peer->un->name;
                 peer->instance_address_len = peer->un->len;
                 peer->modifier1 = peer->un->modifier1;
+		peer->modifier2 = peer->un->modifier2;
+		peer->proto = peer->un->proto;
         }
         else if (ucr->cheap && !ucr->i_am_cheap && uwsgi_no_subscriptions(ucr->subscriptions)) {
                 uwsgi_gateway_go_cheap(ucr->name, ucr->queue, &ucr->i_am_cheap);
diff --git a/plugins/coroae/coroae.c b/plugins/coroae/coroae.c
index fc6ca7e..837f054 100644
--- a/plugins/coroae/coroae.c
+++ b/plugins/coroae/coroae.c
@@ -187,7 +187,7 @@ end:
 
 XS(XS_coroae_sighandler) {
 	int sigfd = (long) XSANY.any_ptr;
-	uwsgi_receive_signal(sigfd, "worker", uwsgi.mywid);
+	uwsgi_receive_signal(NULL, sigfd, "worker", uwsgi.mywid);
 }
 
 XS(XS_coroae_acceptor) {
@@ -227,7 +227,7 @@ edge:
 
         // enter harakiri mode
         if (uwsgi.harakiri_options.workers > 0) {
-                set_harakiri(uwsgi.harakiri_options.workers);
+                set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
         }
 
 
@@ -356,7 +356,7 @@ static void coroae_wait_condvar(SV *cv) {
 
 static void coroae_loop() {
 
-	if (uwsgi.async < 2) {
+	if (uwsgi.async < 1) {
 		if (uwsgi.mywid == 1) {
 			uwsgi_log("the Coro::AnyEvent loop engine requires async mode (--async <n>)\n");
 		}
diff --git a/plugins/cplusplus/base.cc b/plugins/cplusplus/base.cc
index a04e602..f698024 100644
--- a/plugins/cplusplus/base.cc
+++ b/plugins/cplusplus/base.cc
@@ -28,7 +28,7 @@ extern "C" int uwsgi_cplusplus_request(struct wsgi_request *wsgi_req) {
 	FakeClass *fc;
 
 	// empty request ?
-	if (!wsgi_req->uh->pktsize) {
+	if (!wsgi_req->len) {
                 uwsgi_log( "Invalid request. skip.\n");
 		goto clear;
         }
diff --git a/plugins/echo/echo_plugin.c b/plugins/echo/echo_plugin.c
index a7e7248..961d813 100644
--- a/plugins/echo/echo_plugin.c
+++ b/plugins/echo/echo_plugin.c
@@ -4,7 +4,7 @@ extern struct uwsgi_server uwsgi;
 
 static int uwsgi_echo_request(struct wsgi_request *wsgi_req) {
 
-	return uwsgi_response_write_body_do(wsgi_req, wsgi_req->buffer, wsgi_req->uh->pktsize);
+	return uwsgi_response_write_body_do(wsgi_req, wsgi_req->buffer, wsgi_req->len);
 }
 
 struct uwsgi_plugin echo_plugin = {
diff --git a/plugins/emperor_mongodb/emperor_mongodb.cc b/plugins/emperor_mongodb/emperor_mongodb.cc
index 449f5d3..bb41fc3 100644
--- a/plugins/emperor_mongodb/emperor_mongodb.cc
+++ b/plugins/emperor_mongodb/emperor_mongodb.cc
@@ -24,7 +24,14 @@ extern "C" void uwsgi_imperial_monitor_mongodb(struct uwsgi_emperor_scanner *ues
 	try {
 
 		// requested fields
-        	mongo::BSONObj p = BSON( "name" << 1 << "config" << 1 << "ts" << 1 << "uid" << 1 << "gid" << 1 << "socket" << 1 );
+		mongo::BSONObjBuilder builder;
+        	builder.appendElements(BSON("name" << 1 << "config" << 1 << "ts" << 1 << "uid" << 1 << "gid" << 1 << "socket" << 1 ));
+		struct uwsgi_string_list *e_attrs = uwsgi.emperor_collect_attributes;
+		while(e_attrs) {
+			builder.appendElements(BSON(e_attrs->value << 1));
+			e_attrs = e_attrs->next;
+		}
+		mongo::BSONObj p = builder.obj();
 		mongo::BSONObj q = mongo::fromjson(uems->json);
 		// the connection object (will be automatically destroyed at each cycle)
 		mongo::DBClientConnection c;
@@ -76,7 +83,26 @@ extern "C" void uwsgi_imperial_monitor_mongodb(struct uwsgi_emperor_scanner *ues
 			const char *socket_name = p.getStringField("socket");
 			if (strlen(socket_name) == 0) socket_name = NULL;
 
-			uwsgi_emperor_simple_do(ues, (char *) name, (char *) config, vassal_ts/1000, vassal_uid, vassal_gid, (char *) socket_name);
+			struct uwsgi_dyn_dict *attrs = NULL;
+			struct uwsgi_string_list *e_attrs = uwsgi.emperor_collect_attributes;
+			while(e_attrs) {
+				const char *attr_value = p.getStringField(e_attrs->value);
+				if (strlen(attr_value) == 0) attr_value = NULL;
+				if (attr_value) {
+					// the value memory is always reallocated
+					char *value = uwsgi_str((char *)attr_value);
+					uwsgi_dyn_dict_new(&attrs, e_attrs->value, e_attrs->len, value, strlen(value));
+				}	
+				e_attrs = e_attrs->next;
+			}
+
+			if (attrs) {
+				// attrs will be freed in case of error
+				uwsgi_emperor_simple_do_with_attrs(ues, (char *) name, (char *) config, vassal_ts/1000, vassal_uid, vassal_gid, (char *) socket_name, attrs);
+			}
+			else {
+				uwsgi_emperor_simple_do(ues, (char *) name, (char *) config, vassal_ts/1000, vassal_uid, vassal_gid, (char *) socket_name);
+			}
 		}
 
 
diff --git a/plugins/emperor_mongodb/uwsgiplugin.py b/plugins/emperor_mongodb/uwsgiplugin.py
index 5d7810d..58b5675 100644
--- a/plugins/emperor_mongodb/uwsgiplugin.py
+++ b/plugins/emperor_mongodb/uwsgiplugin.py
@@ -5,7 +5,7 @@ NAME='emperor_mongodb'
 CFLAGS = ['-I/usr/include/mongo','-I/usr/local/include/mongo']
 LDFLAGS = []
 
-LIBS = []
+LIBS = ['-lstdc++']
 if not 'UWSGI_MONGODB_NOLIB' in os.environ:
     LIBS.append('-lmongoclient')
     LIBS.append('-lboost_thread')
diff --git a/plugins/emperor_zeromq/uwsgiplugin.py b/plugins/emperor_zeromq/uwsgiplugin.py
index 5b4211e..f550d71 100644
--- a/plugins/emperor_zeromq/uwsgiplugin.py
+++ b/plugins/emperor_zeromq/uwsgiplugin.py
@@ -2,6 +2,6 @@
 NAME='emperor_zeromq'
 CFLAGS = []
 LDFLAGS = []
-LIBS = []
+LIBS = ['-lzmq']
 
 GCC_LIST = ['emperor_zeromq']
diff --git a/plugins/fastrouter/fastrouter.c b/plugins/fastrouter/fastrouter.c
index 47a5271..ba2a217 100644
--- a/plugins/fastrouter/fastrouter.c
+++ b/plugins/fastrouter/fastrouter.c
@@ -9,6 +9,7 @@
 
 static struct uwsgi_fastrouter {
 	struct uwsgi_corerouter cr;
+	char *force_key;
 } ufr;
 
 extern struct uwsgi_server uwsgi;
@@ -55,7 +56,10 @@ static struct uwsgi_option fastrouter_options[] = {
 	{"fastrouter-resubscribe-bind", required_argument, 0, "bind to the specified address when re-subscribing", uwsgi_opt_set_str, &ufr.cr.resubscribe_bind, 0},
 
 	{"fastrouter-buffer-size", required_argument, 0, "set internal buffer size (default: page size)", uwsgi_opt_set_64bit, &ufr.cr.buffer_size, 0},
-	{0, 0, 0, 0, 0, 0, 0},
+	{"fastrouter-fallback-on-no-key", no_argument, 0, "move to fallback node even if a subscription key is not found", uwsgi_opt_true, &ufr.cr.fallback_on_no_key, 0},
+
+	{"fastrouter-force-key", required_argument, 0, "skip uwsgi parsing and directly set a key", uwsgi_opt_set_str, &ufr.force_key, 0},
+	UWSGI_END_OF_OPTIONS
 };
 
 static void fr_get_hostname(char *key, uint16_t keylen, char *val, uint16_t vallen, void *data) {
@@ -198,7 +202,7 @@ static ssize_t fr_instance_connected(struct corerouter_peer *peer) {
 static ssize_t fr_recv_uwsgi_vars(struct corerouter_peer *main_peer) {
 	struct uwsgi_header *uh = (struct uwsgi_header *) main_peer->in->buf;
 	// better to store it as the original buf address could change
-	uint16_t pktsize = uh->pktsize;
+	uint16_t pktsize = uh->_pktsize;
 	// increase buffer if needed
 	if (uwsgi_buffer_fix(main_peer->in, pktsize+4))
 		return -1;
@@ -212,9 +216,15 @@ static ssize_t fr_recv_uwsgi_vars(struct corerouter_peer *main_peer) {
 		struct corerouter_peer *new_peer = uwsgi_cr_peer_add(main_peer->session);
 		new_peer->last_hook_read = fr_instance_read;
 
-		// find the hostname
-		if (uwsgi_hooked_parse(main_peer->in->buf+4, pktsize, fr_get_hostname, (void *) new_peer)) {
-			return -1;
+		if (!ufr.force_key) {
+			// find the hostname
+			if (uwsgi_hooked_parse(main_peer->in->buf+4, pktsize, fr_get_hostname, (void *) new_peer)) {
+				return -1;
+			}
+		}
+		else {
+			new_peer->key = ufr.force_key;
+			new_peer->key_len = strlen(ufr.force_key);
 		}
 
 		// check the hostname;
@@ -226,8 +236,15 @@ static ssize_t fr_recv_uwsgi_vars(struct corerouter_peer *main_peer) {
 			return -1;
 
 		// check instance
-		if (new_peer->instance_address_len == 0)
+		if (new_peer->instance_address_len == 0) {
+			if (ufr.cr.fallback_on_no_key) {
+				new_peer->failed = 1;
+				new_peer->can_retry = 1;
+				corerouter_close_peer(&ufr.cr, new_peer);
+				return len;
+			}
 			return -1;
+		}
 
 		new_peer->can_retry = 1;
 
diff --git a/plugins/fiber/fiber.c b/plugins/fiber/fiber.c
index ca9191e..30603ae 100644
--- a/plugins/fiber/fiber.c
+++ b/plugins/fiber/fiber.c
@@ -83,7 +83,7 @@ static int fiber_init() {
 static void fiber_init_apps(void) {
 
         if (!ufiber.enabled) return;
-	if (uwsgi.async <= 1) {
+	if (uwsgi.async < 1) {
 		uwsgi_log("the fiber loop engine requires async mode\n");
 		exit(1);
 	}
diff --git a/plugins/forkptyrouter/forkptyrouter.c b/plugins/forkptyrouter/forkptyrouter.c
index db448ec..88ca3d9 100644
--- a/plugins/forkptyrouter/forkptyrouter.c
+++ b/plugins/forkptyrouter/forkptyrouter.c
@@ -16,14 +16,14 @@
 
 extern struct uwsgi_server uwsgi;
 
-#if defined(__linux__) || defined(__GNU_kFreeBSD__)
+#if defined(__linux__) || defined(__GNU_kFreeBSD__) || defined(__HURD__)
 #include <pty.h>
 #elif defined(__APPLE__) || defined(__OpenBSD__) || defined(__NetBSD__)
 #include <util.h>
-#elif defined(__FreeBSD__)
+#elif defined(__FreeBSD__) || defined(__DragonFly__)
 #include <libutil.h>
 #endif
-#ifndef __FreeBSD__
+#if !defined(__FreeBSD__) || !defined(__DragonFly__)
 #include <utmp.h>
 #endif
 
@@ -134,7 +134,7 @@ static ssize_t fpty_parse_uwsgi(struct corerouter_peer *peer) {
 	for(;;) {
 	if (peer->in->pos < 4) return 0;
 	struct uwsgi_header *uh = (struct uwsgi_header *) peer->in->buf;
-	uint16_t pktsize = uh->pktsize;
+	uint16_t pktsize = uh->_pktsize;
 	switch(uh->modifier2) {
 		case 0:
 			// stdin
diff --git a/plugins/forkptyrouter/uwsgiplugin.py b/plugins/forkptyrouter/uwsgiplugin.py
index 8872472..0bc8af4 100644
--- a/plugins/forkptyrouter/uwsgiplugin.py
+++ b/plugins/forkptyrouter/uwsgiplugin.py
@@ -1,7 +1,13 @@
+import os
+uwsgi_os = os.uname()[0]
+
 NAME='forkptyrouter'
 CFLAGS = []
 LDFLAGS = []
-LIBS = []
+if uwsgi_os in ('Linux', 'FreeBSD', 'GNU', 'NetBSD', 'DragonFly'):
+    LIBS = ['-lutil']
+else:
+    LIBS = []
 
 REQUIRES = ['corerouter']
 
diff --git a/plugins/gccgo/gccgo_plugin.c b/plugins/gccgo/gccgo_plugin.c
index d2aa4ee..09cfd69 100644
--- a/plugins/gccgo/gccgo_plugin.c
+++ b/plugins/gccgo/gccgo_plugin.c
@@ -222,7 +222,7 @@ static int uwsgi_gccgo_request(struct wsgi_request *wsgi_req) {
 		goto end;
 	}
 	/* Standard GO request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log("Empty GO request. skip.\n");
                 return -1;
         }
@@ -342,7 +342,7 @@ static void uwsgi_gccgo_signal_goroutine(void *arg) {
 	for(;;) {
 		runtime_pollWait(pdesc, 'r');
 retry:
-		uwsgi_receive_signal(*fd, "worker", uwsgi.mywid);
+		uwsgi_receive_signal(NULL, *fd, "worker", uwsgi.mywid);
 		if (uwsgi_is_again()) continue;
 		goto retry;
 	}
@@ -389,7 +389,7 @@ retry:
 
 		// enter harakiri mode
 		if (uwsgi.harakiri_options.workers > 0) {
-                	set_harakiri(uwsgi.harakiri_options.workers);
+                	set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
         	}
 
 		// spawn the new goroutine
diff --git a/plugins/gevent/gevent.c b/plugins/gevent/gevent.c
index 15782fc..7fd455f 100644
--- a/plugins/gevent/gevent.c
+++ b/plugins/gevent/gevent.c
@@ -19,6 +19,7 @@ static void uwsgi_opt_setup_gevent(char *opt, char *value, void *null) {
 static struct uwsgi_option gevent_options[] = {
         {"gevent", required_argument, 0, "a shortcut enabling gevent loop engine with the specified number of async cores and optimal parameters", uwsgi_opt_setup_gevent, NULL, UWSGI_OPT_THREADS},
         {"gevent-monkey-patch", no_argument, 0, "call gevent.monkey.patch_all() automatically on startup", uwsgi_opt_true, &ugevent.monkey, 0},
+        {"gevent-early-monkey-patch", no_argument, 0, "call gevent.monkey.patch_all() automatically before app loading", uwsgi_opt_true, &ugevent.early_monkey, 0},
         {"gevent-wait-for-hub", no_argument, 0, "wait for gevent hub's death instead of the control greenlet", uwsgi_opt_true, &ugevent.wait_for_hub, 0},
         {0, 0, 0, 0, 0, 0, 0},
 
@@ -140,7 +141,7 @@ PyObject *py_uwsgi_gevent_signal_handler(PyObject * self, PyObject * args) {
         	return NULL;
 	}
 
-	uwsgi_receive_signal(signal_socket, "worker", uwsgi.mywid);
+	uwsgi_receive_signal(NULL, signal_socket, "worker", uwsgi.mywid);
 
 	Py_INCREF(Py_None);
 	return Py_None;
@@ -180,12 +181,14 @@ PyObject *py_uwsgi_gevent_main(PyObject * self, PyObject * args) {
 	// hack to retrieve the socket address
 	PyObject *py_uwsgi_sock = PyTuple_GetItem(args, 0);
         struct uwsgi_socket *uwsgi_sock = (struct uwsgi_socket *) PyLong_AsLong(py_uwsgi_sock);
+        long watcher_index = PyInt_AsLong(PyTuple_GetItem(args, 1));
 	struct wsgi_request *wsgi_req = NULL;
 edge:
 	wsgi_req = find_first_available_wsgi_req();
 
 	if (wsgi_req == NULL) {
 		uwsgi_async_queue_is_full(uwsgi_now());
+                PyObject_CallMethod(ugevent.watchers[watcher_index], "stop", NULL);
 		goto clear;
 	}
 
@@ -211,7 +214,7 @@ edge:
 
 	// enter harakiri mode
         if (uwsgi.harakiri_options.workers > 0) {
-                set_harakiri(uwsgi.harakiri_options.workers);
+                set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
         }
 
 	// hack to easily pass wsgi_req pointer to the greenlet
@@ -233,6 +236,10 @@ clear:
 	return Py_None;
 }
 
+PyObject *uwsgi_gevent_main;
+void start_watcher(int i, struct uwsgi_socket* uwsgi_sock) {
+        PyObject_CallMethod(ugevent.watchers[i], "start", "Oli", uwsgi_gevent_main,(long)uwsgi_sock, i);
+}
 
 PyObject *py_uwsgi_gevent_request(PyObject * self, PyObject * args) {
 
@@ -249,7 +256,7 @@ PyObject *py_uwsgi_gevent_request(PyObject * self, PyObject * args) {
 	if (wsgi_req->socket->edge_trigger) {
 		int status = wsgi_req->socket->proto(wsgi_req);
 		if (status < 0) {
-			goto end2;
+			goto end;
 		}
 		goto request;
 	}
@@ -294,7 +301,7 @@ end:
 	if (greenlet_switch) {
 		Py_DECREF(greenlet_switch);
 	}
-end2:
+
 	Py_DECREF(current_greenlet);
 
 	uwsgi_close_request(wsgi_req);
@@ -304,22 +311,34 @@ end2:
 	if (uwsgi.workers[uwsgi.mywid].manage_next_request == 0) {
 		int running_cores = 0;
 		int i;
-          for(i=0;i<uwsgi.async;i++) {
-            if (uwsgi.workers[uwsgi.mywid].cores[i].in_request) {
-              running_cores++;
-            }
-          }
-
-          if (running_cores == 0) {
-            // no need to worry about freeing memory
-            PyObject *uwsgi_dict = get_uwsgi_pydict("uwsgi");
-            if (uwsgi_dict) {
-              PyObject *ae = PyDict_GetItemString(uwsgi_dict, "atexit");
-              if (ae) {
-                python_call(ae, PyTuple_New(0), 0, NULL);
-              }
-            }
-          }
+                for(i=0;i<uwsgi.async;i++) {
+                        if (uwsgi.workers[uwsgi.mywid].cores[i].in_request) {
+                                running_cores++;
+                        }
+                }
+
+                if (running_cores == 0) {
+                        // no need to worry about freeing memory
+                        PyObject *uwsgi_dict = get_uwsgi_pydict("uwsgi");
+                        if (uwsgi_dict) {
+                                PyObject *ae = PyDict_GetItemString(uwsgi_dict, "atexit");
+                                if (ae) {
+                                        python_call(ae, PyTuple_New(0), 0, NULL);
+                                }
+                        }
+                }
+        } else {
+                // If we stopped any watcher due to being out of async workers, restart it.
+                int i = 0;
+                struct uwsgi_socket *uwsgi_sock = uwsgi.sockets;
+                for (; uwsgi_sock; uwsgi_sock = uwsgi_sock->next, ++i) {
+                        PyObject *py_watcher_active = PyObject_GetAttrString(ugevent.watchers[i], "active");
+                        if (py_watcher_active && PyBool_Check(py_watcher_active) &&
+                            !PyInt_AsLong(py_watcher_active)) {
+                            start_watcher(i, uwsgi_sock);
+                        }
+                        Py_DECREF(py_watcher_active);
+                }
         }
 
 	Py_INCREF(Py_None);
@@ -343,6 +362,14 @@ static void gil_gevent_release() {
 	PyGILState_Release((PyGILState_STATE) pthread_getspecific(up.upt_gil_key));
 }
 
+static void monkey_patch() {
+	PyObject *gevent_monkey_dict = get_uwsgi_pydict("gevent.monkey");
+        if (!gevent_monkey_dict) uwsgi_pyexit;
+        PyObject *gevent_monkey_patch_all = PyDict_GetItemString(gevent_monkey_dict, "patch_all");
+        if (!gevent_monkey_patch_all) uwsgi_pyexit;
+        PyObject *ret = python_call(gevent_monkey_patch_all, PyTuple_New(0), 0, NULL);
+        if (!ret) uwsgi_pyexit;
+}
 static void gevent_loop() {
 
 	// ensure SIGPIPE is ignored
@@ -368,7 +395,7 @@ static void gevent_loop() {
 
 	struct uwsgi_socket *uwsgi_sock = uwsgi.sockets;
 
-	if (uwsgi.async < 2) {
+	if (uwsgi.async < 1) {
 		uwsgi_log("the gevent loop engine requires async mode (--async <n>)\n");
 		exit(1);
 	}
@@ -388,12 +415,7 @@ static void gevent_loop() {
 
 	// call gevent.monkey.patch_all() if requested
 	if (ugevent.monkey) {
-		PyObject *gevent_monkey_dict = get_uwsgi_pydict("gevent.monkey");
-		if (!gevent_monkey_dict) uwsgi_pyexit;
-		PyObject *gevent_monkey_patch_all = PyDict_GetItemString(gevent_monkey_dict, "patch_all");
-        	if (!gevent_monkey_patch_all) uwsgi_pyexit;
-		PyObject *ret = python_call(gevent_monkey_patch_all, PyTuple_New(0), 0, NULL);
-		if (!ret) uwsgi_pyexit;
+		monkey_patch();
 	}
 
 	ugevent.spawn = PyDict_GetItemString(gevent_dict, "spawn");
@@ -424,7 +446,7 @@ static void gevent_loop() {
 	if (!ugevent.hub_loop) uwsgi_pyexit;
 
 	// main greenlet waiting for connection (one greenlet per-socket)
-	PyObject *uwsgi_gevent_main = PyCFunction_New(uwsgi_gevent_main_def, NULL);
+	uwsgi_gevent_main = PyCFunction_New(uwsgi_gevent_main_def, NULL);
 	Py_INCREF(uwsgi_gevent_main);
 
 	// greenlet to run at each request
@@ -471,7 +493,7 @@ static void gevent_loop() {
 		if (!ugevent.watchers[i]) uwsgi_pyexit;
 	
 		// start the main greenlet
-		PyObject_CallMethod(ugevent.watchers[i], "start", "Ol", uwsgi_gevent_main,(long)uwsgi_sock);
+		start_watcher(i, uwsgi_sock);
 		uwsgi_sock = uwsgi_sock->next;
 		i++;
 	}
@@ -531,8 +553,14 @@ static void gevent_loop() {
 
 }
 
-static void gevent_init() {
+static void gevent_preinit_apps() {
+	// call gevent.monkey.patch_all() if requested
+        if (ugevent.early_monkey) {
+                monkey_patch();
+        }
+}
 
+static void gevent_init() {
 	uwsgi_register_loop( (char *) "gevent", gevent_loop);
 }
 
@@ -541,5 +569,6 @@ struct uwsgi_plugin gevent_plugin = {
 
 	.name = "gevent",
 	.options = gevent_options,
+	.preinit_apps = gevent_preinit_apps,
 	.on_load = gevent_init,
 };
diff --git a/plugins/gevent/gevent.h b/plugins/gevent/gevent.h
index f7687d8..c39034e 100644
--- a/plugins/gevent/gevent.h
+++ b/plugins/gevent/gevent.h
@@ -56,5 +56,6 @@ struct uwsgi_gevent {
 	int destroy;
 	int monkey;
 	int wait_for_hub;
+	int early_monkey;
 };
 
diff --git a/plugins/glusterfs/glusterfs.c b/plugins/glusterfs/glusterfs.c
index 92616b6..bab76c7 100644
--- a/plugins/glusterfs/glusterfs.c
+++ b/plugins/glusterfs/glusterfs.c
@@ -213,7 +213,7 @@ static void uwsgi_glusterfs_setup() {
 static int uwsgi_glusterfs_request(struct wsgi_request *wsgi_req) {
 	char filename[PATH_MAX+1];
 	/* Standard GlusterFS request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log( "Empty GlusterFS request. skip.\n");
                 return -1;
         }
@@ -270,7 +270,7 @@ static int uwsgi_glusterfs_request(struct wsgi_request *wsgi_req) {
 	// skip body on HEAD
 	if (uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "HEAD", 4)) {
 		size_t remains = st.st_size;
-		if (uwsgi.async > 1) {
+		if (uwsgi.async > 0) {
 			if (uwsgi_glusterfs_read_async(wsgi_req, fd, remains)) goto end;
 		}
 		else {
diff --git a/plugins/greenlet/greenlet.c b/plugins/greenlet/greenlet.c
index f494a3b..7c69fa8 100644
--- a/plugins/greenlet/greenlet.c
+++ b/plugins/greenlet/greenlet.c
@@ -116,7 +116,7 @@ static void greenlet_init_apps(void) {
 
 	if (!ugl.enabled) return;
 
-	if (uwsgi.async <= 1) {
+	if (uwsgi.async < 1) {
                 uwsgi_log("the greenlet suspend engine requires async mode\n");
                 exit(1);
         }
diff --git a/plugins/gridfs/gridfs.cc b/plugins/gridfs/gridfs.cc
index d11451a..b9c0e24 100644
--- a/plugins/gridfs/gridfs.cc
+++ b/plugins/gridfs/gridfs.cc
@@ -193,7 +193,7 @@ extern "C" int uwsgi_gridfs_request(struct wsgi_request *wsgi_req) {
         char *itemname = NULL;
 
         /* Standard GridFS request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log( "Empty GridFS request. skip.\n");
                 return -1;
         }
diff --git a/plugins/http/common.h b/plugins/http/common.h
index c0143fe..fb46663 100644
--- a/plugins/http/common.h
+++ b/plugins/http/common.h
@@ -46,6 +46,10 @@ struct uwsgi_http {
 	int connect_timeout;
 	int manage_source;
 	int enable_proxy_protocol;
+
+	int proto_http;
+
+	int manage_rtsp;
 }; 
 
 struct http_session {
@@ -134,6 +138,12 @@ struct http_session {
 
 	ssize_t (*func_write)(struct corerouter_peer *);
 
+	char *proxy_src;
+        char *proxy_src_port;
+        uint16_t proxy_src_len;
+        uint16_t proxy_src_port_len;
+
+	int is_rtsp;
 };
 
 
diff --git a/plugins/http/http.c b/plugins/http/http.c
index caf3e5d..19f8262 100644
--- a/plugins/http/http.c
+++ b/plugins/http/http.c
@@ -65,15 +65,128 @@ struct uwsgi_option http_options[] = {
 
 	{"http-manage-source", no_argument, 0, "manage the SOURCE HTTP method placing the session in raw mode", uwsgi_opt_true, &uhttp.manage_source, 0},
 	{"http-enable-proxy-protocol", optional_argument, 0, "manage PROXY protocol requests", uwsgi_opt_true, &uhttp.enable_proxy_protocol, 0},
+
+	{"http-backend-http", no_argument, 0, "use plain http protocol instead of uwsgi for backend nodes", uwsgi_opt_true, &uhttp.proto_http, 0},
+
+	{"http-manage-rtsp", no_argument, 0, "manage RTSP sessions", uwsgi_opt_true, &uhttp.manage_rtsp, 0},
 	{0, 0, 0, 0, 0, 0, 0},
 };
 
+static int rebuild_key_for_mountpoint(struct http_session *hr, struct corerouter_peer *peer) {
+	if (hr->request_uri_len == 0) return -1;
+	if (hr->request_uri[0] != '/') return -1;
+	uint16_t uri_len = hr->request_uri_len -1;
+	// find QUERY_STRING (if any)
+	char *qs = memchr(hr->request_uri+1, '?', uri_len);
+	if (qs) {
+		uri_len = (qs - hr->request_uri) - 1;
+	}
+	// is it / ?
+	if (uri_len == 0) return 0;
+	// now find the second slash occurrence (if any)
+	char *second_slash = memchr(hr->request_uri+1, '/', uri_len);
+	char *new_key = NULL;
+	uint16_t new_key_len = 0;
+	if (second_slash) {
+		new_key = uwsgi_concat2n(peer->key, peer->key_len, hr->request_uri, second_slash - hr->request_uri);	
+		new_key_len = peer->key_len + (second_slash - hr->request_uri);
+	}
+	else {
+		new_key = uwsgi_concat2n(peer->key, peer->key_len, hr->request_uri, uri_len + 1);
+		new_key_len = peer->key_len + uri_len + 1;
+	}
+	peer->key = new_key;
+	peer->key_len = new_key_len;
+	peer->free_key = 1;
+	return 0;
+}
+
 static void http_set_timeout(struct corerouter_peer *peer, int timeout) {
 	if (peer->current_timeout == timeout) return;
 	peer->current_timeout = timeout;
 	peer->timeout = corerouter_reset_timeout(peer->session->corerouter, peer);
 }
 
+static int http_header_dumb_check(struct http_session *hr, struct corerouter_peer *peer, char *hh, size_t hhlen) {
+	size_t i;
+        char *val = hh;
+        int status = 0;
+	uint16_t keylen = 0;
+	uint16_t vallen = 0;
+        for (i = 0; i < hhlen; i++) {
+                if (!status) {
+                        if (hh[i] == ':') {
+                                status = 1;
+                                keylen = i;
+                        }
+                }
+                else if (status == 1 && hh[i] != ' ') {
+                        status = 2;
+                        val += i;
+                        vallen+=1;
+                }
+                else if (status == 2) {
+                        vallen+=1;
+                }
+        }
+
+	if (!keylen) return -1;
+
+	if (hr->websockets) {
+                if (!uwsgi_strnicmp("UPGRADE", 7, hh, keylen)) {
+                        if (!uwsgi_strncmp(val, vallen, "websocket", 9)) {
+                                hr->websockets++;
+                        }
+			return 0;
+                }
+                else if (!uwsgi_strncmp("CONNECTION", 10, hh, keylen)) {
+                        if (!uwsgi_strnicmp(val, vallen, "Upgrade", 7)) {
+                                hr->websockets++;
+                        }
+			return 0;
+                }
+                else if (!uwsgi_strnicmp("SEC-WEBSOCKET-VERSION", 21, hh, keylen)) {
+                        hr->websockets++;
+			return 0;
+                }
+                else if (!uwsgi_strnicmp("SEC-WEBSOCKET-KEY", 17, hh, keylen)) {
+                        hr->websocket_key = val;
+                        hr->websocket_key_len = vallen;
+			return 0;
+                }
+        }
+
+
+        if (!uwsgi_strnicmp("CONTENT-LENGTH", 14, hh, keylen)) {
+                hr->content_length = uwsgi_str_num(val, vallen);
+        }
+
+        // in the future we could support chunked requests...
+        else if (!uwsgi_strnicmp("TRANSFER_ENCODING", 17, hh, keylen)) {
+                hr->session.can_keepalive = 0;
+        }
+
+        else if (!uwsgi_strnicmp("CONNECTION", 10, hh, keylen)) {
+                if (!uwsgi_strnicmp(val, vallen, "close", 5) || !uwsgi_strnicmp(val, vallen, "upgrade", 7)) {
+                        hr->session.can_keepalive = 0;
+                }
+        }
+        else if (peer->key == uwsgi.hostname && hr->raw_body && !uwsgi_strnicmp("ICE-URL", 7, hh, keylen)) {
+                peer->key = val;
+                peer->key_len = vallen;
+        }
+
+#ifdef UWSGI_ZLIB
+        else if (uhttp.auto_gzip && !uwsgi_strnicmp("ACCEPT-ENCODING", 15, hh, keylen)) {
+                if ( uwsgi_contains_n(val, vallen, "gzip", 4) ) {
+                        hr->can_gzip = 1;
+                }
+        }
+#endif
+
+	return 0;
+}
+
 static char * http_header_to_cgi(char *hh, size_t hhlen, size_t *keylen, size_t *vallen, int *has_prefix) {
 	size_t i;
 	char *val = hh;
@@ -138,8 +251,6 @@ static int http_add_uwsgi_header(struct corerouter_peer *peer, char *hh, size_t
 	}	
 
 	if (!uwsgi_strncmp("HOST", 4, hh, keylen)) {
-		peer->key = val;
-		peer->key_len = vallen;
 		if (uhttp.server_name_as_http_host && uwsgi_buffer_append_keyval(out, "SERVER_NAME", 11, peer->key, peer->key_len)) return -1;
 	}
 
@@ -187,23 +298,262 @@ done:
 	return 0;
 }
 
+static int http_headers_parse_first_round(struct corerouter_peer *peer) {
+        struct http_session *hr = (struct http_session *) peer->session;
+	char *ptr = peer->session->main_peer->in->buf;
+        char *watermark = ptr + hr->headers_size;
+        char *base = ptr;
+        char *proxy_dst = NULL;
+        char *proxy_dst_port = NULL;
+        uint16_t proxy_dst_len = 0;
+        uint16_t proxy_dst_port_len = 0;
+
+	int skip = 0;
+
+	//struct uwsgi_buffer *out = peer->out;
+        int found = 0;
+
+        if (uwsgi.enable_proxy_protocol || uhttp.enable_proxy_protocol) {
+                ptr = proxy1_parse(ptr, watermark, &hr->proxy_src, &hr->proxy_src_len, &proxy_dst, &proxy_dst_len, &hr->proxy_src_port, &hr->proxy_src_port_len, &proxy_dst_port, &proxy_dst_port_len);
+		// how many bytes to skip ?
+		skip = ptr - base;
+                base = ptr;
+        }
+
+	// the following code is only a check for http compliance
+
+        // METHOD
+        while (ptr < watermark) {
+                if (*ptr == ' ') {
+                        ptr++;
+                        found = 1;
+                        break;
+                }
+                else if (*ptr == '\r' || *ptr == '\n') break;
+                ptr++;
+        }
+
+        // ensure we have a method
+        if (!found) return -1;
+
+	// REQUEST_URI / PATH_INFO / QUERY_STRING
+        base = ptr;
+        found = 0;
+        while (ptr < watermark) {
+                if (*ptr == ' ') {
+			// if we want to allow sub-keys, we need to parse the first part of the REQUEST_URI
+                        hr->request_uri = base;
+                        hr->request_uri_len = ptr - base;
+                        ptr++;
+                        found = 1;
+                        break;
+                }
+                ptr++;
+        }
+
+        // ensure we have a URI
+        if (!found) return -1;
+
+        // SERVER_PROTOCOL
+        base = ptr;
+        found = 0;
+        while (ptr < watermark) {
+                if (*ptr == '\r') {
+                        if (ptr + 1 >= watermark)
+                                return 0;
+                        if (*(ptr + 1) != '\n')
+                                return 0;
+                        ptr += 2;
+                        found = 1;
+                        break;
+                }
+                ptr++;
+        }
+
+        // ensure we have a protocol
+        if (!found) return -1;
+
+        peer->key = uwsgi.hostname;
+        peer->key_len = uwsgi.hostname_len;
+
+        //HEADERS
+        base = ptr;
+        while (ptr < watermark) {
+                if (*ptr == '\r') {
+                        if (ptr + 1 >= watermark)
+                                break;
+                        if (*(ptr + 1) != '\n')
+                                break;
+                        // multiline header ?
+                        if (ptr + 2 < watermark) {
+                                if (*(ptr + 2) == ' ' || *(ptr + 2) == '\t') {
+                                        ptr += 2;
+                                        continue;
+                                }
+                        }
+
+                        if ((ptr - base) > 6 && !uwsgi_strnicmp("HOST: ", 6, base, 6)) {
+				peer->key = base + 6;
+				peer->key_len = (ptr - base) - 6;
+                        }
+
+                        // last line, do not waste time
+                        if (ptr - base == 0) break;
+                        ptr++;
+                        base = ptr + 1;
+                }
+                ptr++;
+        }
+
+	return skip;
+}
+
+static int http_headers_parse_dumb(struct corerouter_peer *peer, int skip) {
+	struct http_session *hr = (struct http_session *) peer->session;
+	char *ptr = peer->session->main_peer->in->buf;
+        char *watermark = ptr + hr->headers_size;
+        char *base = ptr + skip;
+
+	// leave space for X-Forwarded-For and X-Forwarded-Proto: https
+	peer->out = uwsgi_buffer_new(hr->headers_size + 256);
+        // force this buffer to be destroyed as soon as possibile
+        peer->out_need_free = 1;
+        peer->out->limit = UMAX16;
+        peer->out_pos = 0;
+
+        //struct uwsgi_buffer *out = peer->out;
+        int found = 0;
+
+	// the following code is only a check for http compliance
+
+	// METHOD
+	while (ptr < watermark) {
+                if (*ptr == ' ') {
+                        // on SOURCE METHOD, force raw body
+                        if (uhttp.manage_source && !uwsgi_strncmp(base, ptr - base, "SOURCE", 6)) {
+                                hr->raw_body = 1;
+                        }
+                        ptr++;
+                        found = 1;
+                        break;
+                }
+                else if (*ptr == '\r' || *ptr == '\n') break;
+                ptr++;
+        }
+
+        // ensure we have a method
+        if (!found) return -1;
+
+	// REQUEST_URI / PATH_INFO / QUERY_STRING
+        base = ptr;
+        found = 0;
+        while (ptr < watermark) {
+                if (*ptr == ' ') {
+                        ptr++;
+                        found = 1;
+                        break;
+                }
+                ptr++;
+        }
+
+        // ensure we have a URI
+        if (!found) return -1;
+
+	// SERVER_PROTOCOL
+        base = ptr;
+        found = 0;
+        while (ptr < watermark) {
+                if (*ptr == '\r') {
+                        if (ptr + 1 >= watermark)
+                                return 0;
+                        if (*(ptr + 1) != '\n')
+                                return 0;
+                        if (uhttp.keepalive && !uwsgi_strncmp("HTTP/1.1", 8, base, ptr-base)) {
+                                hr->session.can_keepalive = 1;
+                        }
+			if (uhttp.manage_rtsp && !uwsgi_strncmp("RTSP/1.0", 8, base, ptr-base)) {
+                                hr->session.can_keepalive = 1;
+				hr->is_rtsp = 1;
+			}
+                        ptr += 2;
+                        found = 1;
+                        break;
+                }
+                ptr++;
+        }
+
+        // ensure we have a protocol
+        if (!found) return -1;
+
+	//HEADERS
+        base = ptr;
+        while (ptr < watermark) {
+                if (*ptr == '\r') {
+                        if (ptr + 1 >= watermark)
+                                break;
+                        if (*(ptr + 1) != '\n')
+                                break;
+                        // multiline header ?
+                        if (ptr + 2 < watermark) {
+                                if (*(ptr + 2) == ' ' || *(ptr + 2) == '\t') {
+                                        ptr += 2;
+                                        continue;
+                                }
+                        }
+
+                        // this is an hack with dumb/wrong/useless error checking
+                        if (uhttp.manage_expect) {
+                                if (!uwsgi_strncmp("Expect: 100-continue", 20, base, ptr - base)) {
+                                        hr->send_expect_100 = 1;
+                                }
+                        }
+                        // last line, do not waste time
+                        if (ptr - base == 0) break;
+			if (http_header_dumb_check(hr, peer, base, ptr - base)) return -1;
+                        ptr++;
+                        base = ptr + 1;
+                }
+                ptr++;
+        }
 
-int http_headers_parse(struct corerouter_peer *peer) {
+	struct uwsgi_buffer *out = peer->out;
+	if (uwsgi_buffer_append(out, peer->session->main_peer->in->buf, hr->headers_size-1)) return -1;
+
+	// X-Forwarded-For
+        if (uwsgi_buffer_append(out, "X-Forwarded-For: ", 17)) return -1;
+        if (hr->proxy_src) {
+		if (uwsgi_buffer_append(out, hr->proxy_src, hr->proxy_src_len)) return -1;
+        }
+        else {
+                if (uwsgi_buffer_append(out, peer->session->client_address, strlen(peer->session->client_address))) return -1;
+	}
+	if (uwsgi_buffer_append(out, "\r\n", 2)) return -1;
+
+#ifdef UWSGI_SSL
+	if (hr->stud_prefix_pos > 0 || hr->session.ugs->mode == UWSGI_HTTP_SSL) {
+		if (uwsgi_buffer_append(out, "X-Forwarded-Proto: https\r\n", 26)) return -1;
+	}
+#endif
+
+	if (uwsgi_buffer_append(out, "\r\n", 2)) return -1;
+
+#ifdef UWSGI_SSL
+	if (hr->session.ugs->mode == UWSGI_HTTP_FORCE_SSL) {
+                hr->force_https = 1;
+        }
+#endif
+	
+	return 0;
+}
+
+int http_headers_parse(struct corerouter_peer *peer, int skip) {
 
 	struct http_session *hr = (struct http_session *) peer->session;
 
 	char *ptr = peer->session->main_peer->in->buf;
 	char *watermark = ptr + hr->headers_size;
-	char *base = ptr;
+	char *base = ptr + skip;
 	char *query_string = NULL;
-	char *proxy_src = NULL;
-	char *proxy_dst = NULL;
-	char *proxy_src_port = NULL;
-	char *proxy_dst_port = NULL;
-	uint16_t proxy_src_len = 0;
-	uint16_t proxy_dst_len = 0;
-	uint16_t proxy_src_port_len = 0;
-	uint16_t proxy_dst_port_len = 0;
 
 	peer->out = uwsgi_buffer_new(uwsgi.page_size);
 	// force this buffer to be destroyed as soon as possibile
@@ -216,11 +566,6 @@ int http_headers_parse(struct corerouter_peer *peer) {
 	struct uwsgi_buffer *out = peer->out;
 	int found = 0;
 
-        if (uwsgi.enable_proxy_protocol || uhttp.enable_proxy_protocol) {
-		ptr = proxy1_parse(ptr, watermark, &proxy_src, &proxy_src_len, &proxy_dst, &proxy_dst_len, &proxy_src_port, &proxy_src_port_len, &proxy_dst_port, &proxy_dst_port_len);
-		base = ptr;
-        }
-
 	// REQUEST_METHOD 
 	while (ptr < watermark) {
 		if (*ptr == ' ') {
@@ -266,8 +611,6 @@ int http_headers_parse(struct corerouter_peer *peer) {
 			query_string = ptr + 1;
 		}
 		else if (*ptr == ' ') {
-			hr->request_uri = base;
-			hr->request_uri_len = ptr - base;
 			if (uwsgi_buffer_append_keyval(out, "REQUEST_URI", 11, base, ptr - base)) return -1;
 			if (!query_string) {
 				// PATH_INFO must be url-decoded !!!
@@ -316,6 +659,10 @@ int http_headers_parse(struct corerouter_peer *peer) {
 			if (uhttp.keepalive && !uwsgi_strncmp("HTTP/1.1", 8, base, ptr-base)) {
 				hr->session.can_keepalive = 1;
 			}
+			if (uhttp.manage_rtsp && !uwsgi_strncmp("RTSP/1.0", 8, base, ptr-base)) {
+				hr->session.can_keepalive = 1;
+				hr->is_rtsp = 1;
+			}
 			ptr += 2;
 			found = 1;
 			break;
@@ -333,8 +680,6 @@ int http_headers_parse(struct corerouter_peer *peer) {
 
 	// SERVER_NAME
 	if (!uhttp.server_name_as_http_host && uwsgi_buffer_append_keyval(out, "SERVER_NAME", 11, uwsgi.hostname, uwsgi.hostname_len)) return -1;
-	peer->key = uwsgi.hostname;
-	peer->key_len = uwsgi.hostname_len;
 
 	// SERVER_PORT
 	if (uwsgi_buffer_append_keyval(out, "SERVER_PORT", 11, hr->port, hr->port_len)) return -1;
@@ -352,10 +697,10 @@ int http_headers_parse(struct corerouter_peer *peer) {
 #endif
 
 	// REMOTE_ADDR
-        if (proxy_src) {
-		if (uwsgi_buffer_append_keyval(out, "REMOTE_ADDR", 11, proxy_src, proxy_src_len)) return -1;
-		if (proxy_src_port) {
-			if (uwsgi_buffer_append_keyval(out, "REMOTE_PORT", 11, proxy_src_port, proxy_src_port_len)) return -1;
+        if (hr->proxy_src) {
+		if (uwsgi_buffer_append_keyval(out, "REMOTE_ADDR", 11, hr->proxy_src, hr->proxy_src_len)) return -1;
+		if (hr->proxy_src_port) {
+			if (uwsgi_buffer_append_keyval(out, "REMOTE_PORT", 11, hr->proxy_src_port, hr->proxy_src_port_len)) return -1;
 		}
 	}
 	else
@@ -788,8 +1133,8 @@ ssize_t http_parse(struct corerouter_peer *main_peer) {
 			// default hook
 			new_peer->last_hook_read = hr_instance_read;
 		
-			// parse HTTP request
-			if (http_headers_parse(new_peer)) return -1;
+			int skip = http_headers_parse_first_round(new_peer);
+			if (skip < 0) return -1;
 
 			// check for a valid hostname
 			if (new_peer->key_len == 0) return -1;
@@ -800,6 +1145,9 @@ ssize_t http_parse(struct corerouter_peer *main_peer) {
 				break;
 			}
 #endif
+			if (uwsgi.subscription_mountpoints) {
+				if (rebuild_key_for_mountpoint(hr, new_peer)) return -1;
+			}
 			// find an instance using the key
                 	if (ucr->mapper(ucr, new_peer))
                         	return -1;
@@ -808,13 +1156,20 @@ ssize_t http_parse(struct corerouter_peer *main_peer) {
                 	if (new_peer->instance_address_len == 0)
                         	return -1;
 
-			uint16_t pktsize = new_peer->out->pos-4;
-        		// fix modifiers
-        		new_peer->out->buf[0] = new_peer->session->main_peer->modifier1;
-        		new_peer->out->buf[3] = new_peer->session->main_peer->modifier2;
-        		// fix pktsize
-        		new_peer->out->buf[1] = (uint8_t) (pktsize & 0xff);
-        		new_peer->out->buf[2] = (uint8_t) ((pktsize >> 8) & 0xff);
+			// parse HTTP request
+			if (new_peer->proto != 'h' && !uhttp.proto_http) {
+				if (http_headers_parse(new_peer, skip)) return -1;
+				uint16_t pktsize = new_peer->out->pos-4;
+        			// fix modifiers
+        			new_peer->out->buf[0] = new_peer->session->main_peer->modifier1;
+        			new_peer->out->buf[3] = new_peer->session->main_peer->modifier2;
+        			// fix pktsize
+        			new_peer->out->buf[1] = (uint8_t) (pktsize & 0xff);
+        			new_peer->out->buf[2] = (uint8_t) ((pktsize >> 8) & 0xff);
+			}
+			else {
+				if (http_headers_parse_dumb(new_peer, skip)) return -1;
+			}
 
 			if (hr->remains > 0) {
 				if (hr->content_length < hr->remains) { 
@@ -969,6 +1324,7 @@ int http_alloc_session(struct uwsgi_corerouter *ucr, struct uwsgi_gateway_socket
 	if (uhttp.websockets) {
 		hr->websockets = 1;	
 	}
+
 	hr->func_write = hr_write;
 
 	// be sure buffer does not grow over 64k
diff --git a/plugins/http/keepalive.c b/plugins/http/keepalive.c
index 7315a63..8bdff6c 100644
--- a/plugins/http/keepalive.c
+++ b/plugins/http/keepalive.c
@@ -17,7 +17,7 @@ int http_response_parse(struct http_session *hr, struct uwsgi_buffer *ub, size_t
         // protocol
         for(i=0;i<len;i++) {
                 if (buf[i] == ' ') {
-			if (hr->session.can_keepalive && uwsgi_strncmp("HTTP/1.1", 8, buf, i)) {
+			if (!hr->is_rtsp && hr->session.can_keepalive && uwsgi_strncmp("HTTP/1.1", 8, buf, i)) {
 				goto end;
 			}
                         if (i+1 >= len) return -1;;
@@ -34,6 +34,15 @@ int http_response_parse(struct http_session *hr, struct uwsgi_buffer *ub, size_t
         for(i=next;i<len;i++) {
                 if (buf[i] == '\r' || buf[i] == '\n') {
 			// status ready
+			// if we are in RTSP mode we need to ensure a 200 is returned
+			if (hr->is_rtsp) {
+				if (next + 3 >= len) return -1;
+				char *code = buf + next;
+				if (code[0] != '2' || code[1] != '0' || code[2] != '0') {
+					hr->is_rtsp = 0;
+					hr->session.can_keepalive = 0;
+				}
+			}
                         if (i+1 >= len) return -1;
                         next = i + 1;
                         found = 1;
@@ -116,7 +125,7 @@ int http_response_parse(struct http_session *hr, struct uwsgi_buffer *ub, size_t
                 }
         }
 
-	if (!has_size) {
+	if (!has_size && !hr->is_rtsp) {
 #ifdef UWSGI_ZLIB
 		if (hr->has_gzip) {
 			hr->force_gzip = 1;
diff --git a/plugins/jvm/jvm_plugin.c b/plugins/jvm/jvm_plugin.c
index f709ed1..511f893 100644
--- a/plugins/jvm/jvm_plugin.c
+++ b/plugins/jvm/jvm_plugin.c
@@ -1257,7 +1257,7 @@ static int uwsgi_jvm_request(struct wsgi_request *wsgi_req) {
 	}
 
 	/* Standard JVM request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log("Empty JVM request. skip.\n");
                 return -1;
         }
diff --git a/plugins/logfile/logfile.c b/plugins/logfile/logfile.c
index 2d027c3..a33e985 100644
--- a/plugins/logfile/logfile.c
+++ b/plugins/logfile/logfile.c
@@ -1,10 +1,49 @@
 #include <uwsgi.h>
 
+struct logfile_data {
+	char *logfile;
+	char *backupname;
+	uint64_t maxsize;
+};
+
 static ssize_t uwsgi_file_logger(struct uwsgi_logger *ul, char *message, size_t len) {
 
 	if (!ul->configured) {
 		if (ul->arg) {
-			ul->fd = open(ul->arg, O_RDWR | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR | S_IRGRP);
+			int is_keyval = 0;
+			char *backupname = NULL;
+			char *maxsize = NULL;
+			char *logfile = NULL;
+
+			if (strchr(ul->arg, '=')) {
+				if (uwsgi_kvlist_parse(ul->arg, strlen(ul->arg), ',', '=',
+					"logfile", &logfile, "backupname", &backupname, "maxsize", &maxsize, NULL)) {
+					uwsgi_log("[uwsgi-logfile] invalid keyval syntax\n");
+					exit(1);
+				}
+				is_keyval = 1;
+			}
+			if (is_keyval) {
+				if (!logfile) {
+					uwsgi_log("[uwsgi-logfile] missing logfile key\n");
+					return 0;
+				}
+
+				if (maxsize) {
+					struct logfile_data *data = uwsgi_malloc(sizeof(struct logfile_data));
+					data->logfile = logfile;
+					data->backupname = backupname;
+					data->maxsize = (uint64_t)strtoull(maxsize, NULL, 10);
+					ul->data = data;
+
+					free(maxsize);
+					maxsize = NULL;
+				}
+			} else {
+				logfile = ul->arg;
+			}
+
+			ul->fd = open(logfile, O_RDWR | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR | S_IRGRP);
 			if (ul->fd >= 0) {
 				ul->configured = 1;
 			}	
@@ -12,10 +51,21 @@ static ssize_t uwsgi_file_logger(struct uwsgi_logger *ul, char *message, size_t
 	}
 
 	if (ul->fd >= 0) {
-		return write(ul->fd, message, len);
+		ssize_t written = write(ul->fd, message, len);
+
+		if (ul->data) {
+			struct logfile_data *data = ul->data;
+			off_t logsize = lseek(ul->fd, 0, SEEK_CUR);
+
+			if (data->maxsize > 0 && (uint64_t) logsize > data->maxsize) {
+				uwsgi_log_do_rotate(data->logfile, data->backupname, logsize, ul->fd);
+			}
+		}
+
+		return written;
 	}
-	return 0;
 
+	return 0;
 }
 
 static ssize_t uwsgi_fd_logger(struct uwsgi_logger *ul, char *message, size_t len) {
diff --git a/plugins/lua/lua_plugin.c b/plugins/lua/lua_plugin.c
index fe81045..89c50cf 100644
--- a/plugins/lua/lua_plugin.c
+++ b/plugins/lua/lua_plugin.c
@@ -746,7 +746,7 @@ static int uwsgi_lua_request(struct wsgi_request *wsgi_req) {
 	}
 
 	/* Standard WSAPI request */
-	if (!wsgi_req->uh->pktsize) {
+	if (!wsgi_req->len) {
 		uwsgi_log( "Empty lua request. skip.\n");
 		return -1;
 	}
@@ -843,7 +843,7 @@ static int uwsgi_lua_request(struct wsgi_request *wsgi_req) {
 		}
 		lua_pop(L, 1);
 		lua_pushvalue(L, -1);
-		if (uwsgi.async > 1) {
+		if (uwsgi.async > 0) {
 			return UWSGI_AGAIN;
 		}
 	}
diff --git a/plugins/matheval/math.c b/plugins/matheval/math.c
index 7d41575..01fb948 100644
--- a/plugins/matheval/math.c
+++ b/plugins/matheval/math.c
@@ -6,7 +6,7 @@ static char *uwsgi_route_var_math(struct wsgi_request *wsgi_req, char *key, uint
         // avoid crash
         if (!wsgi_req->var_cnt) return NULL;
         // we make a bit of fun here, we do a copy of the vars buffer (+1 byte for final zero) and zeor-pad all of the strings
-        char *vars_buf = uwsgi_malloc(wsgi_req->uh->pktsize + keylen + 1);
+        char *vars_buf = uwsgi_malloc(wsgi_req->len + keylen + 1);
         char **names = uwsgi_malloc(sizeof(char *) * (wsgi_req->var_cnt/2));
         double *values = uwsgi_calloc(sizeof(double) * (wsgi_req->var_cnt/2));
         int i,j = 0;
diff --git a/plugins/mongrel2/mongrel2.c b/plugins/mongrel2/mongrel2.c
index 1dbf6f9..4eaef1a 100644
--- a/plugins/mongrel2/mongrel2.c
+++ b/plugins/mongrel2/mongrel2.c
@@ -64,7 +64,7 @@ static int uwsgi_mongrel2_json_parse(json_t * root, struct wsgi_request *wsgi_re
 		if (!strcmp(json_val, "JSON")) {
 			return -1;
 		}
-		wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_METHOD", 14, json_val, strlen(json_val));
+		wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_METHOD", 14, json_val, strlen(json_val));
 	}
 
 	// pretty easy, we get the file and we map it to wsgi_req->post_file, uWSGI read api will automatically use this
@@ -80,49 +80,49 @@ static int uwsgi_mongrel2_json_parse(json_t * root, struct wsgi_request *wsgi_re
 	}
 
 
-	wsgi_req->uh->pktsize += uwsgi_mongrel2_json_add(wsgi_req, root, "VERSION", "SERVER_PROTOCOL", 15, NULL, NULL);
-	wsgi_req->uh->pktsize += uwsgi_mongrel2_json_add(wsgi_req, root, "QUERY", "QUERY_STRING", 12, &query_string, &query_string_len);
+	wsgi_req->len += uwsgi_mongrel2_json_add(wsgi_req, root, "VERSION", "SERVER_PROTOCOL", 15, NULL, NULL);
+	wsgi_req->len += uwsgi_mongrel2_json_add(wsgi_req, root, "QUERY", "QUERY_STRING", 12, &query_string, &query_string_len);
 	if (query_string == NULL) {
 		// always set QUERY_STRING
-		wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, "", 0);
+		wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, "", 0);
 	}
 
 	// set SCRIPT_NAME to an empty value
-	wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SCRIPT_NAME", 11, "", 0);
+	wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SCRIPT_NAME", 11, "", 0);
 
 	if ((json_val = uwsgi_mongrel2_json_get_string(root, "PATH"))) {
-		wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "PATH_INFO", 9, json_val + script_name_len, strlen(json_val + script_name_len));
+		wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "PATH_INFO", 9, json_val + script_name_len, strlen(json_val + script_name_len));
 		if (query_string_len) {
 			char *request_uri = uwsgi_concat3n(json_val, strlen(json_val), "?", 1, query_string, query_string_len);
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, request_uri, strlen(json_val) + 1 + query_string_len);
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, request_uri, strlen(json_val) + 1 + query_string_len);
 			free(request_uri);
 		}
 		else {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, json_val, strlen(json_val));
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, json_val, strlen(json_val));
 		}
 	}
 
 	if ((json_val = uwsgi_mongrel2_json_get_string(root, "URL_SCHEME"))) {
-                wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "UWSGI_SCHEME", 12, json_val, strlen(json_val));
+                wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "UWSGI_SCHEME", 12, json_val, strlen(json_val));
         }
 
 	if ((json_val = uwsgi_mongrel2_json_get_string(root, "host"))) {
 		char *colon = strchr(json_val, ':');
 		if (colon) {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, colon + 1, strlen(colon + 1));
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, colon + 1, strlen(colon + 1));
 		}
 		else {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, "80", 2);
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, "80", 2);
 		}
 	}
 
 	if ((json_val = uwsgi_mongrel2_json_get_string(root, "x-forwarded-for"))) {
 		char *colon = strchr(json_val, ',');
 		if (colon) {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, colon + 1, (colon + 1) - json_val);
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, colon + 1, (colon + 1) - json_val);
 		}
 		else {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, json_val, strlen(json_val));
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, json_val, strlen(json_val));
 		}
 	}
 
@@ -131,7 +131,7 @@ static int uwsgi_mongrel2_json_parse(json_t * root, struct wsgi_request *wsgi_re
 		wsgi_req->post_cl = atoi(json_val);
 	}
 
-	wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_NAME", 11, uwsgi.hostname, uwsgi.hostname_len);
+	wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_NAME", 11, uwsgi.hostname, uwsgi.hostname_len);
 
 	json_iter = json_object_iter(root);
 
@@ -142,7 +142,7 @@ static int uwsgi_mongrel2_json_parse(json_t * root, struct wsgi_request *wsgi_re
 			json_value = json_object_iter_value(json_iter);
 			if (json_is_string(json_value)) {
 				json_val = (char *) json_string_value(json_value);
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_header(wsgi_req, json_key, strlen(json_key), json_val, strlen(json_val));
+				wsgi_req->len += proto_base_add_uwsgi_header(wsgi_req, json_key, strlen(json_key), json_val, strlen(json_val));
 			}
 		}
 		json_iter = json_object_iter_next(root, json_iter);
@@ -169,7 +169,7 @@ static int uwsgi_mongrel2_tnetstring_parse(struct wsgi_request *wsgi_req, char *
 	int async_upload = 0;
 
 	// set an empty SCRIPT_NAME
-	wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SCRIPT_NAME", 11, "", 0);
+	wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SCRIPT_NAME", 11, "", 0);
 
 	while (ptr < watermark) {
 
@@ -193,29 +193,29 @@ static int uwsgi_mongrel2_tnetstring_parse(struct wsgi_request *wsgi_req, char *
 				if (!uwsgi_strncmp("JSON", 4, val, vallen)) {
 					return -1;
 				}
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_METHOD", 14, val, vallen);
+				wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_METHOD", 14, val, vallen);
 			}
 			else if (!uwsgi_strncmp("VERSION", 7, key, keylen)) {
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PROTOCOL", 15, val, vallen);
+				wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PROTOCOL", 15, val, vallen);
 			}
 			else if (!uwsgi_strncmp("QUERY", 5, key, keylen)) {
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, val, vallen);
+				wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, val, vallen);
 				query_string = val;
 				query_string_len = vallen;
 			}
 			else if (!uwsgi_strncmp("PATH", 4, key, keylen)) {
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "PATH_INFO", 9, val + script_name_len, vallen - script_name_len);
+				wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "PATH_INFO", 9, val + script_name_len, vallen - script_name_len);
 				if (query_string_len) {
 					char *request_uri = uwsgi_concat3n(val, vallen, "?", 1, query_string, query_string_len);
-					wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, request_uri, vallen + 1 + query_string_len);
+					wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, request_uri, vallen + 1 + query_string_len);
 					free(request_uri);
 				}
 				else {
-					wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, val, vallen);
+					wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, val, vallen);
 				}
 			}
 			else if (!uwsgi_strncmp("URL_SCHEME", 10, key, keylen)) {	
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "UWSGI_SCHEME", 12, val, vallen);
+				wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "UWSGI_SCHEME", 12, val, vallen);
 			}
 		}
 		else {
@@ -223,10 +223,10 @@ static int uwsgi_mongrel2_tnetstring_parse(struct wsgi_request *wsgi_req, char *
 			if (!uwsgi_strncmp("host", 4, key, keylen)) {
 				char *colon = memchr(val, ':', vallen);
 				if (colon) {
-					wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, colon + 1, vallen - ((colon + 1) - val));
+					wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, colon + 1, vallen - ((colon + 1) - val));
 				}
 				else {
-					wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, "80", 2);
+					wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, "80", 2);
 				}
 			}
 			else if (!uwsgi_strncmp("content-length", 14, key, keylen)) {
@@ -245,24 +245,24 @@ static int uwsgi_mongrel2_tnetstring_parse(struct wsgi_request *wsgi_req, char *
 			else if (!uwsgi_strncmp("x-forwarded-for", 15, key, keylen)) {
 				char *colon = memchr(val, ',', vallen);
 				if (colon) {
-					wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, colon + 1, (colon + 1) - val);
+					wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, colon + 1, (colon + 1) - val);
 				}
 				else {
-					wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, val, vallen);
+					wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, val, vallen);
 				}
 			}
 			else if (!uwsgi_strncmp("x-mongrel2-upload-start", 23, key, keylen)) {
 				async_upload += 1;
 			}
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_header(wsgi_req, key, keylen, val, vallen);
+			wsgi_req->len += proto_base_add_uwsgi_header(wsgi_req, key, keylen, val, vallen);
 		}
 	}
 
-	wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_NAME", 11, uwsgi.hostname, uwsgi.hostname_len);
+	wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_NAME", 11, uwsgi.hostname, uwsgi.hostname_len);
 
 	if (query_string == NULL) {
 		// always set QUERY_STRING
-		wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, "", 0);
+		wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, "", 0);
 	}
 
 	// reject uncomplete upload
diff --git a/plugins/mono/mono_plugin.c b/plugins/mono/mono_plugin.c
index b0c2a13..c1ae15d 100644
--- a/plugins/mono/mono_plugin.c
+++ b/plugins/mono/mono_plugin.c
@@ -516,7 +516,7 @@ static void uwsgi_mono_init_apps() {
 static int uwsgi_mono_request(struct wsgi_request *wsgi_req) {
 
 	/* Standard ASP.NET request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log("Empty Mono/ASP.NET request. skip.\n");
                 return -1;
         }
diff --git a/plugins/mono/uwsgiplugin.py b/plugins/mono/uwsgiplugin.py
index e03cdf2..4d17a48 100644
--- a/plugins/mono/uwsgiplugin.py
+++ b/plugins/mono/uwsgiplugin.py
@@ -6,6 +6,9 @@ LDFLAGS = []
 LIBS = os.popen('pkg-config --libs mono-2').read().rstrip().split() 
 GCC_LIST = ['mono_plugin']
 
+if os.uname()[0] == 'Darwin':
+    LIBS.append('-framework Foundation')
+
 def post_build(config):
     if os.system("sn -k plugins/mono/uwsgi.key") != 0:
         os._exit(1)
diff --git a/plugins/nagios/nagios.c b/plugins/nagios/nagios.c
index ee0ac86..200f783 100644
--- a/plugins/nagios/nagios.c
+++ b/plugins/nagios/nagios.c
@@ -36,7 +36,7 @@ int nagios() {
 	}
 
 	uh.modifier1 = UWSGI_MODIFIER_PING;
-	uh.pktsize = 0;
+	uh._pktsize = 0;
 	uh.modifier2 = 0;
 	if (write(fd, &uh, 4) != 4) {
 		uwsgi_error("write()");
@@ -56,8 +56,8 @@ int nagios() {
 		exit(2);
 	}
 	else {
-		if (uh.pktsize > 0 && buf) {
-			fprintf(stdout, "UWSGI WARNING: %.*s\n", uh.pktsize, buf);
+		if (uh._pktsize > 0 && buf) {
+			fprintf(stdout, "UWSGI WARNING: %.*s\n", uh._pktsize, buf);
 			exit(1);
 		}
 		else {
diff --git a/plugins/php/php_plugin.c b/plugins/php/php_plugin.c
index dbe7acd..1dda41d 100644
--- a/plugins/php/php_plugin.c
+++ b/plugins/php/php_plugin.c
@@ -4,6 +4,8 @@ extern struct uwsgi_server uwsgi;
 
 static sapi_module_struct uwsgi_sapi_module;
 
+static int uwsgi_php_init(void);
+
 struct uwsgi_php {
 	struct uwsgi_string_list *allowed_docroot;
 	struct uwsgi_string_list *allowed_ext;
@@ -26,6 +28,10 @@ struct uwsgi_php {
 
 	struct uwsgi_string_list *exec_before;
 	struct uwsgi_string_list *exec_after;
+
+	char *sapi_name;
+
+	int sapi_initialized;
 } uphp;
 
 void uwsgi_opt_php_ini(char *opt, char *value, void *foobar) {
@@ -33,6 +39,10 @@ void uwsgi_opt_php_ini(char *opt, char *value, void *foobar) {
         uwsgi_sapi_module.php_ini_ignore = 1;
 }
 
+void uwsgi_opt_early_php(char *opt, char *value, void *foobar) {
+	uwsgi_php_init();
+}
+
 struct uwsgi_option uwsgi_php_options[] = {
 
         {"php-ini", required_argument, 0, "set php.ini path", uwsgi_opt_php_ini, NULL, 0},
@@ -58,6 +68,10 @@ struct uwsgi_option uwsgi_php_options[] = {
         {"php-exec-begin", required_argument, 0, "run specified php code before the requested script", uwsgi_opt_add_string_list, &uphp.exec_before, 0},
         {"php-exec-after", required_argument, 0, "run specified php code after the requested script", uwsgi_opt_add_string_list, &uphp.exec_after, 0},
         {"php-exec-end", required_argument, 0, "run specified php code after the requested script", uwsgi_opt_add_string_list, &uphp.exec_after, 0},
+        {"php-sapi-name", required_argument, 0, "hack the sapi name (required for enabling zend opcode cache)", uwsgi_opt_set_str, &uphp.sapi_name, 0},
+
+        {"early-php", no_argument, 0, "initialize an early perl interpreter shared by all loaders", uwsgi_opt_early_php, NULL, UWSGI_OPT_IMMEDIATE},
+        {"early-php-sapi-name", required_argument, 0, "hack the sapi name (required for enabling zend opcode cache)", uwsgi_opt_set_str, &uphp.sapi_name, UWSGI_OPT_IMMEDIATE},
 	UWSGI_END_OF_OPTIONS
 };
 
@@ -176,11 +190,11 @@ static void sapi_uwsgi_register_variables(zval *track_vars_array TSRMLS_DC)
 	php_register_variable_safe("DOCUMENT_ROOT", wsgi_req->document_root, wsgi_req->document_root_len, track_vars_array TSRMLS_CC);
 
 	if (wsgi_req->path_info_len) {
-		char *path_translated = ecalloc(1, (wsgi_req->file_len - wsgi_req->script_name_len) + wsgi_req->path_info_len + 1);
+		char *path_translated = ecalloc(1, wsgi_req->file_len + wsgi_req->path_info_len + 1);
 
-		memcpy(path_translated, wsgi_req->file, (wsgi_req->file_len - wsgi_req->script_name_len));
-		memcpy(path_translated + (wsgi_req->file_len - wsgi_req->script_name_len), wsgi_req->path_info, wsgi_req->path_info_len);
-		php_register_variable_safe("PATH_TRANSLATED", path_translated, (wsgi_req->file_len - wsgi_req->script_name_len) + wsgi_req->path_info_len , track_vars_array TSRMLS_CC);
+		memcpy(path_translated, wsgi_req->file, wsgi_req->file_len);
+		memcpy(path_translated + wsgi_req->file_len, wsgi_req->path_info, wsgi_req->path_info_len);
+		php_register_variable_safe("PATH_TRANSLATED", path_translated, wsgi_req->file_len + wsgi_req->path_info_len , track_vars_array TSRMLS_CC);
 	}
 	else {
 		php_register_variable_safe("PATH_TRANSLATED", "", 0, track_vars_array TSRMLS_CC);
@@ -251,8 +265,9 @@ PHP_FUNCTION(uwsgi_cache_exists) {
         char *key = NULL;
         int keylen = 0;
         char *cache = NULL;
+        int cachelen = 0;
 
-        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|s", &key, &keylen, &cache) == FAILURE) {
+        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|s", &key, &keylen, &cache, &cachelen) == FAILURE) {
                 RETURN_NULL();
         }
 
@@ -266,8 +281,9 @@ PHP_FUNCTION(uwsgi_cache_exists) {
 PHP_FUNCTION(uwsgi_cache_clear) {
 
         char *cache = NULL;
+        int cachelen = 0;
 
-        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|s", &cache) == FAILURE) {
+        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "|s", &cache, &cachelen) == FAILURE) {
                 RETURN_NULL();
         }
 
@@ -284,8 +300,9 @@ PHP_FUNCTION(uwsgi_cache_del) {
 	char *key = NULL;
         int keylen = 0;
 	char *cache = NULL;
+	int cachelen = 0;
 
-        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|s", &key, &keylen, &cache) == FAILURE) {
+        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|s", &key, &keylen, &cache, &cachelen) == FAILURE) {
                 RETURN_NULL();
         }
 
@@ -301,12 +318,13 @@ PHP_FUNCTION(uwsgi_cache_get) {
 	char *key = NULL;
 	int keylen = 0;
 	char *cache = NULL;
+	int cachelen = 0;
 	uint64_t valsize;
 
 	if (!uwsgi.caches)
 		RETURN_NULL();
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|s", &key, &keylen, &cache) == FAILURE) {
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|s", &key, &keylen, &cache, &cachelen) == FAILURE) {
                 RETURN_NULL();
         }
 
@@ -326,11 +344,12 @@ PHP_FUNCTION(uwsgi_cache_set) {
 	int vallen;
 	uint64_t expires = 0;
 	char *cache = NULL;
+	int cachelen = 0;
 
 	if (!uwsgi.caches)
 		RETURN_NULL();
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ss|ls", &key, &keylen, &value, &vallen, &expires, &cache) == FAILURE) {
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ss|ls", &key, &keylen, &value, &vallen, &expires, &cache, &cachelen) == FAILURE) {
                 RETURN_NULL();
         }
 
@@ -348,11 +367,12 @@ PHP_FUNCTION(uwsgi_cache_update) {
         int vallen;
         uint64_t expires = 0;
         char *cache = NULL;
+        int cachelen = 0;
 
         if (!uwsgi.caches)
                 RETURN_NULL();
 
-        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ss|ls", &key, &keylen, &value, &vallen, &expires, &cache) == FAILURE) {
+        if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "ss|ls", &key, &keylen, &value, &vallen, &expires, &cache, &cachelen) == FAILURE) {
                 RETURN_NULL();
         }
 
@@ -545,12 +565,15 @@ static sapi_module_struct uwsgi_sapi_module = {
 	STANDARD_SAPI_MODULE_PROPERTIES
 };
 
-int uwsgi_php_init(void) {
+static int uwsgi_php_init(void) {
 
 	struct uwsgi_string_list *pset = uphp.set;
 	struct uwsgi_string_list *append_config = uphp.append_config;
 
-	sapi_startup(&uwsgi_sapi_module);
+	if (!uphp.sapi_initialized) {
+		sapi_startup(&uwsgi_sapi_module);
+		uphp.sapi_initialized = 1;
+	}
 
 	// applying custom options
 	while(append_config) {
@@ -578,8 +601,11 @@ int uwsgi_php_init(void) {
 		}
 	}
 
-	uwsgi_sapi_module.startup(&uwsgi_sapi_module);
+	if (uphp.sapi_name) {
+		uwsgi_sapi_module.name = uphp.sapi_name;
+	}
 
+	uwsgi_sapi_module.startup(&uwsgi_sapi_module);
 	uwsgi_log("PHP %s initialized\n", PHP_VERSION);
 
 	return 0;
@@ -657,6 +683,9 @@ int uwsgi_php_request(struct wsgi_request *wsgi_req) {
 		return -1;
 	}
 
+	char *orig_path_info = wsgi_req->path_info;
+	uint16_t orig_path_info_len = wsgi_req->path_info_len;
+
 	if (uphp.docroot) {
 		wsgi_req->document_root = uphp.docroot;
 	}
@@ -733,10 +762,6 @@ oldstyle:
 		}
 	}
 
-
-	char *orig_path_info = wsgi_req->path_info;
-	uint16_t orig_path_info_len = wsgi_req->path_info_len;
-
 	if (path_info) {
 		wsgi_req->path_info = path_info;
 		wsgi_req->path_info_len = orig_path_info_len - (path_info - orig_path_info);
@@ -846,24 +871,19 @@ secure2:
         }
 
 secure3:
-
-	if (wsgi_req->document_root[wsgi_req->document_root_len-1] == '/') {
-		wsgi_req->script_name = real_filename + (wsgi_req->document_root_len-1);
+	wsgi_req->script_name = orig_path_info;
+	if (path_info) {
+		wsgi_req->script_name_len = path_info - orig_path_info;
 	}
 	else {
-		wsgi_req->script_name = real_filename + wsgi_req->document_root_len;
-	}
-
-	wsgi_req->script_name_len = strlen(wsgi_req->script_name);
+		wsgi_req->script_name_len = orig_path_info_len;
+	}	
 
 #ifdef UWSGI_DEBUG
 	uwsgi_log("php filename = %s script_name = %.*s (%d) document_root = %.*s (%d)\n", real_filename, wsgi_req->script_name_len, wsgi_req->script_name, wsgi_req->script_name_len,
 		wsgi_req->document_root_len, wsgi_req->document_root, wsgi_req->document_root_len);
 #endif
 
-
-
-
 	// now check for allowed paths and extensions
 
 	SG(request_info).request_uri = estrndup(wsgi_req->uri, wsgi_req->uri_len);
diff --git a/plugins/ping/ping_plugin.c b/plugins/ping/ping_plugin.c
index 384fa97..c620c72 100644
--- a/plugins/ping/ping_plugin.c
+++ b/plugins/ping/ping_plugin.c
@@ -29,7 +29,7 @@ static void ping() {
 	}
 
 	uh.modifier1 = UWSGI_MODIFIER_PING;
-	uh.pktsize = 0;
+	uh._pktsize = 0;
 	uh.modifier2 = 0;
 
 	if (write(fd, &uh, 4) != 4) {
@@ -42,8 +42,8 @@ static void ping() {
 		exit(1);
 	}
 	else {
-		if (uh.pktsize > 0) {
-			uwsgi_log("[WARNING] node %s message: %.*s\n", uping.ping, uh.pktsize, buf);
+		if (uh._pktsize > 0) {
+			uwsgi_log("[WARNING] node %s message: %.*s\n", uping.ping, uh._pktsize, buf);
 			exit(2);
 		}
 		else {
@@ -70,13 +70,13 @@ int uwsgi_request_ping(struct wsgi_request *wsgi_req) {
 
 	uwsgi_log( "PING\n");
 	wsgi_req->uh->modifier2 = 1;
-	wsgi_req->uh->pktsize = 0;
+	wsgi_req->uh->_pktsize = 0;
 	wsgi_req->do_not_account = 1;
 
 	len = strlen(uwsgi.shared->warning_message);
 	if (len > 0) {
 		// TODO: check endianess ?
-		wsgi_req->uh->pktsize = len;
+		wsgi_req->uh->_pktsize = len;
 	}
 
 	if (uwsgi_response_write_body_do(wsgi_req, (char *) wsgi_req->uh, 4)) {
diff --git a/plugins/psgi/psgi.h b/plugins/psgi/psgi.h
index 92e6b58..f204b80 100644
--- a/plugins/psgi/psgi.h
+++ b/plugins/psgi/psgi.h
@@ -67,6 +67,11 @@ struct uwsgi_perl {
 	CV *spooler;
 
 	int no_plack;
+
+	SV **early_psgi_callable;
+	char *early_psgi_app_name;
+
+	PerlInterpreter *early_interpreter;
 };
 
 void init_perl_embedded_module(void);
@@ -87,3 +92,5 @@ void uwsgi_perl_exec(char *);
 
 void uwsgi_perl_check_auto_reload(void);
 void uwsgi_psgi_preinit_apps(void);
+
+int uwsgi_perl_add_app(struct wsgi_request *, char *, PerlInterpreter **, SV **, time_t);
diff --git a/plugins/psgi/psgi_loader.c b/plugins/psgi/psgi_loader.c
index c798408..27b0280 100644
--- a/plugins/psgi/psgi_loader.c
+++ b/plugins/psgi/psgi_loader.c
@@ -337,11 +337,13 @@ int init_psgi_app(struct wsgi_request *wsgi_req, char *app, uint16_t app_len, Pe
 	if (!interpreters) goto clear2;
 
 	callables = uwsgi_calloc(sizeof(SV *) * uwsgi.threads);
-	uperl.tmp_streaming_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
-	uperl.tmp_input_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
-	uperl.tmp_error_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
-	uperl.tmp_stream_responder = uwsgi_calloc(sizeof(CV *) * uwsgi.threads);
-	uperl.tmp_psgix_logger = uwsgi_calloc(sizeof(CV *) * uwsgi.threads);
+	if (!uperl.early_interpreter) {
+		uperl.tmp_streaming_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
+		uperl.tmp_input_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
+		uperl.tmp_error_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
+		uperl.tmp_stream_responder = uwsgi_calloc(sizeof(CV *) * uwsgi.threads);
+		uperl.tmp_psgix_logger = uwsgi_calloc(sizeof(CV *) * uwsgi.threads);
+	}
 
 	for(i=0;i<uwsgi.threads;i++) {
 
@@ -369,7 +371,7 @@ int init_psgi_app(struct wsgi_request *wsgi_req, char *app, uint16_t app_len, Pe
 		// our xs_init hook, but we're *not* calling it with
 		// uperl.embedding as an argument so we won't execute
 		// BEGIN blocks in app_name twice.
-		{
+		if (!uperl.early_interpreter) {
 			char *perl_e_arg = uwsgi_concat2("#line 0 ", app_name);
 			char *perl_init_arg[] = { "", "-e", perl_e_arg };
 			if (perl_parse(interpreters[i], xs_init, 3, perl_init_arg, NULL)) {
@@ -453,46 +455,19 @@ int init_psgi_app(struct wsgi_request *wsgi_req, char *app, uint16_t app_len, Pe
 		PERL_SET_CONTEXT(interpreters[0]);
 	}
 
+	// is it an early loading ?
+	if (!uwsgi.workers) {
+		uperl.early_psgi_app_name = app_name;
+		uperl.early_psgi_callable = callables;
+		return 0;
+	}
+
 	if (uwsgi_apps_cnt >= uwsgi.max_apps) {
 		uwsgi_log("ERROR: you cannot load more than %d apps in a worker\n", uwsgi.max_apps);
 		goto clear;
 	}
 
-	int id = uwsgi_apps_cnt;
-	struct uwsgi_app *wi = NULL;
-
-	if (wsgi_req) {
-		// we need a copy of app_id
-		wi = uwsgi_add_app(id, psgi_plugin.modifier1, uwsgi_concat2n(wsgi_req->appid, wsgi_req->appid_len, "", 0), wsgi_req->appid_len, interpreters, callables);
-	}
-	else {
-		wi = uwsgi_add_app(id, psgi_plugin.modifier1, "", 0, interpreters, callables);
-	}
-
-	wi->started_at = now;
-	wi->startup_time = uwsgi_now() - now;
-
-        uwsgi_log("PSGI app %d (%s) loaded in %d seconds at %p (interpreter %p)\n", id, app_name, (int) wi->startup_time, callables[0], interpreters[0]);
-	free(app_name);
-
-	// copy global data to app-specific areas
-	wi->stream = uperl.tmp_streaming_stash;
-	wi->input = uperl.tmp_input_stash;
-	wi->error = uperl.tmp_error_stash;
-	wi->responder0 = uperl.tmp_stream_responder;
-	wi->responder1 = uperl.tmp_psgix_logger;
-
-	uwsgi_emulate_cow_for_apps(id);
-
-
-	// restore context if required
-	if (interpreters != uperl.main) {
-		PERL_SET_CONTEXT(uperl.main[0]);
-	}
-
-	uperl.loaded = 1;
-
-	return id;
+	return uwsgi_perl_add_app(wsgi_req, app_name, interpreters, callables, now);
 
 clear:
 	if (interpreters != uperl.main) {
@@ -509,6 +484,44 @@ clear2:
        	return -1; 
 }
 
+int uwsgi_perl_add_app(struct wsgi_request *wsgi_req, char *app_name, PerlInterpreter **interpreters, SV **callables, time_t now) {
+	int id = uwsgi_apps_cnt;
+        struct uwsgi_app *wi = NULL;
+
+        if (wsgi_req) {
+                // we need a copy of app_id
+                wi = uwsgi_add_app(id, psgi_plugin.modifier1, uwsgi_concat2n(wsgi_req->appid, wsgi_req->appid_len, "", 0), wsgi_req->appid_len, interpreters, callables);
+        }
+        else {
+                wi = uwsgi_add_app(id, psgi_plugin.modifier1, "", 0, interpreters, callables);
+        }
+
+        wi->started_at = now;
+        wi->startup_time = uwsgi_now() - now;
+
+        uwsgi_log("PSGI app %d (%s) loaded in %d seconds at %p (interpreter %p)\n", id, app_name, (int) wi->startup_time, callables[0], interpreters[0]);
+        free(app_name);
+
+        // copy global data to app-specific areas
+        wi->stream = uperl.tmp_streaming_stash;
+        wi->input = uperl.tmp_input_stash;
+        wi->error = uperl.tmp_error_stash;
+        wi->responder0 = uperl.tmp_stream_responder;
+        wi->responder1 = uperl.tmp_psgix_logger;
+
+        uwsgi_emulate_cow_for_apps(id);
+
+
+        // restore context if required
+        if (interpreters != uperl.main) {
+                PERL_SET_CONTEXT(uperl.main[0]);
+        }
+
+        uperl.loaded = 1;
+
+        return id;
+}
+
 void uwsgi_psgi_preinit_apps() {
 	if (uperl.exec) {
 		PERL_SET_CONTEXT(uperl.main[0]);
@@ -524,6 +537,10 @@ void uwsgi_psgi_preinit_apps() {
 
 void uwsgi_psgi_app() {
 
+	if (uperl.early_psgi_callable) {
+		uwsgi_perl_add_app(NULL, uperl.early_psgi_app_name, uperl.main, uperl.early_psgi_callable, uwsgi_now());	
+	}
+
         if (uperl.psgi) {
 		//load app in the main interpreter list
 		init_psgi_app(NULL, uperl.psgi, strlen(uperl.psgi), uperl.main);
diff --git a/plugins/psgi/psgi_plugin.c b/plugins/psgi/psgi_plugin.c
index a764cb2..02e3c12 100644
--- a/plugins/psgi/psgi_plugin.c
+++ b/plugins/psgi/psgi_plugin.c
@@ -26,6 +26,45 @@ static void uwsgi_opt_plshell(char *opt, char *value, void *foobar) {
         }
 }
 
+EXTERN_C void xs_init (pTHX);
+int uwsgi_perl_init(void);
+
+static void uwsgi_opt_early_perl(char *opt, char *value, void *foobar) {
+	// avoid duplicates
+	if (uperl.early_interpreter) return;
+	uwsgi_perl_init();
+	uperl.early_interpreter = uperl.main[0];
+
+	// HACK the following allocations ensure correct xs initialization
+	uperl.tmp_streaming_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
+        uperl.tmp_input_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
+        uperl.tmp_error_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
+        uperl.tmp_stream_responder = uwsgi_calloc(sizeof(CV *) * uwsgi.threads);
+        uperl.tmp_psgix_logger = uwsgi_calloc(sizeof(CV *) * uwsgi.threads);
+
+	char *perl_e_arg = uwsgi_concat2("#line 0 ", value);
+        char *perl_init_arg[] = { "", "-e", perl_e_arg };
+        perl_parse(uperl.early_interpreter, xs_init, 3, perl_init_arg, NULL);
+	free(perl_e_arg);
+}
+
+static void uwsgi_opt_early_psgi(char *opt, char *value, void *foobar) {
+	uwsgi_perl_init();
+	init_psgi_app(NULL, value, strlen(value), uperl.main);
+	if (!uperl.early_psgi_callable) exit(1);
+}
+
+static void uwsgi_opt_early_exec(char *opt, char *value, void *foobar) {
+        uwsgi_perl_init();
+	if (!uperl.early_interpreter) {
+        	perl_parse(uperl.main[0], xs_init, 3, uperl.embedding, NULL);
+	}
+        SV *dollar_zero = get_sv("0", GV_ADD);
+        sv_setsv(dollar_zero, newSVpv(value, strlen(value)));
+        uwsgi_perl_exec(value);
+}
+
+
 struct uwsgi_option uwsgi_perl_options[] = {
 
         {"psgi", required_argument, 0, "load a psgi app", uwsgi_opt_set_str, &uperl.psgi, 0},
@@ -46,6 +85,9 @@ struct uwsgi_option uwsgi_perl_options[] = {
         {"plshell-oneshot", no_argument, 0, "run a perl interactive shell (one shot)", uwsgi_opt_plshell, NULL, 0},
 
         {"perl-no-plack", no_argument, 0, "force the use of do instead of Plack::Util::load_psgi", uwsgi_opt_true, &uperl.no_plack, 0},
+        {"early-perl", required_argument, 0, "initialize an early perl interpreter shared by all loaders", uwsgi_opt_early_perl, NULL, UWSGI_OPT_IMMEDIATE},
+        {"early-psgi", required_argument, 0, "load a psgi app soon after uWSGI initialization", uwsgi_opt_early_psgi, NULL, UWSGI_OPT_IMMEDIATE},
+        {"early-perl-exec", required_argument, 0, "load a perl script soon after uWSGI initialization", uwsgi_opt_early_exec, NULL, UWSGI_OPT_IMMEDIATE},
         {0, 0, 0, 0, 0, 0, 0},
 
 };
@@ -363,7 +405,7 @@ SV *build_psgi_env(struct wsgi_request *wsgi_req) {
 
         if (!hv_store(env, "psgi.run_once", 13, newSViv(0), 0)) goto clear;
 
-        if (uwsgi.async > 1) {
+        if (uwsgi.async > 0) {
                 if (!hv_store(env, "psgi.nonblocking", 16, newSViv(1), 0)) goto clear;
         }
         else {
@@ -437,6 +479,10 @@ int uwsgi_perl_init(){
 	int argc;
 	int i;
 
+	if (uperl.main) {
+		goto already_initialized;
+	}
+
 	uperl.embedding[0] = "";
 	uperl.embedding[1] = "-e";
 	uperl.embedding[2] = "0";
@@ -477,6 +523,7 @@ int uwsgi_perl_init(){
 
 	PERL_SET_CONTEXT(uperl.main[0]);
 
+already_initialized:
 #ifdef PERL_VERSION_STRING
 	uwsgi_log_initial("initialized Perl %s main interpreter at %p\n", PERL_VERSION_STRING, uperl.main[0]);
 #else
@@ -494,7 +541,7 @@ int uwsgi_perl_request(struct wsgi_request *wsgi_req) {
 	}
 
 	/* Standard PSGI request */
-	if (!wsgi_req->uh->pktsize) {
+	if (!wsgi_req->len) {
 		uwsgi_log("Empty PSGI request. skip.\n");
 		return -1;
 	}
@@ -584,7 +631,7 @@ int uwsgi_perl_request(struct wsgi_request *wsgi_req) {
 	}
 
 	while (psgi_response(wsgi_req, wsgi_req->async_result) != UWSGI_OK) {
-		if (uwsgi.async > 1) {
+		if (uwsgi.async > 0) {
 			FREETMPS;
 			LEAVE;
 			return UWSGI_AGAIN;
@@ -814,7 +861,7 @@ static void uwsgi_perl_atexit() {
                 return;
 
         // managing atexit in async mode is a real pain...skip it for now
-        if (uwsgi.async > 1)
+        if (uwsgi.async > 0)
                 return;
 realstuff:
 
@@ -945,7 +992,15 @@ static int uwsgi_perl_spooler(char *filename, char *buf, uint16_t len, char *bod
 	return ret;
 }
 
+static int uwsgi_perl_hook_perl(char *arg) {
+	SV *ret = perl_eval_pv(arg, 0);
+	if (!ret) return -1;
+	return 0;
+}
 
+static void uwsgi_perl_register_features() {
+	uwsgi_register_hook("perl", uwsgi_perl_hook_perl);
+}
 
 struct uwsgi_plugin psgi_plugin = {
 
@@ -976,4 +1031,5 @@ struct uwsgi_plugin psgi_plugin = {
 	.magic = uwsgi_perl_magic,
 
 	.spooler = uwsgi_perl_spooler,
+	.on_load = uwsgi_perl_register_features,
 };
diff --git a/plugins/psgi/psgi_response.c b/plugins/psgi/psgi_response.c
index e20cfc4..648b396 100644
--- a/plugins/psgi/psgi_response.c
+++ b/plugins/psgi/psgi_response.c
@@ -68,7 +68,7 @@ int psgi_response(struct wsgi_request *wsgi_req, AV *response) {
 
 
         hitem = av_fetch(response, 1, 0);
-	if (!hitem) { uwsgi_log("invalid PSGI headers\n"); return UWSGI_OK;}
+	if (!hitem || !SvRV(*hitem) || SvTYPE(SvRV(*hitem)) != SVt_PVAV) { uwsgi_log("invalid PSGI headers\n"); return UWSGI_OK;}
 
         headers = (AV *) SvRV(*hitem);
 	if (!headers) { uwsgi_log("invalid PSGI headers\n"); return UWSGI_OK;}
@@ -148,7 +148,7 @@ int psgi_response(struct wsgi_request *wsgi_req, AV *response) {
                         chitem = SvPV( chunk, hlen);
                         if (hlen <= 0) {
 				SvREFCNT_dec(chunk);
-				if (uwsgi.async > 1 && wsgi_req->async_force_again) {
+				if (uwsgi.async > 0 && wsgi_req->async_force_again) {
 					wsgi_req->async_placeholder = (SV *) *hitem;
 					return UWSGI_AGAIN;
 				}
@@ -161,7 +161,7 @@ int psgi_response(struct wsgi_request *wsgi_req, AV *response) {
                                 break;
 			}
 			SvREFCNT_dec(chunk);
-			if (uwsgi.async > 1) {
+			if (uwsgi.async > 0) {
 				wsgi_req->async_placeholder = (SV *) *hitem;
 				wsgi_req->async_force_again = 1;
 				return UWSGI_AGAIN;
diff --git a/plugins/psgi/uwsgi_plmodule.c b/plugins/psgi/uwsgi_plmodule.c
index 8500e52..8d02ced 100644
--- a/plugins/psgi/uwsgi_plmodule.c
+++ b/plugins/psgi/uwsgi_plmodule.c
@@ -86,9 +86,11 @@ XS(XS_signal) {
 XS(XS_set_user_harakiri) {
         dXSARGS;
 
+	struct wsgi_request *wsgi_req = current_wsgi_req();
+
         psgi_check_args(1);
 
-	set_user_harakiri( SvIV(ST(0)) );
+	set_user_harakiri(wsgi_req, SvIV(ST(0)) );
 
         XSRETURN_UNDEF;
 }
@@ -430,10 +432,10 @@ XS(XS_signal_wait) {
         wsgi_req->signal_received = -1;
 
 	if (items > 0) {
-                received_signal = uwsgi_signal_wait(SvIV(ST(0)));
+                received_signal = uwsgi_signal_wait(wsgi_req, SvIV(ST(0)));
         }
         else {
-                received_signal = uwsgi_signal_wait(-1);
+                received_signal = uwsgi_signal_wait(wsgi_req, -1);
         }
 
         if (received_signal < 0) {
@@ -946,7 +948,7 @@ XS(XS_spool) {
 		}
         }
 
-	char *filename = uwsgi_spool_request(current_wsgi_req(), ub->buf, ub->pos, body, body_len);
+	char *filename = uwsgi_spool_request(NULL, ub->buf, ub->pos, body, body_len);
 	uwsgi_buffer_destroy(ub);
 	if (filename) {
 		ST(0) = newSVpv(filename, strlen(filename));
diff --git a/plugins/pty/pty.c b/plugins/pty/pty.c
index 87d4f6b..a90965d 100644
--- a/plugins/pty/pty.c
+++ b/plugins/pty/pty.c
@@ -331,7 +331,7 @@ static int uwsgi_pty_client() {
 			if (upty.uremote) {
 				struct uwsgi_header uh;
 				uh.modifier1 = 0;
-				uh.pktsize = rlen;
+				uh._pktsize = rlen;
 				uh.modifier2 = 0;
 				if (write(upty.server_fd, &uh, 4) != 4) break;
 			}
diff --git a/plugins/pypy/pypy_plugin.c b/plugins/pypy/pypy_plugin.c
index a14ddda..8aafd24 100644
--- a/plugins/pypy/pypy_plugin.c
+++ b/plugins/pypy/pypy_plugin.c
@@ -207,7 +207,7 @@ static void uwsgi_pypy_preinit_apps() {
 
 static int uwsgi_pypy_request(struct wsgi_request *wsgi_req) {
 	/* Standard WSGI request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log( "Empty pypy request. skip.\n");
                 return -1;
         }
diff --git a/plugins/pypy/pypy_setup.py b/plugins/pypy/pypy_setup.py
index ac83c75..67533dd 100644
--- a/plugins/pypy/pypy_setup.py
+++ b/plugins/pypy/pypy_setup.py
@@ -237,7 +237,7 @@ void uwsgi_disconnect(struct wsgi_request *);
 
 int uwsgi_ready_fd(struct wsgi_request *);
 
-void set_user_harakiri(int);
+void set_user_harakiri(struct wsgi_request *, int);
 
 int uwsgi_metric_set(char *, char *, int64_t);
 int uwsgi_metric_inc(char *, char *, int64_t);
@@ -918,7 +918,10 @@ uwsgi.chunked_read_nb = uwsgi_pypy_chunked_read_nb
 """
 uwsgi.set_user_harakiri(sec)
 """
-uwsgi.set_user_harakiri = lambda x: lib.set_user_harakiri(x)
+def uwsgi_pypy_set_user_harakiri(x):
+    wsgi_req = uwsgi_pypy_current_wsgi_req()
+    lib.set_user_harakiri(wsgi_req, x)
+uwsgi.set_user_harakiri = uwsgi_pypy_set_user_harakiri
 
 
 print "Initialized PyPy with Python", sys.version
@@ -977,7 +980,7 @@ def uwsgi_pypy_continulet_switch(wsgi_req):
     lib.uwsgi.wsgi_req = wsgi_req
     
 def uwsgi_pypy_setup_continulets():
-    if lib.uwsgi.async <= 1:
+    if lib.uwsgi.async < 1:
         raise Exception("pypy continulets require async mode !!!")
     lib.uwsgi.schedule_to_main = uwsgi_pypy_continulet_switch
     lib.uwsgi.schedule_to_req = uwsgi_pypy_continulet_schedule
diff --git a/plugins/python/pump_subhandler.c b/plugins/python/pump_subhandler.c
index 0e4f026..42a84ae 100644
--- a/plugins/python/pump_subhandler.c
+++ b/plugins/python/pump_subhandler.c
@@ -255,7 +255,7 @@ int uwsgi_response_subhandler_pump(struct wsgi_request *wsgi_req) {
 				goto clear;
 			}
 
-			if (uwsgi.async > 1) {
+			if (uwsgi.async > 0) {
 				return UWSGI_AGAIN;
 			}
 
diff --git a/plugins/python/pyloader.c b/plugins/python/pyloader.c
index fb5ac40..925f3a7 100644
--- a/plugins/python/pyloader.c
+++ b/plugins/python/pyloader.c
@@ -325,12 +325,19 @@ int init_uwsgi_app(int loader, void *arg1, struct wsgi_request *wsgi_req, PyThre
 	if (uwsgi.threads > 1 && id) {
 		// if we have multiple threads we need to initialize a PyThreadState for each one
 		for(i=0;i<uwsgi.threads;i++) {
-			//uwsgi_log("%p\n", uwsgi.core[i]->ts[id]);
 			uwsgi.workers[uwsgi.mywid].cores[i].ts[id] = PyThreadState_New( ((PyThreadState *)wi->interpreter)->interp);
+			//uwsgi_log("%p\n", uwsgi.workers[uwsgi.mywid].cores[i].ts[id]);
 			if (!uwsgi.workers[uwsgi.mywid].cores[i].ts[id]) {
 				uwsgi_log("unable to allocate new PyThreadState structure for app %s", wi->mountpoint);
 				goto doh;
 			}
+			// cow ?
+			if (uwsgi.mywid == 0) {
+				int j;
+				for(j=1;j<=uwsgi.numproc;j++) {
+					uwsgi.workers[j].cores[i].ts[id] = uwsgi.workers[0].cores[i].ts[id];
+				}
+			}
 		}
 		PyThreadState_Swap((PyThreadState *) pthread_getspecific(up.upt_save_key) );
 	}
diff --git a/plugins/python/python_plugin.c b/plugins/python/python_plugin.c
index f3e7c07..e30352f 100644
--- a/plugins/python/python_plugin.c
+++ b/plugins/python/python_plugin.c
@@ -63,6 +63,29 @@ void uwsgi_opt_pyver(char *opt, char *foo, void *bar) {
 	exit(0);
 }
 
+int uwsgi_python_init(void);
+void uwsgi_python_preinit_apps(void);
+static void uwsgi_early_python(char *opt, char *foo, void *bar) {
+	static int early_initialized = 0;
+	if (early_initialized) return;
+	early_initialized = 1;
+	uwsgi_python_init();
+	uwsgi_python_preinit_apps();
+}
+
+
+static void uwsgi_early_python_import(char *opt, char *module, void *bar) {
+	uwsgi_early_python(opt, NULL, NULL);
+	if (strchr(module, '/') || uwsgi_endswith(module, ".py")) {
+        	uwsgi_pyimport_by_filename(uwsgi_pythonize(module), module);
+        }
+        else {
+        	if (PyImport_ImportModule(module) == NULL) {
+                	PyErr_Print();
+                }
+	}
+}
+
 
 void uwsgi_opt_ini_paste(char *opt, char *value, void *foobar) {
 
@@ -170,6 +193,12 @@ struct uwsgi_option uwsgi_python_options[] = {
 
 	{"py-call-osafterfork", no_argument, 0, "enable child processes running cpython to trap OS signals", uwsgi_opt_true, &up.call_osafterfork, 0},
 
+	{"early-python", no_argument, 0, "load the python VM as soon as possible (useful for the fork server)", uwsgi_early_python, NULL, UWSGI_OPT_IMMEDIATE},
+	{"early-pyimport", required_argument, 0, "import a python module in the early phase", uwsgi_early_python_import, NULL, UWSGI_OPT_IMMEDIATE},
+	{"early-python-import", required_argument, 0, "import a python module in the early phase", uwsgi_early_python_import, NULL, UWSGI_OPT_IMMEDIATE},
+	{"early-pythonpath", required_argument, 0, "add directory (or glob) to pythonpath (immediate version)", uwsgi_opt_pythonpath, NULL,  UWSGI_OPT_IMMEDIATE},
+	{"early-python-path", required_argument, 0, "add directory (or glob) to pythonpath (immediate version)", uwsgi_opt_pythonpath, NULL,  UWSGI_OPT_IMMEDIATE},
+
 	{0, 0, 0, 0, 0, 0, 0},
 };
 
@@ -332,7 +361,7 @@ void uwsgi_python_atexit() {
 		return;
 
 	// managing atexit in async mode is a real pain...skip it for now
-	if (uwsgi.async > 1)
+	if (uwsgi.async > 0)
 		return;
 realstuff:
 
@@ -397,6 +426,7 @@ void uwsgi_python_post_fork() {
 	PyErr_Clear();
 
 	if (uwsgi.mywid > 0) {
+		uwsgi_python_set_thread_name(0);
 		if (up.auto_reload) {
 			// spawn the reloader thread
 			pthread_t par_tid;
@@ -920,12 +950,16 @@ int uwsgi_python_mount_app(char *mountpoint, char *app) {
 	if (strchr(app, ':') || uwsgi_endswith(app, ".py") || uwsgi_endswith(app, ".wsgi")) {
 		uwsgi.wsgi_req->appid = mountpoint;
 		uwsgi.wsgi_req->appid_len = strlen(mountpoint);
+		// lazy ?
+        	if (uwsgi.mywid > 0) UWSGI_GET_GIL
 		if (uwsgi.single_interpreter) {
 			id = init_uwsgi_app(LOADER_MOUNT, app, uwsgi.wsgi_req, up.main_thread, PYTHON_APP_TYPE_WSGI);
 		}
 		else {
 			id = init_uwsgi_app(LOADER_MOUNT, app, uwsgi.wsgi_req, NULL, PYTHON_APP_TYPE_WSGI);
 		}
+		// lazy ?
+        	if (uwsgi.mywid > 0) UWSGI_RELEASE_GIL
 		return id;
 	}
 	return -1;
@@ -1037,6 +1071,10 @@ void uwsgi_python_destroy_env_holy(struct wsgi_request *wsgi_req) {
 
 // this hook will be executed by master (or worker1 when master is not requested, so COW is in place)
 void uwsgi_python_preinit_apps() {
+	struct uwsgi_string_list *upli = up.shared_import_list;
+
+	if (up.pre_initialized) goto ready;
+	up.pre_initialized = 1;
 
 	init_pyargv();
 
@@ -1068,8 +1106,9 @@ void uwsgi_python_preinit_apps() {
 
         init_uwsgi_vars();
 
+ready:
+
 	// load shared imports
-	struct uwsgi_string_list *upli = up.shared_import_list;
 	while(upli) {
 		if (strchr(upli->value, '/') || uwsgi_endswith(upli->value, ".py")) {
 			uwsgi_pyimport_by_filename(uwsgi_pythonize(upli->value), upli->value);
@@ -1092,7 +1131,7 @@ void uwsgi_python_init_apps() {
 	}
 
 	// prepare for stack suspend/resume
-	if (uwsgi.async > 1) {
+	if (uwsgi.async > 0) {
 		up.current_recursion_depth = uwsgi_malloc(sizeof(int)*uwsgi.async);
         	up.current_frame = uwsgi_malloc(sizeof(struct _frame)*uwsgi.async);
 	}
@@ -1266,45 +1305,51 @@ void uwsgi_python_enable_threads() {
 		up.reset_ts = threaded_reset_ts;
 	}
 
+	
+
 	uwsgi_log("python threads support enabled\n");
 	
 
 }
 
-void uwsgi_python_init_thread(int core_id) {
-
-	// set a new ThreadState for each thread
-	PyThreadState *pts;
-	pts = PyThreadState_New(up.main_thread->interp);
-	pthread_setspecific(up.upt_save_key, (void *) pts);
-	pthread_setspecific(up.upt_gil_key, (void *) pts);
-#ifdef UWSGI_DEBUG
-	uwsgi_log("python ThreadState %d = %p\n", core_id, pts);
-#endif
-	UWSGI_GET_GIL;
+void uwsgi_python_set_thread_name(int core_id) {
 	// call threading.currentThread (taken from mod_wsgi, but removes DECREFs as thread in uWSGI are fixed)
 	PyObject *threading_module = PyImport_ImportModule("threading");
         if (threading_module) {
-        	PyObject *threading_module_dict = PyModule_GetDict(threading_module);
+                PyObject *threading_module_dict = PyModule_GetDict(threading_module);
                 if (threading_module_dict) {
 #ifdef PYTHREE
-			PyObject *threading_current = PyDict_GetItemString(threading_module_dict, "current_thread");
+                        PyObject *threading_current = PyDict_GetItemString(threading_module_dict, "current_thread");
 #else
-			PyObject *threading_current = PyDict_GetItemString(threading_module_dict, "currentThread");
+                        PyObject *threading_current = PyDict_GetItemString(threading_module_dict, "currentThread");
 #endif
                         if (threading_current) {
                                 PyObject *current_thread = PyEval_CallObject(threading_current, (PyObject *)NULL);
                                 if (!current_thread) {
-					// ignore the error
+                                        // ignore the error
                                         PyErr_Clear();
                                 }
-				else {
-					PyObject_SetAttrString(current_thread, "name", PyString_FromFormat("uWSGIWorker%dCore%d", uwsgi.mywid, core_id));
-					Py_INCREF(current_thread);
-				}
+                                else {
+                                        PyObject_SetAttrString(current_thread, "name", PyString_FromFormat("uWSGIWorker%dCore%d", uwsgi.mywid, core_id));
+                                        Py_INCREF(current_thread);
+                                }
                         }
                 }
         }
+}
+
+void uwsgi_python_init_thread(int core_id) {
+
+	// set a new ThreadState for each thread
+	PyThreadState *pts;
+	pts = PyThreadState_New(up.main_thread->interp);
+	pthread_setspecific(up.upt_save_key, (void *) pts);
+	pthread_setspecific(up.upt_gil_key, (void *) pts);
+#ifdef UWSGI_DEBUG
+	uwsgi_log("python ThreadState %d = %p\n", core_id, pts);
+#endif
+	UWSGI_GET_GIL;
+	uwsgi_python_set_thread_name(core_id);
 	UWSGI_RELEASE_GIL;
 	
 
diff --git a/plugins/python/pyutils.c b/plugins/python/pyutils.c
index f4b1ef3..400c9f4 100644
--- a/plugins/python/pyutils.c
+++ b/plugins/python/pyutils.c
@@ -289,7 +289,7 @@ int uwsgi_python_call(struct wsgi_request *wsgi_req, PyObject *callable, PyObjec
 
 	if (wsgi_req->async_result) {
 		while ( manage_python_response(wsgi_req) != UWSGI_OK) {
-			if (uwsgi.async > 1) {
+			if (uwsgi.async > 0) {
 				return UWSGI_AGAIN;
 			}
 		}
diff --git a/plugins/python/raw.c b/plugins/python/raw.c
index c577bf1..47f66d2 100644
--- a/plugins/python/raw.c
+++ b/plugins/python/raw.c
@@ -71,7 +71,7 @@ int uwsgi_request_python_raw(struct wsgi_request *wsgi_req) {
 			int ret = manage_raw_response(wsgi_req);
 			if (ret == UWSGI_AGAIN) {
 				wsgi_req->async_force_again = 1;
-				if (uwsgi.async > 1) {
+				if (uwsgi.async > 0) {
 					UWSGI_RELEASE_GIL return UWSGI_AGAIN;
 				}
 				continue;
diff --git a/plugins/python/tracebacker.c b/plugins/python/tracebacker.c
index 542ef61..5430831 100644
--- a/plugins/python/tracebacker.c
+++ b/plugins/python/tracebacker.c
@@ -27,7 +27,18 @@ char *uwsgi_python_get_thread_name(PyObject *thread_id) {
 		if (PyInt_AsLong(thread_ident) == PyInt_AsLong(thread_id)) {
 			PyObject *thread_name = PyObject_GetAttrString(threads_list_next, "name");
 			if (!thread_name) goto clear2;
+#ifdef PYTHREE
+			PyObject *thread_name_utf8 = PyUnicode_AsUTF8String(thread_name);
+			if (!thread_name_utf8) goto clear2;
+			char *name = NULL;
+			char *tmp_name = PyString_AsString(thread_name_utf8);
+			if (tmp_name) {
+				name = uwsgi_str(tmp_name);	
+				Py_DECREF(thread_name_utf8);
+			}
+#else
 			char *name = PyString_AsString(thread_name);
+#endif
 			Py_DECREF(threads_list_next);
 			Py_DECREF(threads_list_iter);
 			Py_DECREF(threads_list);
@@ -133,6 +144,9 @@ void *uwsgi_python_tracebacker_thread(void *foobar) {
 			PyObject *st_items = PyIter_Next(stacktrace_iter);
 			// we have the first traceback item
 			while(st_items) {
+#ifdef PYTHREE
+				int thread_name_need_free = 0;
+#endif
 				PyObject *st_filename = PyTuple_GetItem(st_items, 0);
 				if (!st_filename) { Py_DECREF(st_items); goto next; }
 				PyObject *st_lineno = PyTuple_GetItem(st_items, 1);
@@ -149,12 +163,26 @@ void *uwsgi_python_tracebacker_thread(void *foobar) {
 				if (!iov[1].iov_base) {
 					iov[1].iov_base = "<UnnamedPythonThread>";
 				}
+#ifdef PYTHREE
+				else {
+					thread_name_need_free = 1;
+				}
+#endif
 				iov[1].iov_len = strlen(iov[1].iov_base);
 
 				iov[2].iov_base = " filename = ";
 				iov[2].iov_len = 12;
 
+#ifdef PYTHREE
+				PyObject *st_filename_utf8 = PyUnicode_AsUTF8String(st_filename);
+				if (!st_filename_utf8) {
+					if (thread_name_need_free) free(iov[1].iov_base);
+					goto next;
+				}
+				iov[3].iov_base = PyString_AsString(st_filename_utf8);
+#else
 				iov[3].iov_base = PyString_AsString(st_filename);
+#endif
 				iov[3].iov_len = strlen(iov[3].iov_base);
 
 				iov[4].iov_base = " lineno = ";
@@ -166,7 +194,17 @@ void *uwsgi_python_tracebacker_thread(void *foobar) {
 				iov[6].iov_base = " function = ";
 				iov[6].iov_len = 12 ;
 
+#ifdef PYTHREE
+                                PyObject *st_name_utf8 = PyUnicode_AsUTF8String(st_name);
+                                if (!st_name_utf8) {
+					if (thread_name_need_free) free(iov[1].iov_base);
+					Py_DECREF(st_filename_utf8);
+					goto next;
+				}
+				iov[7].iov_base = PyString_AsString(st_name_utf8);
+#else
 				iov[7].iov_base = PyString_AsString(st_name);
+#endif
                                 iov[7].iov_len = strlen(iov[7].iov_base);
 
 				iov[8].iov_base = "";
@@ -178,10 +216,24 @@ void *uwsgi_python_tracebacker_thread(void *foobar) {
 				iov[10].iov_base = "\n";
 				iov[10].iov_len = 1;
 
+#ifdef PYTHREE
+				PyObject *st_line_utf8 = NULL;
+#endif
 				if (st_line) {
 					iov[8].iov_base = " line = ";
 					iov[8].iov_len = 8;
+#ifdef PYTHREE
+                                	PyObject *st_line_utf8 = PyUnicode_AsUTF8String(st_line);
+                                	if (!st_line_utf8) {
+						if (thread_name_need_free) free(iov[1].iov_base);
+                                        	Py_DECREF(st_filename_utf8);
+                                        	Py_DECREF(st_name_utf8);
+                                        	goto next;
+                                	}
+					iov[9].iov_base = PyString_AsString(st_line_utf8);
+#else
 					iov[9].iov_base = PyString_AsString(st_line);
+#endif
 					iov[9].iov_len = strlen(iov[9].iov_base);
 				}
 
@@ -192,6 +244,15 @@ void *uwsgi_python_tracebacker_thread(void *foobar) {
 				// free the line_no
 				free(iov[5].iov_base);
 				Py_DECREF(st_items);
+#ifdef PYTHREE
+				Py_DECREF(st_filename_utf8);
+				Py_DECREF(st_name_utf8);
+				if (st_line_utf8) {
+					Py_DECREF(st_line_utf8);
+				}
+				if (thread_name_need_free)
+					free(iov[1].iov_base);
+#endif
 				st_items = PyIter_Next(stacktrace_iter);
 			}
 			if (write(client_fd, "\n", 1) < 0) {
diff --git a/plugins/python/uwsgi_pymodule.c b/plugins/python/uwsgi_pymodule.c
index 1c6f264..34f4df8 100644
--- a/plugins/python/uwsgi_pymodule.c
+++ b/plugins/python/uwsgi_pymodule.c
@@ -46,10 +46,10 @@ static PyObject *py_uwsgi_signal_wait(PyObject * self, PyObject * args) {
 	UWSGI_RELEASE_GIL;
 
 	if (wait_for_specific_signal) {
-		received_signal = uwsgi_signal_wait(uwsgi_signal);
+		received_signal = uwsgi_signal_wait(wsgi_req, uwsgi_signal);
 	}
 	else {
-		received_signal = uwsgi_signal_wait(-1);
+		received_signal = uwsgi_signal_wait(wsgi_req, -1);
 	}
 
 	if (received_signal < 0) {
@@ -382,6 +382,11 @@ PyObject *py_uwsgi_rpc(PyObject * self, PyObject * args) {
 	if (PyString_Check(py_node)) {
 		node = PyString_AsString(py_node);
 	}
+#ifdef PYTHREE
+        else if (PyUnicode_Check(py_node)) {
+                node = PyBytes_AsString(PyUnicode_AsLatin1String(py_node));
+	}
+#endif
 
 	py_func = PyTuple_GetItem(args, 1);
 
@@ -888,12 +893,13 @@ PyObject *py_uwsgi_log(PyObject * self, PyObject * args) {
 }
 
 PyObject *py_uwsgi_set_user_harakiri(PyObject * self, PyObject * args) {
+	struct wsgi_request *wsgi_req = py_current_wsgi_req();
 	int sec = 0;
 	if (!PyArg_ParseTuple(args, "i:set_user_harakiri", &sec)) {
                 return NULL;
         }
 
-	set_user_harakiri(sec);
+	set_user_harakiri(wsgi_req, sec);
 
         Py_INCREF(Py_None);
         return Py_None;
@@ -1649,7 +1655,6 @@ PyObject *py_uwsgi_sharedarea_read64(PyObject * self, PyObject * args) {
         }
 
 	return PyLong_FromLongLong(value);
-
 }
 
 PyObject *py_uwsgi_sharedarea_read32(PyObject * self, PyObject * args) {
@@ -1855,7 +1860,6 @@ PyObject *py_uwsgi_send_spool(PyObject * self, PyObject * args, PyObject *kw) {
 	PyObject *spool_dict, *spool_vars;
 	PyObject *zero, *key, *val;
 	uint16_t keysize, valsize;
-	struct wsgi_request *wsgi_req = py_current_wsgi_req();
 	char *body = NULL;
 	size_t body_len= 0;
 
@@ -1956,7 +1960,8 @@ PyObject *py_uwsgi_send_spool(PyObject * self, PyObject * args, PyObject *kw) {
 
 	UWSGI_RELEASE_GIL
 
-	char *filename = uwsgi_spool_request(wsgi_req, ub->buf, ub->pos, body, body_len);
+	// current_wsgi_req can be NULL, in such a case a non-thread-safe counter will be used
+	char *filename = uwsgi_spool_request(NULL, ub->buf, ub->pos, body, body_len);
 	uwsgi_buffer_destroy(ub);
 
 	UWSGI_GET_GIL
@@ -1988,6 +1993,16 @@ PyObject *py_uwsgi_spooler_pid(PyObject * self, PyObject * args) {
 	return PyInt_FromLong(uspool->pid);
 }
 
+PyObject *py_uwsgi_spooler_pids(PyObject * self, PyObject * args) {
+    PyObject *ret = PyList_New(0);
+    struct uwsgi_spooler *uspool = uwsgi.spoolers;
+    while (uspool) {
+        PyList_Append(ret, PyInt_FromLong(uspool->pid));
+        uspool = uspool->next;
+    }
+    return ret;
+}
+
 
 PyObject *py_uwsgi_connect(PyObject * self, PyObject * args) {
 
@@ -2240,7 +2255,8 @@ PyObject *py_uwsgi_stop(PyObject * self, PyObject * args) {
 }
 
 PyObject *py_uwsgi_request_id(PyObject * self, PyObject * args) {
-	return PyLong_FromUnsignedLongLong(uwsgi.workers[uwsgi.mywid].requests);
+	struct wsgi_request *wsgi_req = py_current_wsgi_req();
+	return PyLong_FromUnsignedLongLong(uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].requests);
 }
 
 PyObject *py_uwsgi_worker_id(PyObject * self, PyObject * args) {
@@ -2323,14 +2339,14 @@ PyObject *py_uwsgi_parse_file(PyObject * self, PyObject * args) {
 		goto clear2;
 	}
 
-	buffer = malloc(uh.pktsize);
+	buffer = malloc(uh._pktsize);
 	if (!buffer) {
 		uwsgi_error("malloc()");
 		UWSGI_GET_GIL
 		goto clear2;
 	}
-	len = read(fd, buffer, uh.pktsize);
-	if (len != uh.pktsize) {
+	len = read(fd, buffer, uh._pktsize);
+	if (len != uh._pktsize) {
 		uwsgi_error("read()");
 		free(buffer);
 		UWSGI_GET_GIL
@@ -2340,7 +2356,7 @@ PyObject *py_uwsgi_parse_file(PyObject * self, PyObject * args) {
 	UWSGI_GET_GIL
 
 	ptrbuf = buffer;
-	bufferend = ptrbuf + uh.pktsize;
+	bufferend = ptrbuf + uh._pktsize;
 
 	if (!uh.modifier1 || uh.modifier1 == UWSGI_MODIFIER_SPOOL_REQUEST) {
 		zero = PyDict_New();
@@ -2419,6 +2435,7 @@ static PyMethodDef uwsgi_spooler_methods[] = {
 	{"set_spooler_frequency", py_uwsgi_spooler_freq, METH_VARARGS, ""},
 	{"spooler_jobs", py_uwsgi_spooler_jobs, METH_VARARGS, ""},
 	{"spooler_pid", py_uwsgi_spooler_pid, METH_VARARGS, ""},
+	{"spooler_pids", py_uwsgi_spooler_pids, METH_VARARGS, ""},
 	{NULL, NULL},
 };
 
diff --git a/plugins/python/uwsgi_python.h b/plugins/python/uwsgi_python.h
index a2cc6e6..430fde6 100644
--- a/plugins/python/uwsgi_python.h
+++ b/plugins/python/uwsgi_python.h
@@ -199,6 +199,7 @@ struct uwsgi_python {
 	struct uwsgi_string_list *sharedarea;
 
 	int call_osafterfork;
+	int pre_initialized;
 };
 
 
@@ -299,6 +300,8 @@ int uwsgi_python_send_body(struct wsgi_request *, PyObject *);
 
 int uwsgi_request_python_raw(struct wsgi_request *);
 
+void uwsgi_python_set_thread_name(int);
+
 #define py_current_wsgi_req() current_wsgi_req();\
 			if (!wsgi_req) {\
 				return PyErr_Format(PyExc_SystemError, "you can call uwsgi api function only from the main callable");\
diff --git a/plugins/python/web3_subhandler.c b/plugins/python/web3_subhandler.c
index 231a538..48fe162 100644
--- a/plugins/python/web3_subhandler.c
+++ b/plugins/python/web3_subhandler.c
@@ -164,7 +164,7 @@ int uwsgi_response_subhandler_web3(struct wsgi_request *wsgi_req) {
 			if (!wsgi_req->async_placeholder) {
 				goto clear;
 			}
-			if (uwsgi.async > 1) {
+			if (uwsgi.async > 0) {
 				return UWSGI_AGAIN;
 			}
 		}
diff --git a/plugins/python/wsgi_handlers.c b/plugins/python/wsgi_handlers.c
index badb1ae..c9bb2db 100644
--- a/plugins/python/wsgi_handlers.c
+++ b/plugins/python/wsgi_handlers.c
@@ -326,7 +326,7 @@ int uwsgi_request_wsgi(struct wsgi_request *wsgi_req) {
 	}
 
 	/* Standard WSGI request */
-	if (!wsgi_req->uh->pktsize) {
+	if (!wsgi_req->len) {
 		uwsgi_log( "Empty python request. skip.\n");
 		return -1;
 	}
@@ -405,7 +405,7 @@ int uwsgi_request_wsgi(struct wsgi_request *wsgi_req) {
 
 
 		while (wi->response_subhandler(wsgi_req) != UWSGI_OK) {
-			if (uwsgi.async > 1) {
+			if (uwsgi.async > 0) {
 				UWSGI_RELEASE_GIL
 				wsgi_req->async_force_again = 1;
 				return UWSGI_AGAIN;
@@ -442,8 +442,8 @@ void uwsgi_after_request_wsgi(struct wsgi_request *wsgi_req) {
 	if (up.after_req_hook) {
 		if (uwsgi.harakiri_no_arh) {
 			// leave harakiri mode
-        		if (uwsgi.workers[uwsgi.mywid].harakiri > 0)
-                		set_harakiri(0);
+        		if (uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri > 0)
+                		set_harakiri(wsgi_req, 0);
 		}
 		UWSGI_GET_GIL
 		PyObject *arh = python_call(up.after_req_hook, up.after_req_hook_args, 0, NULL);
diff --git a/plugins/python/wsgi_subhandler.c b/plugins/python/wsgi_subhandler.c
index 7eb57b0..3112ddb 100644
--- a/plugins/python/wsgi_subhandler.c
+++ b/plugins/python/wsgi_subhandler.c
@@ -170,7 +170,7 @@ void *uwsgi_request_subhandler_wsgi(struct wsgi_request *wsgi_req, struct uwsgi_
 
 	PyDict_SetItemString(wsgi_req->async_environ, "wsgi.file_wrapper", wi->sendfile);
 
-	if (uwsgi.async > 1) {
+	if (uwsgi.async > 0) {
 		PyDict_SetItemString(wsgi_req->async_environ, "x-wsgiorg.fdevent.readable", wi->eventfd_read);
 		PyDict_SetItemString(wsgi_req->async_environ, "x-wsgiorg.fdevent.writable", wi->eventfd_write);
 		PyDict_SetItemString(wsgi_req->async_environ, "x-wsgiorg.fdevent.timeout", Py_None);
@@ -269,7 +269,7 @@ int uwsgi_response_subhandler_wsgi(struct wsgi_request *wsgi_req) {
 		if (!wsgi_req->async_placeholder) {
 			goto exception;
 		}
-		if (uwsgi.async > 1) {
+		if (uwsgi.async > 0) {
 			return UWSGI_AGAIN;
 		}
 	}
diff --git a/plugins/pyuwsgi/pyuwsgi.c b/plugins/pyuwsgi/pyuwsgi.c
index 02a0332..2f248f4 100644
--- a/plugins/pyuwsgi/pyuwsgi.c
+++ b/plugins/pyuwsgi/pyuwsgi.c
@@ -1,75 +1,325 @@
 #include "../python/uwsgi_python.h"
 
+//FIXME: [upstream:python] needs PyAPI_FUNC(void)
+extern void Py_GetArgcArgv(int *, char ***);
+
 extern struct uwsgi_server uwsgi;
 extern struct uwsgi_python up;
 
 extern char **environ;
 
-PyObject *u_run(PyObject *self, PyObject *args) {
+static int new_argc = -1;
+static int orig_argc = -1;
+static char **new_argv = NULL;
+static char **orig_argv = NULL;
+static char *new_argv_buf = NULL;
 
-        char **argv;
-        size_t size = 2;
-        int i;
 
-        if (PyTuple_Size(args) < 1) {
-		return PyErr_Format(PyExc_ValueError, "you have to specify at least one uWSGI option to run() it");
-	}
+PyObject *
+pyuwsgi_setup(PyObject *self, PyObject *args, PyObject *kwds)
+{
+    if (new_argv) {
+        PyErr_SetString(
+            PyExc_RuntimeError,
+            "uWSGI already setup"
+            );
+        return NULL;
+    }
 
-	PyObject *the_arg = PyTuple_GetItem(args, 0);
+    if (uwsgi.mywid) {
+        PyErr_SetString(
+            PyExc_RuntimeError,
+            "uWSGI must be setup by master"
+            );
+        return NULL;
+    }
 
-	if (PyList_Check(the_arg)) {
-        	size = PyList_Size(the_arg) + 2;
-	}
-	else if (PyTuple_Check(the_arg)) {
-        	size = PyTuple_Size(the_arg) + 2;
-	}
-	else if (PyString_Check(the_arg)) {
-		size = 3;
-	}
+    PyObject *iterator;
 
-        argv = uwsgi_malloc(sizeof(char *) * size);
-        memset(argv, 0, sizeof(char *) * size);
+    if (args == NULL || PyObject_Size(args) == 0) {
+        PyObject *argv = PySys_GetObject("argv");
+        if (argv == NULL)
+            return NULL;
 
-        // will be overwritten
-        argv[0] = "uwsgi";
+        // during site.py maybe
+        if (argv == Py_None) {
+            argv = PyTuple_New(0);
+            iterator = PyObject_GetIter(argv);
+            Py_DECREF(argv);
+        }
+        else {
+            iterator = PyObject_GetIter(argv);
+            if (PyObject_Size(argv) > 0) {
+                // forward past argv0
+                PyObject *item = PyIter_Next(iterator);
+                Py_DECREF(item);
+            }
+        }
+    }
+    else if (
+        PyObject_Size(args) == 1
+        && !PyString_Check(PyTuple_GetItem(args, 0))
+        ) {
+        iterator = PyObject_GetIter(PyTuple_GetItem(args, 0));
+    }
+    else {
+        iterator = PyObject_GetIter(args);
+    }
 
-	if (PyList_Check(the_arg)) {
-        	for(i=0;i<PyList_Size(the_arg);i++) {
-                	argv[i+1] = PyString_AsString( PyList_GetItem(the_arg, i) );
-        	}
-	}
-	else if (PyTuple_Check(the_arg)) {
-        	for(i=0;i<PyTuple_Size(the_arg);i++) {
-                	argv[i+1] = PyString_AsString( PyTuple_GetItem(the_arg, i) );
-        	}
-	}
-	else if (PyString_Check(the_arg)) {
-		argv[1] = PyString_AsString( the_arg );
-	}
+    if (iterator == NULL) {
+        return NULL;
+    }
+
+    size_t size = 1;
+    //FIXME: ARGS prior to and including -c/-m are REQUIRED!
+    PyObject *item = PyString_FromString(orig_argv[0]);
+    PyObject *args_li = PyList_New(0);
+    PyList_Append(args_li, item);
+    size += strlen(orig_argv[0]) + 1;
+    Py_DECREF(item);
+
+    while ((item = PyIter_Next(iterator))) {
+        //TODO: call str(...) on everything
+        PyList_Append(args_li, item);
+        size += PyObject_Length(item) + 1;
+        Py_DECREF(item);
+    }
+
+    Py_DECREF(iterator);
+
+    new_argc = PyObject_Length(args_li);
+    new_argv = uwsgi_calloc(sizeof(char *) * (new_argc + 1));
+    new_argv_buf = uwsgi_calloc(size);
+
+    int i = 0;
+    char *new_argv_ptr = new_argv_buf;
+    for(i=0; i < new_argc; i++) {
+        PyObject *arg = PyList_GetItem(args_li, i);
+        char *arg_str = PyString_AsString(arg);
+        new_argv[i] = new_argv_ptr;
+        strcpy(new_argv_ptr, arg_str);
+        new_argv_ptr += strlen(arg_str) + 1;
+    }
+
+    PyObject *args_tup = PyList_AsTuple(args_li);
+    PyObject_SetAttrString(self, "NEW_ARGV", args_tup);
+    Py_DECREF(args_tup);
+    Py_DECREF(args_li);
+
+    // TODO: convention here is a goto methinks?
+    if (PyErr_Occurred()) {
+        free(new_argv_buf);
+        free(new_argv);
+        new_argv = 0;
+        new_argc = 0;
+        return NULL;
+    }
 
-        uwsgi_init(size-1, argv, environ);
+    //TODO: ...???
+    // actually do the thing!
+    PyThreadState *_tstate = PyThreadState_Get();
+    uwsgi_setup(orig_argc, orig_argv, environ);
+    PyThreadState_Swap(_tstate);
 
-        Py_INCREF(Py_None);
-        return Py_None;
+    Py_INCREF(self);
+    return self;
 }
 
+
+PyObject *
+pyuwsgi_init(PyObject *self, PyObject *args, PyObject *kwds)
+{
+    if (pyuwsgi_setup(self, args, kwds) == NULL) {
+        return NULL;
+    }
+
+    int rc = uwsgi_run();
+
+    // never(?) here
+    return Py_BuildValue("i", rc);
+}
+
+
+PyObject *
+pyuwsgi_run(PyObject *self, PyObject *args, PyObject *kwds)
+{
+    // backcompat
+    if (new_argv == NULL &&
+        pyuwsgi_setup(self, args, kwds) == NULL) {
+        return NULL;
+    }
+
+    int rc = uwsgi_run();
+
+    // never(?) here
+    return Py_BuildValue("i", rc);
+}
+
+
 PyMethodDef methods[] = {
-    {"run", u_run, METH_VARARGS, "run the uWSGI server"},
+    {"run",
+        (PyCFunction) pyuwsgi_run,
+        METH_VARARGS | METH_KEYWORDS,
+     "run(...)"
+     "\n>>> 0"
+     "\n"
+     "\n * Call setup(...) if not configured"
+     "\n * Begin uWSGI mainloop"
+     "\n   NOTE: will not return"
+     "\n"
+    },
+    {"init",
+        (PyCFunction) pyuwsgi_init,
+        METH_VARARGS | METH_KEYWORDS,
+     "init(...)"
+     "\n>>> 0"
+     "\n"
+     "\n * Call setup(...)"
+     "\n * Begin uWSGI mainloop"
+     "\n   NOTE: will not return"
+     "\n"
+    },
+    {"setup",
+        (PyCFunction) pyuwsgi_setup,
+        METH_VARARGS | METH_KEYWORDS,
+     "setup('--master', ...)"
+     "\n>>> <module 'uwsgi' from \"uwsgi.so\">"
+     "\n"
+     "\n * Initialize uWSGI core with (...)"
+     "\n   MUST only call once          [RuntimeException]"
+     "\n   MUST only call from master   [RuntimeException]"
+     "\n"
+    },
     {NULL, NULL, 0, NULL}
 };
 
+
+static void
+pyuwsgi_set_orig_argv(PyObject *self)
+{
+
+    //  ask python for the original argc/argv saved in Py_Main()
+    Py_GetArgcArgv(&orig_argc, &orig_argv);
+
+    //  [re?]export to uwsgi.orig_argv
+    PyObject *m_orig_argv;
+    m_orig_argv = PyTuple_New(orig_argc);
+
+    int i = 0;
+    int i_cm = -1;
+
+    for(i=0; i < orig_argc; i++) {
+        char *arg = orig_argv[i];
+        //XXX: _PyOS_optarg != 0 also indicates python quit early...
+        //FIXME: [upstream:python] orig_argv could be mangled; reset
+        // rel: http://bugs.python.org/issue8202
+        orig_argv[i + 1] = arg + strlen(arg) + 1;
+
+        // look for -c or -m and record the offset
+        if (i_cm < 0) {
+            if (strcmp(arg, "-c") || strcmp(arg, "-m")) {
+                // python's getopt would've failed had + 1 not exist
+                i_cm = i + 1;
+            }
+            else if (!uwsgi_startswith(arg, "-c", 2) ||
+                     !uwsgi_startswith(arg, "-m", 2)) {
+                //FIXME: ARGS prior to and including -c/-m are REQUIRED,
+                // but NOT a part of the uWSGI argv! Needed to make
+                // exec*() self-referential: exec*(...) -> uwsgi
+                //
+                // want: uwsgi.binary_argv[:] + uwsgi.argv[:]!
+                //       binary_argv = [binary_path] + args
+                i_cm = i;
+            }
+        }
+
+        PyTuple_SetItem(m_orig_argv, i, PyString_FromString(arg));
+    }
+
+    //TODO: howto properly detect uwsgi already running...
+    // orig_argv == uwsgi.orig_argv (?)
+    // ^^^ but if Py_Main not called, python/main.c:orig_argv unset
+    // howto interact/detect things in general
+    PyObject *m_new_argv = PyTuple_New(0);
+    PyObject_SetAttrString(self, "NEW_ARGV", m_new_argv);
+    PyObject_SetAttrString(self, "ORIG_ARGV", m_orig_argv);
+    Py_DECREF(m_new_argv);
+    Py_DECREF(m_orig_argv);
+}
+
+
+static PyObject *
+pyuwsgi_init_as(char *mod_name)
+{
+
+    PyObject *m;
+
+    m = PyImport_GetModuleDict();
+    if (m == NULL) {
+        return NULL;
+    }
+
+    m = PyDict_GetItemString(m, mod_name);
+    if (!m) {
+        m = Py_InitModule(mod_name, NULL);
+	}
+
+    if (orig_argc < 0) {
+        pyuwsgi_set_orig_argv(m);
+    }
+
+    int i;
+    for (i=0; methods[i].ml_name != NULL; i++) {
+        PyObject *fun = PyObject_GetAttrString(m, methods[i].ml_name);
+        if (fun != NULL) {
+            // already exists
+            Py_DECREF(fun);
+            continue;
+        }
+
+        PyErr_Clear();
+
+        //  rel: Python/modsupport.c:Py_InitModule4
+        PyObject* name = PyString_FromString(methods[i].ml_name);
+        //  fun(self, ...)
+        fun = PyCFunction_NewEx(&methods[i], m, name);
+        Py_DECREF(name);
+        //  module.fun
+        PyObject_SetAttrString(m, methods[i].ml_name, fun);
+        Py_DECREF(fun);
+    }
+
+    return m;
+}
+
+
 PyMODINIT_FUNC
 initpyuwsgi()
 {
-    (void) Py_InitModule("pyuwsgi", methods);
+    (void) pyuwsgi_init_as("pyuwsgi");
 }
 
 
-int pyuwsgi_init() { return 0; }
+// allow the module to be called `uwsgi`
+PyMODINIT_FUNC
+inituwsgi()
+{
+    (void) pyuwsgi_init_as("uwsgi");
+}
+
+
+void pyuwsgi_load()
+{
+    if (new_argc > -1) {
+        uwsgi.new_argc = new_argc;
+        uwsgi.new_argv = new_argv;
+    }
+}
+
 
 struct uwsgi_plugin pyuwsgi_plugin = {
 
         .name = "pyuwsgi",
-        .init = pyuwsgi_init,
+        .on_load = pyuwsgi_load,
 };
 
diff --git a/plugins/rack/rack_api.c b/plugins/rack/rack_api.c
index 465860e..6a1396e 100644
--- a/plugins/rack/rack_api.c
+++ b/plugins/rack/rack_api.c
@@ -110,7 +110,8 @@ static VALUE rack_uwsgi_warning(VALUE *class, VALUE rbmessage) {
 
 static VALUE rack_uwsgi_user_harakiri(VALUE *class, VALUE sec) {
         Check_Type(sec, T_FIXNUM);
-	set_user_harakiri(NUM2INT(sec));
+	struct wsgi_request *wsgi_req = current_wsgi_req();
+	set_user_harakiri(wsgi_req, NUM2INT(sec));
         return Qnil;
 }
 
@@ -765,10 +766,10 @@ static VALUE uwsgi_ruby_signal_wait(int argc, VALUE *argv, VALUE *class) {
         }
 
         if (wait_for_specific_signal) {
-                received_signal = uwsgi_signal_wait(uwsgi_signal);
+                received_signal = uwsgi_signal_wait(wsgi_req, uwsgi_signal);
         }
         else {
-                received_signal = uwsgi_signal_wait(-1);
+                received_signal = uwsgi_signal_wait(wsgi_req, -1);
         }
 
 	if (received_signal < 0) {
@@ -969,7 +970,6 @@ static int rack_uwsgi_build_spool(VALUE rbkey, VALUE rbval, VALUE argv) {
 
 static VALUE rack_uwsgi_send_spool(VALUE *class, VALUE args) {
 
-        struct wsgi_request *wsgi_req = current_wsgi_req();
         char *body = NULL;
         size_t body_len= 0;
 
@@ -991,7 +991,7 @@ static VALUE rack_uwsgi_send_spool(VALUE *class, VALUE args) {
 
 	rb_hash_foreach(args, rack_uwsgi_build_spool, (VALUE) ub); 
 
-        char *filename = uwsgi_spool_request(wsgi_req, ub->buf, ub->pos, body, body_len);
+        char *filename = uwsgi_spool_request(NULL, ub->buf, ub->pos, body, body_len);
 
 	uwsgi_buffer_destroy(ub);
 
diff --git a/plugins/rack/rack_plugin.c b/plugins/rack/rack_plugin.c
index bab2e2a..2719db7 100644
--- a/plugins/rack/rack_plugin.c
+++ b/plugins/rack/rack_plugin.c
@@ -814,7 +814,7 @@ int uwsgi_rack_request(struct wsgi_request *wsgi_req) {
 	}
 
 	/* Standard RACK request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log("Empty RACK request. skip.\n");
                 return -1;
         }
diff --git a/plugins/rados/rados.c b/plugins/rados/rados.c
index 21542c4..b8eb390 100644
--- a/plugins/rados/rados.c
+++ b/plugins/rados/rados.c
@@ -6,27 +6,56 @@ extern struct uwsgi_server uwsgi;
 /*
 
 	Author: Javier Guerra
+	Author: Marcin Deranek
+	Author: Roberto De Ioris
 
-	based on the uWSGI GlusterFS plugin by Roberto De Ioris
-
-	--rados-mount mountpoint=/foo,pool=unbit001,config=/etc/ceph.conf
+	--rados-mount mountpoint=/foo,pool=unbit001,config=/etc/ceph.conf,timeout=30,allow_put=1,allow_delete=1
 
 */
 
 struct uwsgi_plugin rados_plugin;
 
-struct uwsgi_rados {
+// this structure is preallocated (only the pipe part is per-request)
+struct uwsgi_rados_io {
+        int fds[2];
+        // this is increased at every usage (in locked context)
+        uint64_t rid;
+        pthread_mutex_t mutex;
+};
+
+// this structure is allocated for each async transaction
+struct uwsgi_rados_cb {
+        // this is copied from the current uwsgi_rados_io->rid
+        uint64_t rid;
+        struct uwsgi_rados_io *urio;
+};
+
+static struct uwsgi_rados {
 	int timeout;
 	struct uwsgi_string_list *mountpoints;
+	struct uwsgi_rados_io *urio;
 } urados;
 
+struct uwsgi_rados_mountpoint {
+	rados_t cluster;
+	char *mountpoint;
+	char *config;
+	char *pool;
+	char *str_timeout;
+	int timeout;
+	char *allow_put;
+	char *allow_delete;
+	char *allow_mkcol;
+	char *allow_propfind;
+};
+
 static struct uwsgi_option uwsgi_rados_options[] = {
 	{"rados-mount", required_argument, 0, "virtual mount the specified rados volume in a uri", uwsgi_opt_add_string_list, &urados.mountpoints, UWSGI_OPT_MIME},
 	{"rados-timeout", required_argument, 0, "timeout for async operations", uwsgi_opt_set_int, &urados.timeout, 0},
 	{0, 0, 0, 0, 0, 0, 0},
 };
 
-static int uwsgi_rados_read_sync(struct wsgi_request *wsgi_req, rados_ioctx_t *ctx, const char *key, size_t remains) {
+static int uwsgi_rados_read_sync(struct wsgi_request *wsgi_req, rados_ioctx_t ctx, const char *key, size_t remains) {
 	uint64_t off = 0;
 	while(remains > 0) {
 		char buf[8192];
@@ -39,119 +68,434 @@ static int uwsgi_rados_read_sync(struct wsgi_request *wsgi_req, rados_ioctx_t *c
 	return 0;
 }
 
-/*
-	async read of a resource
-	the uwsgi_rados_async_io structure is passed between threads
-	the callback simply signal the main core about the availability of data
-*/
-struct uwsgi_rados_async_io {
-	int fd[2];
-	ssize_t rlen;
-};
-
+// callback used to asynchronously signal the completion
 static void uwsgi_rados_read_async_cb(rados_completion_t comp, void *data) {
-	struct uwsgi_rados_async_io *aio = (struct uwsgi_rados_async_io *) data;
-#ifdef UWSGI_DEBUG
-	uwsgi_log("[rados-cb] rlen = %d\n", rlen);
-#endif
-	aio->rlen = rados_aio_get_return_value(comp);
-	// signal the core
-	if (write(aio->fd[1], "\1", 1) <= 0) {
-		uwsgi_error("uwsgi_rados_read_async_cb()/write()");
+	struct uwsgi_rados_cb *urcb = (struct uwsgi_rados_cb *) data;
+	struct uwsgi_rados_io *urio = urcb->urio;
+
+	pthread_mutex_lock(&urio->mutex);
+	if (urcb->rid != urio->rid) {
+		uwsgi_log_verbose("[uwsgi-rados] callback %llu woke up too late\n", (unsigned long long) urcb->rid);
 	}
+	else {
+		// signal the core
+		if (write(urio->fds[1], "\1", 1) <= 0) {
+			uwsgi_error("uwsgi_rados_read_async_cb()/write()");
+		}
+	}
+
+	pthread_mutex_unlock(&urio->mutex);
+
+	free(urcb);
 }
 
+static int uwsgi_rados_delete(struct wsgi_request *wsgi_req, rados_ioctx_t ctx, char *key, int timeout) {
+	if (uwsgi.async < 1) {
+		return rados_remove(ctx, key); 
+	}
+	struct uwsgi_rados_io *urio = &urados.urio[wsgi_req->async_id];
+	int ret = -1;
+        // increase request counter
+        pthread_mutex_lock(&urio->mutex);
+        urio->rid++;
+        pthread_mutex_unlock(&urio->mutex);
+
+        struct uwsgi_rados_cb *urcb = uwsgi_malloc(sizeof(struct uwsgi_rados_cb));
+        // map the current request id to the callback
+        urcb->rid = urio->rid;
+        // map urio to the callback
+        urcb->urio = urio;
+
+        rados_completion_t comp;
+	// we use the safe cb here
+        if (rados_aio_create_completion(urcb, NULL, uwsgi_rados_read_async_cb, &comp) < 0) {
+                free(urcb);
+                goto end;
+        }
+        if (rados_aio_remove(ctx, key, comp) < 0) {
+                free(urcb);
+                rados_aio_release(comp);
+                goto end;
+        }
+
+        // wait for the callback to be executed
+        if (uwsgi.wait_read_hook(urio->fds[0], timeout) <= 0) {
+                rados_aio_release(comp);
+                goto end;
+        }
+        char ack = 1;
+        if (read(urio->fds[0], &ack, 1) != 1) {
+                rados_aio_release(comp);
+                uwsgi_error("uwsgi_rados_delete()/read()");
+                goto end;
+        }
+
+        if (rados_aio_is_safe_and_cb(comp)) {
+                ret = rados_aio_get_return_value(comp);
+        }
+        rados_aio_release(comp);
+end:
+      	return ret;
+}
 
-static int uwsgi_rados_read_async(struct wsgi_request *wsgi_req, rados_ioctx_t *ctx, const char *key, size_t remains) {
+static int uwsgi_rados_put(struct wsgi_request *wsgi_req, rados_ioctx_t ctx, char *key, int timeout) {
+	struct uwsgi_rados_io *urio = &urados.urio[wsgi_req->async_id];
+	size_t remains = wsgi_req->post_cl;
 	uint64_t off = 0;
-	char buf[8192];
-	struct uwsgi_rados_async_io aio;
+        while(remains > 0) {
+                ssize_t body_len = 0;
+                char *body =  uwsgi_request_body_read(wsgi_req, UMIN(remains, 32768) , &body_len);
+                if (!body || body == uwsgi.empty) goto error;
+		if (uwsgi.async < 1) {
+			if (rados_write_full(ctx, key, body, body_len) < 0) {
+				return -1;
+			}
+		}
+		else {
+			// increase request counter
+        		pthread_mutex_lock(&urio->mutex);
+        		urio->rid++;
+        		pthread_mutex_unlock(&urio->mutex);
+
+			struct uwsgi_rados_cb *urcb = uwsgi_malloc(sizeof(struct uwsgi_rados_cb));
+        		// map the current request id to the callback
+        		urcb->rid = urio->rid;
+        		// map urio to the callback
+        		urcb->urio = urio;
+
+        		rados_completion_t comp;
+			// use safe for write
+        		if (rados_aio_create_completion(urcb, NULL, uwsgi_rados_read_async_cb, &comp) < 0) {
+                		free(urcb);
+                		goto error;
+        		}
+        		if (rados_aio_write_full(ctx, key, comp, body, body_len) < 0) {
+                		free(urcb);
+                		rados_aio_release(comp);
+                		goto error;
+        		}
+
+        		// wait for the callback to be executed
+        		if (uwsgi.wait_read_hook(urio->fds[0], timeout) <= 0) {
+                		rados_aio_release(comp);
+                		goto error;
+        		}
+        		char ack = 1;
+        		if (read(urio->fds[0], &ack, 1) != 1) {
+                		rados_aio_release(comp);
+                		uwsgi_error("uwsgi_rados_read_async()/read()");
+                		goto error;
+        		}
+
+        		if (rados_aio_is_safe_and_cb(comp)) {
+                		if (rados_aio_get_return_value(comp) < 0) {
+                			rados_aio_release(comp);
+					goto error;
+				}
+				
+        		}
+        		rados_aio_release(comp);
+		}
+		remains -= body_len;
+		off += body_len;
+        }	
+
+	return 0;
+
+error:
+	return -1;
+}
+
+// async stat
+static int uwsgi_rados_async_stat(struct uwsgi_rados_io *urio, rados_ioctx_t ctx, const char *key, uint64_t *stat_size, time_t *stat_mtime, int timeout) {
 	int ret = -1;
-	if (pipe(aio.fd)) {
-		uwsgi_error("uwsgi_rados_read_async()/pipe()");
-		return -1;
-	}
-	aio.rlen = -1;
+        // increase request counter
+        pthread_mutex_lock(&urio->mutex);
+        urio->rid++;
+        pthread_mutex_unlock(&urio->mutex);
+
+	struct uwsgi_rados_cb *urcb = uwsgi_malloc(sizeof(struct uwsgi_rados_cb));
+        // map the current request id to the callback
+        urcb->rid = urio->rid;
+        // map urio to the callback
+        urcb->urio = urio;
+
 	rados_completion_t comp;
-	if (rados_aio_create_completion(&aio, uwsgi_rados_read_async_cb, NULL, &comp) < 0) goto end;
-	
+	if (rados_aio_create_completion(urcb, uwsgi_rados_read_async_cb, NULL, &comp) < 0) {
+        	free(urcb);
+		goto end;
+	}
+	if (rados_aio_stat(ctx, key, comp, stat_size, stat_mtime) < 0) {
+		free(urcb);
+                rados_aio_release(comp);
+		goto end;
+	}	
+
+	// wait for the callback to be executed
+        if (uwsgi.wait_read_hook(urio->fds[0], timeout) <= 0) {
+        	rados_aio_release(comp);
+		goto end;
+        }
+        char ack = 1;
+        if (read(urio->fds[0], &ack, 1) != 1) {
+        	rados_aio_release(comp);
+                uwsgi_error("uwsgi_rados_read_async()/read()");
+		goto end;
+        }
+
+	if (rados_aio_is_complete_and_cb(comp)) {
+        	ret = rados_aio_get_return_value(comp);
+        }
+        rados_aio_release(comp);
+
+end:
+	return ret;
+}
+
+static int uwsgi_rados_read_async(struct wsgi_request *wsgi_req, rados_ioctx_t ctx, const char *key, size_t remains, int timeout) {
+	uint64_t off = 0;
+	int ret = -1;
+	char buf[8192];
+
+	struct uwsgi_rados_io *urio = &urados.urio[wsgi_req->async_id];
+	// increase request counter
+	pthread_mutex_lock(&urio->mutex);
+	urio->rid++;
+	pthread_mutex_unlock(&urio->mutex);
+
 	while(remains > 0) {
+		struct uwsgi_rados_cb *urcb = uwsgi_malloc(sizeof(struct uwsgi_rados_cb));
+		// map the current request id to the callback
+		urcb->rid = urio->rid;
+		// map urio to the callback
+		urcb->urio = urio;
+
+
+		rados_completion_t comp;
+		if (rados_aio_create_completion(urcb, uwsgi_rados_read_async_cb, NULL, &comp) < 0) {
+			free(urcb);
+			break;
+		}
 		// trigger an async read
-		if (rados_aio_read(ctx, key, comp, buf, 8192, off) < 0) goto end;
+		if (rados_aio_read(ctx, key, comp, buf, UMIN(remains, 8192), off) < 0) {
+			free(urcb);
+			rados_aio_release(comp);
+			break;
+		}
 		// wait for the callback to be executed
-		if (uwsgi.wait_read_hook(aio.fd[0], urados.timeout) <= 0) goto end;
-		if (aio.rlen <= 0) goto end;	
-		if (uwsgi_response_write_body_do(wsgi_req, buf, aio.rlen)) goto end;
-		remains -= aio.rlen;
+		if (uwsgi.wait_read_hook(urio->fds[0], timeout) <= 0) {
+			rados_aio_release(comp);
+			break;
+		}
+		char ack = 1;
+		if (read(urio->fds[0], &ack, 1) != 1) {
+			rados_aio_release(comp);
+			uwsgi_error("uwsgi_rados_read_async()/read()");
+			break;
+		}
+		int rlen = -1;	
+		if (rados_aio_is_complete_and_cb(comp)) {
+			rlen = rados_aio_get_return_value(comp);
+		}
+		rados_aio_release(comp);
+		if (rlen <= 0) break;
+		if (uwsgi_response_write_body_do(wsgi_req, buf, rlen)) break;
+		remains -= rlen;
+		off += rlen;
 	}
-	ret = 0;
-end:
-	rados_aio_release(&comp);
-	close(aio.fd[0]);
-	close(aio.fd[1]);
+
+	if (remains == 0) ret = 0;
+
+	pthread_mutex_lock(&urio->mutex);
+	// increase the counter again
+	urio->rid++;
+	pthread_mutex_unlock(&urio->mutex);
 	return ret;	
 }
 
+static void uwsgi_rados_propfind(struct wsgi_request *wsgi_req, rados_ioctx_t ctx, char *key, uint64_t size, time_t mtime, int timeout) {
+	// consume the body
+	size_t remains = wsgi_req->post_cl;
+        while(remains > 0) {
+                ssize_t body_len = 0;
+                char *body =  uwsgi_request_body_read(wsgi_req, UMIN(remains, 32768), &body_len);
+                if (!body || body == uwsgi.empty) break;
+		remains -= body_len;
+	}
+
+	if (uwsgi_response_prepare_headers(wsgi_req, "207 Multi-Status", 16)) return;
+	if (uwsgi_response_add_content_type(wsgi_req, "text/xml; charset=\"utf-8\"", 25)) return;
+	struct uwsgi_buffer *ub = uwsgi_webdav_multistatus_new();
+	if (!ub) return;
+	if (key) {
+		size_t mime_type_len = 0;
+        	char *mime_type = uwsgi_get_mime_type(key, strlen(key), &mime_type_len);
+		char *slashed = uwsgi_concat2("/", key);
+		if (uwsgi_webdav_propfind_item_add(ub, slashed, strlen(key)+1, size, mtime, mime_type, mime_type_len, NULL, 0, NULL, 0)) {
+			free(slashed);
+			goto end;
+		}
+		free(slashed);
+		if (uwsgi_webdav_multistatus_close(ub)) goto end;
+		uwsgi_response_write_body_do(wsgi_req, ub->buf, ub->pos);
+		goto end;
+	}
+	// request for /
+	size_t depth = 0;
+	uint16_t http_depth_len = 0;
+        char *http_depth = uwsgi_get_var(wsgi_req, "HTTP_DEPTH", 10, &http_depth_len);
+        if (http_depth) {
+                depth = uwsgi_str_num(http_depth, http_depth_len);
+        }
+
+	if (depth == 0) {
+		if (uwsgi_webdav_propfind_item_add(ub, "/", 1, 0, 0, NULL, 0, NULL, 0, NULL, 0)) {
+                        goto end;
+                }
+                if (uwsgi_webdav_multistatus_close(ub)) goto end;
+                uwsgi_response_write_body_do(wsgi_req, ub->buf, ub->pos);
+		goto end;
+	}
+
+	struct uwsgi_rados_io *urio = &urados.urio[wsgi_req->async_id];
+	rados_list_ctx_t ctx_list;
+	if (rados_objects_list_open(ctx, &ctx_list) < 0) {
+		goto end;
+	}
+
+	char *entry = NULL;
+	while(rados_objects_list_next(ctx_list, (const char **)&entry, NULL) == 0) {
+		uint64_t stat_size = 0;
+		time_t stat_mtime = 0;
+		if (uwsgi.async > 0) {
+        		if (uwsgi_rados_async_stat(urio, ctx, entry, &stat_size, &stat_mtime, timeout) < 0) goto end;
+        	}
+        	else {
+                	if (rados_stat(ctx, entry, &stat_size, &stat_mtime) < 0) goto end;
+        	}
+
+		size_t mime_type_len = 0;
+                char *mime_type = uwsgi_get_mime_type(entry, strlen(entry), &mime_type_len);
+                char *slashed = uwsgi_concat2("/", entry);
+                if (uwsgi_webdav_propfind_item_add(ub, slashed, strlen(entry)+1, stat_size, stat_mtime, mime_type, mime_type_len, NULL, 0, NULL, 0)) {
+                        free(slashed);
+                        goto end;
+                }
+                free(slashed);
+                if (uwsgi_response_write_body_do(wsgi_req, ub->buf, ub->pos)) goto end;
+		// reset buffer;
+		ub->pos = 0;
+	}
+	rados_objects_list_close(ctx_list);
+        if (uwsgi_webdav_multistatus_close(ub)) goto end;
+        uwsgi_response_write_body_do(wsgi_req, ub->buf, ub->pos);
+
+end:
+	uwsgi_buffer_destroy(ub);
+}
 
 static void uwsgi_rados_add_mountpoint(char *arg, size_t arg_len) {
-	char *rad_mountpoint = NULL;
-	char *rad_config = NULL;
-	char *rad_poolname = NULL;
+	struct uwsgi_rados_mountpoint *urmp = uwsgi_calloc(sizeof(struct uwsgi_rados_mountpoint));
 	if (uwsgi_kvlist_parse(arg, arg_len, ',', '=',
-			"mountpoint", &rad_mountpoint,
-			"config", &rad_config,
-			"pool", &rad_poolname,
+			"mountpoint", &urmp->mountpoint,
+			"config", &urmp->config,
+			"pool", &urmp->pool,
+			"timeout", &urmp->str_timeout,
+			"allow_put", &urmp->allow_put,
+			"allow_delete", &urmp->allow_delete,
+			"allow_mkcol", &urmp->allow_mkcol,
+			"allow_propfind", &urmp->allow_propfind,
 			NULL)) {
 				uwsgi_log("unable to parse rados mountpoint definition\n");
 				exit(1);
 		}
 
-	if (!rad_mountpoint|| !rad_poolname) {
+	if (!urmp->mountpoint|| !urmp->pool) {
 		uwsgi_log("[rados] mount requires a mountpoint, and a pool name.\n");
 		exit(1);
 	}
+
+	if (urmp->str_timeout) {
+		urmp->timeout = atoi(urmp->str_timeout);
+	}
+
 	time_t now = uwsgi_now();
-	uwsgi_log("[rados] mounting %s ...\n", rad_mountpoint);
+	uwsgi_log("[rados] mounting %s ...\n", urmp->mountpoint);
 	
 	rados_t cluster;
 	if (rados_create(&cluster, NULL) < 0) {
-		uwsgi_error("Can't create Ceph cluster handle");
+		uwsgi_error("can't create Ceph cluster handle");
 		exit(1);
 	}
-	if (rad_config)
-		uwsgi_log("Using Ceph conf:%s\n", rad_config);
+	urmp->cluster = cluster;
+
+	if (urmp->config)
+		uwsgi_log("using Ceph conf:%s\n", urmp->config);
 	else
-		uwsgi_log("Using default Ceph conf.\n");
-	if (rados_conf_read_file(cluster, rad_config) < 0) {
-		uwsgi_error("Can't configure Ceph cluster handle");
+		uwsgi_log("using default Ceph conf.\n");
+
+	if (rados_conf_read_file(cluster, urmp->config) < 0) {
+		uwsgi_error("can't configure Ceph cluster handle");
 		exit(1);
 	}
+
+	int timeout = urmp->timeout ? urmp->timeout : urados.timeout;
+	char *timeout_str = uwsgi_num2str(timeout);
+
+	rados_conf_set(cluster, "client_mount_timeout", timeout_str);
+	rados_conf_set(cluster, "rados_mon_op_timeout", timeout_str);
+	rados_conf_set(cluster, "rados_osd_op_timeout", timeout_str);
+
+	free(timeout_str);
+
+
 	if (rados_connect(cluster) < 0) {
-		uwsgi_error("Can't connect with Ceph cluster");
+		uwsgi_error("can't connect with Ceph cluster");
 		exit(1);
 	}
-	
-	rados_ioctx_t ctx;
-	uwsgi_log("Ceph pool: %s\n", rad_poolname);
-	if (rados_ioctx_create(cluster, rad_poolname, &ctx) < 0) {
-		uwsgi_error("Can't open rados pool")
-		rados_shutdown(cluster);
-		exit(1);
+
+
+	void *ctx_ptr;
+
+	if (uwsgi.threads > 1) {
+		int i;
+		rados_ioctx_t *ctxes = uwsgi_calloc(sizeof(rados_ioctx_t) * uwsgi.threads);
+		for(i=0;i<uwsgi.threads;i++) {
+			if (rados_ioctx_create(cluster, urmp->pool, &ctxes[i]) < 0) {
+                        	uwsgi_error("can't open rados pool")
+                        	rados_shutdown(cluster);
+                        	exit(1);
+			}
+                }
+		ctx_ptr = ctxes;
 	}
+	else {
+		rados_ioctx_t ctx;
+		if (rados_ioctx_create(cluster, urmp->pool, &ctx) < 0) {
+			uwsgi_error("can't open rados pool")
+			rados_shutdown(cluster);
+			exit(1);
+		}
+		ctx_ptr = ctx;
+	}
+
+	char fsid[37];
+	rados_cluster_fsid(cluster, fsid, 37);
+	uwsgi_log("connected to Ceph pool: %s on cluster %.*s\n", urmp->pool, 37, fsid);
 	
 	int id = uwsgi_apps_cnt;
-	struct uwsgi_app *ua = uwsgi_add_app(id, rados_plugin.modifier1, rad_mountpoint, strlen(rad_mountpoint), NULL, NULL);
+	struct uwsgi_app *ua = uwsgi_add_app(id, rados_plugin.modifier1, urmp->mountpoint, strlen(urmp->mountpoint), NULL, NULL);
 	if (!ua) {
-		uwsgi_log("[rados] unable to mount %s\n", rad_mountpoint);
+		uwsgi_log("[rados] unable to mount %s\n", urmp->mountpoint);
 		rados_shutdown(cluster);
 		exit(1);
 	}
 
-	ua->responder0 = cluster;
-	ua->responder1 = ctx;
+	ua->responder0 = ctx_ptr;
+	ua->responder1 = urmp;
 	ua->started_at = now;
 	ua->startup_time = uwsgi_now() - now;
-	uwsgi_log("Rados app/mountpoint %d (%s) loaded in %d seconds at %p\n", id, rad_mountpoint, (int) ua->startup_time, ctx);
+	uwsgi_log("Rados app/mountpoint %d (%s) loaded in %d seconds at %p\n", id, urmp->mountpoint, (int) ua->startup_time, ctx_ptr);
 }
 
 // we translate the string list to an app representation
@@ -166,11 +510,26 @@ static void uwsgi_rados_setup() {
 		uwsgi_rados_add_mountpoint(usl->value, usl->len);
 		usl = usl->next;
 	}
+
+	// now initialize a pthread_mutex for each async core
+	if (uwsgi.async > 0) {
+		int i;
+		urados.urio = uwsgi_calloc(sizeof(struct uwsgi_rados_io) * uwsgi.async);
+		for(i=0;i<uwsgi.async;i++) {
+			urados.urio[i].fds[0] = -1;
+			urados.urio[i].fds[1] = -1;
+			if (pthread_mutex_init(&urados.urio[i].mutex, NULL)) {
+				uwsgi_error("uwsgi_rados_setup()/pthread_mutex_init()");
+				exit(1);
+			}
+		}
+	}
+	
 }
 
 static int uwsgi_rados_request(struct wsgi_request *wsgi_req) {
 	char filename[PATH_MAX+1];
-	if (!wsgi_req->uh->pktsize) {
+	if (!wsgi_req->len) {
 		uwsgi_log( "Empty request. skip.\n");
 		return -1;
 	}
@@ -199,29 +558,171 @@ static int uwsgi_rados_request(struct wsgi_request *wsgi_req) {
 	struct uwsgi_app *ua = &uwsgi_apps[wsgi_req->app_id];
 
 	if (wsgi_req->path_info_len > ua->mountpoint_len &&
-		memcmp(wsgi_req->path_info, ua->mountpoint, ua->mountpoint_len) == 0) 
-	{
+		memcmp(wsgi_req->path_info, ua->mountpoint, ua->mountpoint_len) == 0) {
+
 		memcpy(filename, wsgi_req->path_info+ua->mountpoint_len, wsgi_req->path_info_len-ua->mountpoint_len);
+		filename[wsgi_req->path_info_len-ua->mountpoint_len] = 0;
+
 	} else {
 		memcpy(filename, wsgi_req->path_info, wsgi_req->path_info_len);
+		filename[wsgi_req->path_info_len] = 0;
 	}
-	filename[wsgi_req->path_info_len] = 0;
 	
-	struct {
-		uint64_t size;
-		time_t mtime;
-	} st;
-	rados_ioctx_t ctx = ua->responder1;
+	// in multithread mode the memory is different (as we need a ctx for each thread) !!!
+	rados_ioctx_t ctx;
+	if (uwsgi.threads > 1) {
+		rados_ioctx_t *ctxes = (rados_ioctx_t *) ua->responder0;
+		ctx = ctxes[wsgi_req->async_id];
+	}
+	else {
+		ctx = (rados_ioctx_t) ua->responder0;
+	}
+	struct uwsgi_rados_mountpoint *urmp = (struct uwsgi_rados_mountpoint *) ua->responder1;
+	uint64_t stat_size = 0;
+	time_t stat_mtime = 0;
+
+	struct uwsgi_rados_io *urio = &urados.urio[wsgi_req->async_id];
+
+	if (uwsgi.async > 0) {
+	// no need to lock here (the rid protect us)
+        	if (pipe(urio->fds)) {
+                	uwsgi_error("uwsgi_rados_read_async()/pipe()");
+			uwsgi_500(wsgi_req);
+			return UWSGI_OK;
+        	}
+	}
 	
-	int r = rados_stat(ctx, filename, &st.size, &st.mtime);
-	if (r < 0) {
-		if (r == -ENOENT)
+	int ret = -1;
+	int timeout = urmp->timeout ? urmp->timeout : urados.timeout;
+
+	if (!uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "OPTIONS", 7)) {
+		if (uwsgi_response_prepare_headers(wsgi_req, "200 OK", 6)) goto end;
+		if (uwsgi_response_add_header(wsgi_req, "Dav", 3, "1", 1)) goto end;	
+		struct uwsgi_buffer *ub_allow = uwsgi_buffer_new(64);
+		if (uwsgi_buffer_append(ub_allow, "OPTIONS, GET, HEAD", 18)) {
+			uwsgi_buffer_destroy(ub_allow);
+			goto end;
+		}
+		if (urmp->allow_put) {
+			if (uwsgi_buffer_append(ub_allow, ", PUT", 5)) {
+				uwsgi_buffer_destroy(ub_allow);
+				goto end;
+			}
+		}
+		if (urmp->allow_delete) {
+			if (uwsgi_buffer_append(ub_allow, ", DELETE", 8)) {
+				uwsgi_buffer_destroy(ub_allow);
+				goto end;
+			}
+		}
+		if (urmp->allow_mkcol) {
+			if (uwsgi_buffer_append(ub_allow, ", MKCOL", 7)) {
+				uwsgi_buffer_destroy(ub_allow);
+				goto end;
+			}
+		}
+		if (urmp->allow_propfind) {
+			if (uwsgi_buffer_append(ub_allow, ", PROPFIND", 10)) {
+				uwsgi_buffer_destroy(ub_allow);
+				goto end;
+			}
+		}
+
+		uwsgi_response_add_header(wsgi_req, "Allow", 5, ub_allow->buf, ub_allow->pos);
+		uwsgi_buffer_destroy(ub_allow);
+                goto end;
+	}
+
+	// empty paths are mapped to propfind
+	if (wsgi_req->path_info_len == 1 && wsgi_req->path_info[0] == '/') {
+		if (urmp->allow_propfind && !uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "PROPFIND", 8)) {
+			uwsgi_rados_propfind(wsgi_req, ctx, NULL, 0, 0, timeout);
+			goto end;
+		}
+                uwsgi_405(wsgi_req);
+		goto end;
+	}
+
+	// MKCOL does not require stat
+	if (!uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "MKCOL", 5)) {
+                if (!urmp->allow_mkcol) {
+                        uwsgi_405(wsgi_req);
+                        goto end;
+                }
+                ret = rados_pool_create(urmp->cluster, filename);
+		if (ret < 0) {
+			if (ret == -EEXIST) {
+                        	uwsgi_405(wsgi_req);
+			}
+			else {
+                        	uwsgi_500(wsgi_req);
+			}
+                        goto end;
+                }
+                uwsgi_response_prepare_headers(wsgi_req, "201 Created", 11);
+                goto end;
+	}
+
+	if (uwsgi.async > 0) {
+		ret = uwsgi_rados_async_stat(urio, ctx, filename, &stat_size, &stat_mtime, timeout);	
+	}
+	else {
+		ret = rados_stat(ctx, filename, &stat_size, &stat_mtime);
+	}
+
+	// PUT AND MKCOL can be used for non-existent objects
+	if (!uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "PUT", 3)) {
+		if (!urmp->allow_put) {
+			uwsgi_405(wsgi_req);
+			goto end;
+		}
+		if (ret == 0) {
+			if (uwsgi_rados_delete(wsgi_req, ctx, filename, timeout)) {
+				uwsgi_500(wsgi_req);
+				goto end;
+			}
+		}	
+		if (uwsgi_rados_put(wsgi_req, ctx, filename, timeout)) {
+			uwsgi_500(wsgi_req);
+			goto end;
+		}
+		uwsgi_response_prepare_headers(wsgi_req, "201 Created", 11);	
+		goto end;
+	}
+	else if (ret < 0) {
+		if (ret == -ENOENT)
 			uwsgi_404(wsgi_req);
 		else
 			uwsgi_403(wsgi_req);
-		return UWSGI_OK;
+		goto end;
+	}
+
+	if (!uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "DELETE", 6)) {
+		if (!urmp->allow_delete) {
+			uwsgi_405(wsgi_req);
+                        goto end;
+		}
+		if (uwsgi_rados_delete(wsgi_req, ctx, filename, timeout)) {
+			uwsgi_403(wsgi_req);
+                        goto end;
+		}
+		uwsgi_response_prepare_headers(wsgi_req, "200 OK", 6);
+		goto end;
+	}
+
+	if (!uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "PROPFIND", 8)) {
+		if (!urmp->allow_propfind) {
+			uwsgi_405(wsgi_req);
+                        goto end;
+		}
+		uwsgi_rados_propfind(wsgi_req, ctx, filename, stat_size, stat_mtime, timeout);
+		goto end;
+	}
+
+	if (uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "HEAD", 4) && uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "GET", 3)) {
+		uwsgi_405(wsgi_req);
+		goto end;
 	}
-	
 
 	if (uwsgi_response_prepare_headers(wsgi_req, "200 OK", 6)) goto end;
 	size_t mime_type_len = 0;
@@ -230,14 +731,14 @@ static int uwsgi_rados_request(struct wsgi_request *wsgi_req) {
 		if (uwsgi_response_add_content_type(wsgi_req, mime_type, mime_type_len)) goto end;
 	}
 
-	if (uwsgi_response_add_last_modified(wsgi_req, (uint64_t) st.mtime)) goto end;
-	if (uwsgi_response_add_content_length(wsgi_req, st.size)) goto end;
+	if (uwsgi_response_add_last_modified(wsgi_req, (uint64_t) stat_mtime)) goto end;
+	if (uwsgi_response_add_content_length(wsgi_req, stat_size)) goto end;
 
 	// skip body on HEAD
 	if (uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "HEAD", 4)) {
-		size_t remains = st.size;
-		if (uwsgi.async > 1) {
-			if (uwsgi_rados_read_async(wsgi_req, ctx, filename, remains)) goto end;
+		size_t remains = stat_size;
+		if (uwsgi.async > 0) {
+			if (uwsgi_rados_read_async(wsgi_req, ctx, filename, remains, timeout)) goto end;
 		}
 		else {
 			if (uwsgi_rados_read_sync(wsgi_req, ctx, filename, remains)) goto end;
@@ -245,6 +746,10 @@ static int uwsgi_rados_request(struct wsgi_request *wsgi_req) {
 	}
 
 end:
+	if (uwsgi.async > 0) {
+		close(urio->fds[0]);
+		close(urio->fds[1]);
+	}
 	return UWSGI_OK;
 }
 
diff --git a/plugins/router_uwsgi/router_uwsgi.c b/plugins/router_uwsgi/router_uwsgi.c
index 9fca031..7387c3e 100644
--- a/plugins/router_uwsgi/router_uwsgi.c
+++ b/plugins/router_uwsgi/router_uwsgi.c
@@ -39,6 +39,11 @@ static int uwsgi_routing_func_uwsgi_remote(struct wsgi_request *wsgi_req, struct
 	char **subject = (char **) (((char *)(wsgi_req))+ur->subject);
         uint16_t *subject_len = (uint16_t *)  (((char *)(wsgi_req))+ur->subject_len);
 
+	// only 64k can be serialized in a uwsgi packet
+	if (wsgi_req->len > 0xffff) {
+		return UWSGI_ROUTE_BREAK;
+	}
+
         struct uwsgi_buffer *ub_addr = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, addr, strlen(addr));
         if (!ub_addr) return UWSGI_ROUTE_BREAK;
 
@@ -52,10 +57,11 @@ static int uwsgi_routing_func_uwsgi_remote(struct wsgi_request *wsgi_req, struct
 
 	size_t remains = wsgi_req->post_cl - wsgi_req->proto_parser_remains;
 
-	struct uwsgi_buffer *ub = uwsgi_buffer_new(4 + wsgi_req->uh->pktsize + wsgi_req->proto_parser_remains);
-	uh->pktsize = wsgi_req->uh->pktsize;
+
+	struct uwsgi_buffer *ub = uwsgi_buffer_new(4 + wsgi_req->len + wsgi_req->proto_parser_remains);
+	uh->_pktsize = wsgi_req->len;
 	if (uwsgi_buffer_append(ub, (char *) uh, 4)) goto end;
-	if (uwsgi_buffer_append(ub, wsgi_req->buffer, wsgi_req->uh->pktsize)) goto end;
+	if (uwsgi_buffer_append(ub, wsgi_req->buffer, wsgi_req->len)) goto end;
 	if (wsgi_req->proto_parser_remains > 0) {
                 if (uwsgi_buffer_append(ub, wsgi_req->proto_parser_remains_buf, wsgi_req->proto_parser_remains)) {
 			goto end;
diff --git a/plugins/rpc/rpc_plugin.c b/plugins/rpc/rpc_plugin.c
index 134d886..b8a14a2 100644
--- a/plugins/rpc/rpc_plugin.c
+++ b/plugins/rpc/rpc_plugin.c
@@ -142,7 +142,7 @@ static int uwsgi_rpc_request(struct wsgi_request *wsgi_req) {
 	size_t content_len = 0;
 
 	/* Standard RPC request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log("Empty RPC request. skip.\n");
                 return -1;
         }
@@ -226,7 +226,7 @@ static int uwsgi_rpc_request(struct wsgi_request *wsgi_req) {
 	}
 #endif
 
-	if (uwsgi_parse_array(wsgi_req->buffer, wsgi_req->uh->pktsize, argv, argvs, &argc)) {
+	if (uwsgi_parse_array(wsgi_req->buffer, wsgi_req->uh->_pktsize, argv, argvs, &argc)) {
                 uwsgi_log("Invalid RPC request. skip.\n");
                 return -1;
 	}
@@ -247,7 +247,7 @@ static int uwsgi_rpc_request(struct wsgi_request *wsgi_req) {
 				return -1;	
 			}
 			// fix uwsgi header
-			wsgi_req->uh->pktsize = ub->pos;
+			wsgi_req->uh->_pktsize = ub->pos;
 			if (uwsgi_response_write_body_do(wsgi_req, (char *) wsgi_req->uh, 4)) {
 				uwsgi_buffer_destroy(ub);
 				free(response_buf);	
@@ -261,7 +261,7 @@ static int uwsgi_rpc_request(struct wsgi_request *wsgi_req) {
 			uwsgi_buffer_destroy(ub);
 		}
 		else {
-			wsgi_req->uh->pktsize = content_len;
+			wsgi_req->uh->_pktsize = content_len;
 			if (uwsgi_response_write_body_do(wsgi_req, (char *) wsgi_req->uh, 4)) {
 				free(response_buf);	
 				return -1;
@@ -279,37 +279,54 @@ sendbody:
 }
 
 #ifdef UWSGI_ROUTING
-static int uwsgi_routing_func_rpc(struct wsgi_request *wsgi_req, struct uwsgi_route *ur) {
-	int ret = -1;
-	// this is the list of args
-        char *argv[UMAX8];
-        // this is the size of each argument
-        uint16_t argvs[UMAX8];
-	// this is a placeholder for tmp uwsgi_buffers
-	struct uwsgi_buffer *ubs[UMAX8];
-
+static int uwsgi_rpc_apply_translations(struct wsgi_request *wsgi_req, struct uwsgi_route *ur, struct uwsgi_buffer **ubs, uint64_t *ubs_len, char **argv, uint16_t *argvs) {
+	uint64_t i;
 	char **r_argv = (char **) ur->data2;
 	uint16_t *r_argvs = (uint16_t *) ur->data3;
 
 	char **subject = (char **) (((char *)(wsgi_req))+ur->subject);
-        uint16_t *subject_len = (uint16_t *)  (((char *)(wsgi_req))+ur->subject_len);
+	uint16_t *subject_len = (uint16_t *)  (((char *)(wsgi_req))+ur->subject_len);
 
-	uint64_t i;
 	for(i=0;i<ur->custom;i++) {
 		ubs[i] = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, r_argv[i], r_argvs[i]);
-		if (!ubs[i]) goto end;
+		if (!ubs[i]) {
+			*ubs_len = i;
+			return 0;
+		}
 		argv[i] = ubs[i]->buf;
 		argvs[i] = ubs[i]->pos;
 	}
 
-	// ok we now need to check it it is a local call or a remote one
-	char *func = uwsgi_str(ur->data);
+	*ubs_len = i;
+	return 1;
+}
+
+static char *uwsgi_rpc_get_remote(char *func) {
 	char *remote = NULL;
 	char *at = strchr(func, '@');
 	if (at) {
 		*at = 0;
 		remote = at+1;
 	}
+	return remote;
+}
+
+static int uwsgi_routing_func_rpc(struct wsgi_request *wsgi_req, struct uwsgi_route *ur) {
+	int ret = -1;
+	// this is the list of args
+        char *argv[UMAX8];
+        // this is the size of each argument
+        uint16_t argvs[UMAX8];
+	// this is a placeholder for tmp uwsgi_buffers
+	struct uwsgi_buffer *ubs[UMAX8];
+
+	uint64_t i;
+	if (!uwsgi_rpc_apply_translations(wsgi_req, ur, ubs, &i, argv, argvs))
+		goto end;
+
+	// ok we now need to check it it is a local call or a remote one
+	char *func = uwsgi_str(ur->data);
+	char *remote = uwsgi_rpc_get_remote(func);
 	uint64_t size;
 	char *response = uwsgi_do_rpc(remote, func, ur->custom, argv, argvs, &size);
 	free(func);
@@ -340,28 +357,13 @@ static int uwsgi_routing_func_rpc_blob(struct wsgi_request *wsgi_req, struct uws
         // this is a placeholder for tmp uwsgi_buffers
         struct uwsgi_buffer *ubs[UMAX8];
 
-        char **r_argv = (char **) ur->data2;
-        uint16_t *r_argvs = (uint16_t *) ur->data3;
-
-        char **subject = (char **) (((char *)(wsgi_req))+ur->subject);
-        uint16_t *subject_len = (uint16_t *)  (((char *)(wsgi_req))+ur->subject_len);
-
         uint64_t i;
-        for(i=0;i<ur->custom;i++) {
-                ubs[i] = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, r_argv[i], r_argvs[i]);
-                if (!ubs[i]) goto end;
-                argv[i] = ubs[i]->buf;
-                argvs[i] = ubs[i]->pos;
-        }
+	if (!uwsgi_rpc_apply_translations(wsgi_req, ur, ubs, &i, argv, argvs))
+		goto end;
 
         // ok we now need to check it it is a local call or a remote one
         char *func = uwsgi_str(ur->data);
-        char *remote = NULL;
-        char *at = strchr(func, '@');
-        if (at) {
-                *at = 0;
-                remote = at+1;
-        }
+	char *remote = uwsgi_rpc_get_remote(func);
         uint64_t size;
         char *response = uwsgi_do_rpc(remote, func, ur->custom, argv, argvs, &size);
         free(func);
@@ -387,6 +389,7 @@ end:
 }
 
 static int uwsgi_routing_func_rpc_raw(struct wsgi_request *wsgi_req, struct uwsgi_route *ur) {
+	char *response = NULL;
         int ret = -1;
         // this is the list of args
         char *argv[UMAX8];
@@ -395,30 +398,15 @@ static int uwsgi_routing_func_rpc_raw(struct wsgi_request *wsgi_req, struct uwsg
         // this is a placeholder for tmp uwsgi_buffers
         struct uwsgi_buffer *ubs[UMAX8];
 
-        char **r_argv = (char **) ur->data2;
-        uint16_t *r_argvs = (uint16_t *) ur->data3;
-
-        char **subject = (char **) (((char *)(wsgi_req))+ur->subject);
-        uint16_t *subject_len = (uint16_t *)  (((char *)(wsgi_req))+ur->subject_len);
-
         uint64_t i;
-        for(i=0;i<ur->custom;i++) {
-                ubs[i] = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, r_argv[i], r_argvs[i]);
-                if (!ubs[i]) goto end;
-                argv[i] = ubs[i]->buf;
-                argvs[i] = ubs[i]->pos;
-        }
+	if (!uwsgi_rpc_apply_translations(wsgi_req, ur, ubs, &i, argv, argvs))
+		goto end;
 
         // ok we now need to check it it is a local call or a remote one
         char *func = uwsgi_str(ur->data);
-        char *remote = NULL;
-        char *at = strchr(func, '@');
-        if (at) {
-                *at = 0;
-                remote = at+1;
-        }
+	char *remote = uwsgi_rpc_get_remote(func);
         uint64_t size;
-        char *response = uwsgi_do_rpc(remote, func, ur->custom, argv, argvs, &size);
+        response = uwsgi_do_rpc(remote, func, ur->custom, argv, argvs, &size);
         free(func);
         if (!response) goto end;
 
@@ -426,12 +414,13 @@ static int uwsgi_routing_func_rpc_raw(struct wsgi_request *wsgi_req, struct uwsg
 	if (size == 0) goto end;
 
 	ret = uwsgi_blob_to_response(wsgi_req, response, size);
-        free(response);
 	if (ret == 0) {
 		ret = UWSGI_ROUTE_BREAK;
 	}
 
 end:
+	free(response);
+
         for(i=0;i<ur->custom;i++) {
                 if (ubs[i] != NULL) {
                         uwsgi_buffer_destroy(ubs[i]);
@@ -441,6 +430,7 @@ end:
 }
 
 static int uwsgi_routing_func_rpc_var(struct wsgi_request *wsgi_req, struct uwsgi_route *ur) {
+        char *response = NULL;
         int ret = -1;
         // this is the list of args
         char *argv[UMAX8];
@@ -449,30 +439,15 @@ static int uwsgi_routing_func_rpc_var(struct wsgi_request *wsgi_req, struct uwsg
         // this is a placeholder for tmp uwsgi_buffers
         struct uwsgi_buffer *ubs[UMAX8];
 
-        char **r_argv = (char **) ur->data2;
-        uint16_t *r_argvs = (uint16_t *) ur->data3;
-
-        char **subject = (char **) (((char *)(wsgi_req))+ur->subject);
-        uint16_t *subject_len = (uint16_t *)  (((char *)(wsgi_req))+ur->subject_len);
-
         uint64_t i;
-        for(i=0;i<ur->custom;i++) {
-                ubs[i] = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, r_argv[i], r_argvs[i]);
-                if (!ubs[i]) goto end;
-                argv[i] = ubs[i]->buf;
-                argvs[i] = ubs[i]->pos;
-        }
+	if (!uwsgi_rpc_apply_translations(wsgi_req, ur, ubs, &i, argv, argvs))
+		goto end;
 
         // ok we now need to check it it is a local call or a remote one
         char *func = uwsgi_str(ur->data);
-        char *remote = NULL;
-        char *at = strchr(func, '@');
-        if (at) {
-                *at = 0;
-                remote = at+1;
-        }
+	char *remote = uwsgi_rpc_get_remote(func);
         uint64_t size;
-        char *response = uwsgi_do_rpc(remote, func, ur->custom, argv, argvs, &size);
+        response = uwsgi_do_rpc(remote, func, ur->custom, argv, argvs, &size);
         free(func);
         if (!response) goto end;
 
@@ -483,9 +458,9 @@ static int uwsgi_routing_func_rpc_var(struct wsgi_request *wsgi_req, struct uwsg
 		free(response);
 		goto end;
 	}
-	free(response);
 	ret = UWSGI_ROUTE_NEXT;
 end:
+	free(response);
         for(i=0;i<ur->custom;i++) {
                 if (ubs[i] != NULL) {
                         uwsgi_buffer_destroy(ubs[i]);
@@ -506,28 +481,13 @@ static int uwsgi_routing_func_rpc_ret(struct wsgi_request *wsgi_req, struct uwsg
         // this is a placeholder for tmp uwsgi_buffers
         struct uwsgi_buffer *ubs[UMAX8];
 
-        char **r_argv = (char **) ur->data2;
-        uint16_t *r_argvs = (uint16_t *) ur->data3;
-
-        char **subject = (char **) (((char *)(wsgi_req))+ur->subject);
-        uint16_t *subject_len = (uint16_t *)  (((char *)(wsgi_req))+ur->subject_len);
-
         uint64_t i;
-        for(i=0;i<ur->custom;i++) {
-                ubs[i] = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, r_argv[i], r_argvs[i]);
-                if (!ubs[i]) goto end;
-                argv[i] = ubs[i]->buf;
-                argvs[i] = ubs[i]->pos;
-        }
+	if (!uwsgi_rpc_apply_translations(wsgi_req, ur, ubs, &i, argv, argvs))
+		goto end;
 
         // ok we now need to check it it is a local call or a remote one
         char *func = uwsgi_str(ur->data);
-        char *remote = NULL;
-        char *at = strchr(func, '@');
-        if (at) {
-                *at = 0;
-                remote = at+1;
-        }
+	char *remote = uwsgi_rpc_get_remote(func);
         uint64_t size;
         char *response = uwsgi_do_rpc(remote, func, ur->custom, argv, argvs, &size);
         free(func);
diff --git a/plugins/signal/signal_plugin.c b/plugins/signal/signal_plugin.c
index 15a7ae5..a22a855 100644
--- a/plugins/signal/signal_plugin.c
+++ b/plugins/signal/signal_plugin.c
@@ -13,7 +13,7 @@ int uwsgi_request_signal(struct wsgi_request *wsgi_req) {
 	}
 
         uh.modifier1 = 255;
-       	uh.pktsize = 0;
+       	uh._pktsize = 0;
        	uh.modifier2 = ret_status;
 	
 	if (uwsgi_response_write_body_do(wsgi_req, (char *) &uh, 4)) {
diff --git a/plugins/spooler/spooler_plugin.c b/plugins/spooler/spooler_plugin.c
index cab566f..3ec9576 100644
--- a/plugins/spooler/spooler_plugin.c
+++ b/plugins/spooler/spooler_plugin.c
@@ -17,15 +17,15 @@ int uwsgi_request_spooler(struct wsgi_request *wsgi_req) {
         if (uwsgi.spoolers == NULL) {
                 uwsgi_log("the spooler is inactive !!!...skip\n");
 		uh.modifier1 = 255;
-		uh.pktsize = 0;
+		uh._pktsize = 0;
 		uh.modifier2 = 0;
 		uwsgi_response_write_body_do(wsgi_req, (char *) &uh, 4);
                 return -1;
         }
 
-        char *filename = uwsgi_spool_request(wsgi_req, wsgi_req->buffer, wsgi_req->uh->pktsize, NULL, 0);
+        char *filename = uwsgi_spool_request(NULL, wsgi_req->buffer, wsgi_req->uh->_pktsize, NULL, 0);
         uh.modifier1 = 255;
-        uh.pktsize = 0;
+        uh._pktsize = 0;
         if (filename) {
                 uh.modifier2 = 1;
 		if (uwsgi_response_write_body_do(wsgi_req, (char *) &uh, 4)) {
diff --git a/plugins/stackless/stackless.c b/plugins/stackless/stackless.c
index 94cfd67..0516c9f 100644
--- a/plugins/stackless/stackless.c
+++ b/plugins/stackless/stackless.c
@@ -84,7 +84,7 @@ static void stackless_init_apps(void) {
 
 	if (!usl.enabled) return;
 
-	if (uwsgi.async <= 1) {
+	if (uwsgi.async < 1) {
                 uwsgi_log("the stackless suspend engine requires async mode\n");
                 exit(1);
         }
diff --git a/plugins/stats_pusher_statsd/plugin.c b/plugins/stats_pusher_statsd/plugin.c
index 9b2b19f..e7bca47 100644
--- a/plugins/stats_pusher_statsd/plugin.c
+++ b/plugins/stats_pusher_statsd/plugin.c
@@ -92,7 +92,7 @@ static void stats_pusher_statsd(struct uwsgi_stats_pusher_instance *uspi, time_t
 			statsd_send_metric(ub, uspi, um->name, um->name_len, *um->value, "|g");
 		}
 		else {
-			statsd_send_metric(ub, uspi, um->name, um->name_len, *um->value, "|m");
+			statsd_send_metric(ub, uspi, um->name, um->name_len, *um->value, "|c");
 		}
 		uwsgi_rwunlock(uwsgi.metrics_lock);
 		if (um->reset_after_push){
diff --git a/plugins/tornado/tornado.c b/plugins/tornado/tornado.c
index cc01c1a..d733510 100644
--- a/plugins/tornado/tornado.c
+++ b/plugins/tornado/tornado.c
@@ -235,7 +235,7 @@ PyObject *py_uwsgi_tornado_accept(PyObject *self, PyObject *args) {
 
         // enter harakiri mode
         if (uwsgi.harakiri_options.workers > 0) {
-                set_harakiri(uwsgi.harakiri_options.workers);
+                set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
         }
 
 	uwsgi.async_proto_fd_table[wsgi_req->fd] = wsgi_req;
@@ -342,7 +342,7 @@ static void tornado_loop() {
 
 	uwsgi.schedule_fix = uwsgi_tornado_schedule_fix;
 
-	if (uwsgi.async < 2) {
+	if (uwsgi.async < 1) {
 		uwsgi_log("the tornado loop engine requires async mode (--async <n>)\n");
 		exit(1);
 	}
diff --git a/plugins/v8/v8_jsgi.cc b/plugins/v8/v8_jsgi.cc
index dd9ce9b..491f06c 100644
--- a/plugins/v8/v8_jsgi.cc
+++ b/plugins/v8/v8_jsgi.cc
@@ -62,7 +62,7 @@ extern "C" int uwsgi_v8_request(struct wsgi_request *wsgi_req) {
 	v8::Handle<v8::Function> forEach;
 
 	/* Standard JSGI 3.0 request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log( "Empty JSGI request. skip.\n");
                 return -1;
         }
diff --git a/proto/base.c b/proto/base.c
index 0702aaa..d48e7c9 100644
--- a/proto/base.c
+++ b/proto/base.c
@@ -9,11 +9,11 @@ int uwsgi_proto_raw_parser(struct wsgi_request *wsgi_req) {
 	return UWSGI_OK;
 }
 
-uint16_t proto_base_add_uwsgi_header(struct wsgi_request *wsgi_req, char *key, uint16_t keylen, char *val, uint16_t vallen) {
+uint64_t proto_base_add_uwsgi_header(struct wsgi_request *wsgi_req, char *key, uint16_t keylen, char *val, uint16_t vallen) {
 
 
 	int i;
-	char *buffer = wsgi_req->buffer + wsgi_req->uh->pktsize;
+	char *buffer = wsgi_req->buffer + wsgi_req->len;
 	char *watermark = wsgi_req->buffer + uwsgi.buffer_size;
 	char *ptr = buffer;
 
@@ -64,10 +64,10 @@ uint16_t proto_base_add_uwsgi_header(struct wsgi_request *wsgi_req, char *key, u
 
 
 
-uint16_t proto_base_add_uwsgi_var(struct wsgi_request * wsgi_req, char *key, uint16_t keylen, char *val, uint16_t vallen) {
+uint64_t proto_base_add_uwsgi_var(struct wsgi_request * wsgi_req, char *key, uint16_t keylen, char *val, uint16_t vallen) {
 
 
-	char *buffer = wsgi_req->buffer + wsgi_req->uh->pktsize;
+	char *buffer = wsgi_req->buffer + wsgi_req->len;
 	char *watermark = wsgi_req->buffer + uwsgi.buffer_size;
 	char *ptr = buffer;
 
diff --git a/proto/fastcgi.c b/proto/fastcgi.c
index 647b98c..2a0b246 100644
--- a/proto/fastcgi.c
+++ b/proto/fastcgi.c
@@ -60,7 +60,7 @@ int fastcgi_to_uwsgi(struct wsgi_request *wsgi_req, char *buf, size_t len) {
 		uint16_t pktsize = proto_base_add_uwsgi_var(wsgi_req, buf + j, keylen, buf + j + keylen, vallen);
 		if (pktsize == 0)
 			return -1;
-		wsgi_req->uh->pktsize += pktsize;
+		wsgi_req->len += pktsize;
 		// -1 here as the for() will increment j again
 		j += (keylen + vallen) - 1;
 	}
diff --git a/proto/http.c b/proto/http.c
index 1338b9f..9097e96 100644
--- a/proto/http.c
+++ b/proto/http.c
@@ -38,9 +38,9 @@ static char * http_header_to_cgi(char *hh, size_t hhlen, size_t *keylen, size_t
 	return val;
 }
 
-static uint16_t http_add_uwsgi_header(struct wsgi_request *wsgi_req, char *hh, size_t hhlen, char *hv, size_t hvlen, int has_prefix) {
+static uint64_t http_add_uwsgi_header(struct wsgi_request *wsgi_req, char *hh, size_t hhlen, char *hv, size_t hvlen, int has_prefix) {
 
-	char *buffer = wsgi_req->buffer + wsgi_req->uh->pktsize;
+	char *buffer = wsgi_req->buffer + wsgi_req->len;
 	char *watermark = wsgi_req->buffer + uwsgi.buffer_size;
 	char *ptr = buffer;
 	size_t keylen = hhlen;
@@ -48,11 +48,16 @@ static uint16_t http_add_uwsgi_header(struct wsgi_request *wsgi_req, char *hh, s
 	if (has_prefix) keylen += 5;
 
 	if (buffer + keylen + hvlen + 2 + 2 >= watermark) {
-		if (has_prefix) {
-			uwsgi_log("[WARNING] unable to add HTTP_%.*s=%.*s to uwsgi packet, consider increasing buffer size\n", keylen, hh, hvlen, hv);
+		if (keylen <= 0xff && hvlen <= 0xff) {
+			if (has_prefix) {
+				uwsgi_log("[WARNING] unable to add HTTP_%.*s=%.*s to uwsgi packet, consider increasing buffer size\n", keylen - 5, hh, hvlen, hv);
+			}
+			else {
+				uwsgi_log("[WARNING] unable to add %.*s=%.*s to uwsgi packet, consider increasing buffer size\n", keylen, hh, hvlen, hv);
+			}
 		}
 		else {
-			uwsgi_log("[WARNING] unable to add %.*s=%.*s to uwsgi packet, consider increasing buffer size\n", keylen, hh, hvlen, hv);
+			uwsgi_log("[WARNING] unable to build uwsgi packet from http request, consider increasing buffer size\n");
 		}
 		return 0;
 	}
@@ -194,7 +199,7 @@ static int http_parse(struct wsgi_request *wsgi_req, char *watermark) {
 	// REQUEST_METHOD 
 	while (ptr < watermark) {
 		if (*ptr == ' ') {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_METHOD", 14, base, ptr - base);
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_METHOD", 14, base, ptr - base);
 			ptr++;
 			break;
 		}
@@ -206,10 +211,11 @@ static int http_parse(struct wsgi_request *wsgi_req, char *watermark) {
 	while (ptr < watermark) {
 		if (*ptr == '?' && !query_string) {
 			if (watermark + (ptr - base) < (char *)(wsgi_req->proto_parser_buf + uwsgi.buffer_size)) {
+				if (ptr - base > 0xffff) return -1;
 				uint16_t path_info_len = ptr - base;
 				char *path_info = uwsgi_malloc(path_info_len);
 				http_url_decode(base, &path_info_len, path_info);
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "PATH_INFO", 9, path_info, path_info_len);
+				wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "PATH_INFO", 9, path_info, path_info_len);
 				free(path_info);
 			}
 			else {
@@ -219,24 +225,25 @@ static int http_parse(struct wsgi_request *wsgi_req, char *watermark) {
 			query_string = ptr + 1;
 		}
 		else if (*ptr == ' ') {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, base, ptr - base);
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, base, ptr - base);
 			
 			if (!query_string) {
 				if (watermark + (ptr - base) < (char *)(wsgi_req->proto_parser_buf + uwsgi.buffer_size)) {
+					if (ptr - base > 0xffff) return -1;
                                 	uint16_t path_info_len = ptr - base;
 					char *path_info = uwsgi_malloc(path_info_len);
                                 	http_url_decode(base, &path_info_len, path_info);
-                                	wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "PATH_INFO", 9, path_info, path_info_len);
+                                	wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "PATH_INFO", 9, path_info, path_info_len);
 					free(path_info);
                         	}
 				else {
 					uwsgi_log("not enough space in wsgi_req http proto_parser_buf to decode PATH_INFO, consider tuning it with --buffer-size\n");
 					return -1;
 				}
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, "", 0);
+				wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, "", 0);
 			}
 			else {
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, query_string, ptr - query_string);
+				wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, query_string, ptr - query_string);
 			}
 			ptr++;
 			break;
@@ -252,7 +259,8 @@ static int http_parse(struct wsgi_request *wsgi_req, char *watermark) {
 				return -1 ;
 			if (*(ptr + 1) != '\n')
 				return -1;
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PROTOCOL", 15, base, ptr - base);
+			if (ptr - base > 0xffff) return -1;
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PROTOCOL", 15, base, ptr - base);
 			ptr += 2;
 			break;
 		}
@@ -261,42 +269,42 @@ static int http_parse(struct wsgi_request *wsgi_req, char *watermark) {
 
 	// SCRIPT_NAME
 	if (!uwsgi.manage_script_name) {
-		wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SCRIPT_NAME", 11, "", 0);
+		wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SCRIPT_NAME", 11, "", 0);
 	}
 	
 
 	// SERVER_NAME
-	wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_NAME", 11, uwsgi.hostname, uwsgi.hostname_len);
+	wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_NAME", 11, uwsgi.hostname, uwsgi.hostname_len);
 
 	// SERVER_PORT / SERVER_ADDR
 	if (proxy_dst) {
-		wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_ADDR", 11, proxy_dst, proxy_dst_len);
+		wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_ADDR", 11, proxy_dst, proxy_dst_len);
                 if (proxy_dst_port) {
-                        wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, proxy_dst_port, proxy_dst_port_len);
+                        wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, proxy_dst_port, proxy_dst_port_len);
                 }
 	}
 	else {
 		char *server_port = strchr(wsgi_req->socket->name, ':');
 		if (server_port) {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, server_port+1, strlen(server_port+1));
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, server_port+1, strlen(server_port+1));
 		}
 		else {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, "80", 2);
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, "80", 2);
 		}
 	}
 
 	// REMOTE_ADDR
 	if (proxy_src) {
-		wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, proxy_src, proxy_src_len);
+		wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, proxy_src, proxy_src_len);
 		if (proxy_src_port) {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_PORT", 11, proxy_src_port, proxy_src_port_len);
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_PORT", 11, proxy_src_port, proxy_src_port_len);
 		}
 	}
 	else {
 		// TODO add ipv6 support
 		memset(ip, 0, INET_ADDRSTRLEN+1);
 		if (inet_ntop(AF_INET, (void *) &http_sin->sin_addr.s_addr, ip, INET_ADDRSTRLEN)) {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, ip, strlen(ip));
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, ip, strlen(ip));
 		}
 		else {
 			uwsgi_error("inet_ntop()");
@@ -305,7 +313,7 @@ static int http_parse(struct wsgi_request *wsgi_req, char *watermark) {
 	}
 
 	if (wsgi_req->https_len > 0) {
-		wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "HTTPS", 5, wsgi_req->https, wsgi_req->https_len);
+		wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "HTTPS", 5, wsgi_req->https, wsgi_req->https_len);
 	}
 
 	//HEADERS
@@ -330,6 +338,7 @@ static int http_parse(struct wsgi_request *wsgi_req, char *watermark) {
 			int has_prefix = 0;
 			// last line, do not waste time
 			if (ptr - base == 0) break;
+			if (ptr - base > 0xffff) return -1;
 			char *value = http_header_to_cgi(base, ptr - base, &key_len, &value_len, &has_prefix);
 			if (!value) {
 				uwsgi_log_verbose("invalid HTTP request\n");
@@ -363,10 +372,10 @@ static int http_parse(struct wsgi_request *wsgi_req, char *watermark) {
 	int broken = 0;
 	while(usl) {
 		if (!broken) {
-			uint16_t old_pktsize = wsgi_req->uh->pktsize;
-			wsgi_req->uh->pktsize += http_add_uwsgi_header(wsgi_req, usl->value, usl->len, usl->custom_ptr, (size_t) usl->custom, usl->custom2 & 0x02);
+			uint64_t old_len = wsgi_req->len;
+			wsgi_req->len += http_add_uwsgi_header(wsgi_req, usl->value, usl->len, usl->custom_ptr, (size_t) usl->custom, usl->custom2 & 0x02);
 			// if the packet remains unchanged, the buffer is full, mark the request as broken
-			if (old_pktsize == wsgi_req->uh->pktsize) {
+			if (old_len == wsgi_req->len) {
 				broken = 1;
 			}
 		}
@@ -423,7 +432,7 @@ static int uwsgi_proto_http_parser(struct wsgi_request *wsgi_req) {
 	}
 	// mute on 0 len...
 	if (wsgi_req->proto_parser_pos > 0) {
-		uwsgi_log("uwsgi_proto_http_parser() -> client closed connection");
+		uwsgi_log("uwsgi_proto_http_parser() -> client closed connection\n");
 	}
 	return -1;
 
@@ -639,6 +648,62 @@ void uwsgi_proto_http_setup(struct uwsgi_socket *uwsgi_sock) {
 
 }
 
+/*
+close the connection on errors, incomplete parsing, HTTP/1.0,  pipelined or offloaded requests
+NOTE: Connection: close is not honoured
+*/
+void uwsgi_proto_http11_close(struct wsgi_request *wsgi_req) {
+        // check for errors or incomplete packets
+        if (wsgi_req->write_errors || wsgi_req->proto_parser_status != 3 || wsgi_req->proto_parser_remains > 0
+		|| wsgi_req->post_pos < wsgi_req->post_cl || wsgi_req->via == UWSGI_VIA_OFFLOAD
+		|| !uwsgi_strncmp("HTTP/1.0", 8, wsgi_req->protocol, wsgi_req->protocol_len)) {
+                close(wsgi_req->fd);
+                wsgi_req->socket->retry[wsgi_req->async_id] = 0;
+                wsgi_req->socket->fd_threads[wsgi_req->async_id] = -1;
+        }
+        else {
+                wsgi_req->socket->retry[wsgi_req->async_id] = 1;
+                wsgi_req->socket->fd_threads[wsgi_req->async_id] = wsgi_req->fd;
+        }
+}
+
+int uwsgi_proto_http11_accept(struct wsgi_request *wsgi_req, int fd) {
+        if (wsgi_req->socket->retry[wsgi_req->async_id]) {
+                wsgi_req->fd = wsgi_req->socket->fd_threads[wsgi_req->async_id];
+		wsgi_req->c_len = sizeof(struct sockaddr_un);
+		getsockname(wsgi_req->fd, (struct sockaddr *) &wsgi_req->c_addr, (socklen_t *) &wsgi_req->c_len);
+                int ret = uwsgi_wait_read_req(wsgi_req);
+                if (ret <= 0) {
+                        close(wsgi_req->fd);
+                        wsgi_req->socket->retry[wsgi_req->async_id] = 0;
+                        wsgi_req->socket->fd_threads[wsgi_req->async_id] = -1;
+                        return -1;
+                }
+                return wsgi_req->socket->fd_threads[wsgi_req->async_id];
+        }
+        return uwsgi_proto_base_accept(wsgi_req, fd);
+}
+
+void uwsgi_proto_http11_setup(struct uwsgi_socket *uwsgi_sock) {
+        uwsgi_sock->proto = uwsgi_proto_http_parser;
+        uwsgi_sock->proto_accept = uwsgi_proto_http11_accept;
+        uwsgi_sock->proto_prepare_headers = uwsgi_proto_base_prepare_headers;
+        uwsgi_sock->proto_add_header = uwsgi_proto_base_add_header;
+        uwsgi_sock->proto_fix_headers = uwsgi_proto_base_fix_headers;
+        uwsgi_sock->proto_read_body = uwsgi_proto_base_read_body;
+        uwsgi_sock->proto_write = uwsgi_proto_base_write;
+        uwsgi_sock->proto_writev = uwsgi_proto_base_writev;
+        uwsgi_sock->proto_write_headers = uwsgi_proto_base_write;
+        uwsgi_sock->proto_sendfile = uwsgi_proto_base_sendfile;
+        uwsgi_sock->proto_close = uwsgi_proto_http11_close;
+        if (uwsgi.offload_threads > 0)
+        	uwsgi_sock->can_offload = 1;
+	uwsgi_sock->fd_threads = uwsgi_malloc(sizeof(int) * uwsgi.cores);
+        memset(uwsgi_sock->fd_threads, -1, sizeof(int) * uwsgi.cores);
+        uwsgi_sock->retry = uwsgi_calloc(sizeof(int) * uwsgi.cores);
+        uwsgi.is_et = 1;
+}
+
 #ifdef UWSGI_SSL
 static int uwsgi_proto_https_parser(struct wsgi_request *wsgi_req) {
 
diff --git a/proto/puwsgi.c b/proto/puwsgi.c
index 72840be..0a9fb08 100644
--- a/proto/puwsgi.c
+++ b/proto/puwsgi.c
@@ -22,10 +22,11 @@ int uwsgi_proto_puwsgi_parser(struct wsgi_request *wsgi_req) {
 			wsgi_req->proto_parser_pos += len;
 			if (wsgi_req->proto_parser_pos == 4) {
 #ifdef __BIG_ENDIAN__
-                        	wsgi_req->uh->pktsize = uwsgi_swap16(wsgi_req->uh->pktsize);
+                        	wsgi_req->len = uwsgi_swap16(wsgi_req->len);
 #endif
-				if (wsgi_req->uh->pktsize > uwsgi.buffer_size) {
-                                	uwsgi_log("invalid request block size: %u (max %u)...skip\n", wsgi_req->uh->pktsize, uwsgi.buffer_size);
+				wsgi_req->len = wsgi_req->len;
+				if (wsgi_req->len > uwsgi.buffer_size) {
+                                	uwsgi_log("invalid request block size: %u (max %u)...skip\n", wsgi_req->len, uwsgi.buffer_size);
 					wsgi_req->write_errors++;		
                                 	return -1;
                         	}
@@ -34,10 +35,10 @@ int uwsgi_proto_puwsgi_parser(struct wsgi_request *wsgi_req) {
 		}
 		goto negative;
 	}
-	len = read(wsgi_req->fd, ptr + wsgi_req->proto_parser_pos, wsgi_req->uh->pktsize - (wsgi_req->proto_parser_pos-4));
+	len = read(wsgi_req->fd, ptr + wsgi_req->proto_parser_pos, wsgi_req->len - (wsgi_req->proto_parser_pos-4));
 	if (len > 0) {
 		wsgi_req->proto_parser_pos += len;
-		if ((wsgi_req->proto_parser_pos-4) == wsgi_req->uh->pktsize) {
+		if ((wsgi_req->proto_parser_pos-4) == wsgi_req->len) {
 			return UWSGI_OK;	
 		}
 		return UWSGI_AGAIN;
@@ -64,7 +65,7 @@ close the connection on errors, otherwise force edge triggering
 */
 void uwsgi_proto_puwsgi_close(struct wsgi_request *wsgi_req) {
 	// check for errors or incomplete packets
-	if (wsgi_req->write_errors || (size_t) (wsgi_req->uh->pktsize + 4) != wsgi_req->proto_parser_pos) {
+	if (wsgi_req->write_errors || (size_t) (wsgi_req->len + 4) != wsgi_req->proto_parser_pos) {
 		close(wsgi_req->fd);
 		wsgi_req->socket->retry[wsgi_req->async_id] = 0;
 		wsgi_req->socket->fd_threads[wsgi_req->async_id] = -1;
diff --git a/proto/scgi.c b/proto/scgi.c
index a5afec4..707fe3e 100644
--- a/proto/scgi.c
+++ b/proto/scgi.c
@@ -43,7 +43,7 @@ keyval:
 				vallen = (buf+i) - value;
 				uint16_t pktsize = proto_base_add_uwsgi_var(wsgi_req, key, keylen, value, vallen);
                 		if (pktsize == 0) return -1;
-                		wsgi_req->uh->pktsize += pktsize;
+                		wsgi_req->len += pktsize;
 				key = NULL;
 				value = NULL;
 				keylen = 0;
diff --git a/proto/uwsgi.c b/proto/uwsgi.c
index 07f3aaa..e07f7a0 100644
--- a/proto/uwsgi.c
+++ b/proto/uwsgi.c
@@ -11,18 +11,19 @@ static int uwsgi_proto_uwsgi_parser(struct wsgi_request *wsgi_req) {
 		wsgi_req->proto_parser_pos += len;
 		if (wsgi_req->proto_parser_pos >= 4) {
 #ifdef __BIG_ENDIAN__
-			wsgi_req->uh->pktsize = uwsgi_swap16(wsgi_req->uh->pktsize);
+			wsgi_req->uh->_pktsize = uwsgi_swap16(wsgi_req->uh->_pktsize);
 #endif
-			if ((wsgi_req->proto_parser_pos - 4) == wsgi_req->uh->pktsize) {
+			wsgi_req->len = wsgi_req->uh->_pktsize;
+			if ((wsgi_req->proto_parser_pos - 4) == wsgi_req->uh->_pktsize) {
 				return UWSGI_OK;
 			}
-			if ((wsgi_req->proto_parser_pos - 4) > wsgi_req->uh->pktsize) {
-				wsgi_req->proto_parser_remains = wsgi_req->proto_parser_pos - (4 + wsgi_req->uh->pktsize);
-				wsgi_req->proto_parser_remains_buf = wsgi_req->buffer + wsgi_req->uh->pktsize;
+			if ((wsgi_req->proto_parser_pos - 4) > wsgi_req->uh->_pktsize) {
+				wsgi_req->proto_parser_remains = wsgi_req->proto_parser_pos - (4 + wsgi_req->uh->_pktsize);
+				wsgi_req->proto_parser_remains_buf = wsgi_req->buffer + wsgi_req->uh->_pktsize;
 				return UWSGI_OK;
 			}
-			if (wsgi_req->uh->pktsize > uwsgi.buffer_size) {
-				uwsgi_log("invalid request block size: %u (max %u)...skip\n", wsgi_req->uh->pktsize, uwsgi.buffer_size);
+			if (wsgi_req->uh->_pktsize > uwsgi.buffer_size) {
+				uwsgi_log("invalid request block size: %u (max %u)...skip\n", wsgi_req->uh->_pktsize, uwsgi.buffer_size);
 				return -1;
 			}
 		}
@@ -52,18 +53,18 @@ retry:
                 wsgi_req->proto_parser_pos += len;
                 if (wsgi_req->proto_parser_pos >= 4) {
 #ifdef __BIG_ENDIAN__
-                        wsgi_req->uh->pktsize = uwsgi_swap16(wsgi_req->uh->pktsize);
+                        wsgi_req->uh->_pktsize = uwsgi_swap16(wsgi_req->uh->_pktsize);
 #endif
-                        if ((wsgi_req->proto_parser_pos - 4) == wsgi_req->uh->pktsize) {
+                        if ((wsgi_req->proto_parser_pos - 4) == wsgi_req->uh->_pktsize) {
                                 return UWSGI_OK;
                         }
-                        if ((wsgi_req->proto_parser_pos - 4) > wsgi_req->uh->pktsize) {
-                                wsgi_req->proto_parser_remains = wsgi_req->proto_parser_pos - (4 + wsgi_req->uh->pktsize);
-                                wsgi_req->proto_parser_remains_buf = wsgi_req->buffer + wsgi_req->uh->pktsize;
+                        if ((wsgi_req->proto_parser_pos - 4) > wsgi_req->uh->_pktsize) {
+                                wsgi_req->proto_parser_remains = wsgi_req->proto_parser_pos - (4 + wsgi_req->uh->_pktsize);
+                                wsgi_req->proto_parser_remains_buf = wsgi_req->buffer + wsgi_req->uh->_pktsize;
                                 return UWSGI_OK;
                         }
-                        if (wsgi_req->uh->pktsize > uwsgi.buffer_size) {
-                                uwsgi_log("invalid request block size: %u (max %u)...skip\n", wsgi_req->uh->pktsize, uwsgi.buffer_size);
+                        if (wsgi_req->uh->_pktsize > uwsgi.buffer_size) {
+                                uwsgi_log("invalid request block size: %u (max %u)...skip\n", wsgi_req->uh->_pktsize, uwsgi.buffer_size);
                                 return -1;
                         }
                 }
@@ -144,18 +145,18 @@ int uwsgi_proto_uwsgi_parser_unix(struct wsgi_request *wsgi_req) {
 			wsgi_req->proto_parser_status = PROTO_STATUS_RECV_VARS;
 			wsgi_req->proto_parser_pos = 0;
 #ifdef __BIG_ENDIAN__
-			wsgi_req->uh->pktsize = uwsgi_swap16(wsgi_req->uh->pktsize);
+			wsgi_req->uh->_pktsize = uwsgi_swap16(wsgi_req->uh->_pktsize);
 #endif
 
 #ifdef UWSGI_DEBUG
-			uwsgi_debug("uwsgi payload size: %d (0x%X) modifier1: %d modifier2: %d\n", wsgi_req->uh.pktsize, wsgi_req->uh.pktsize, wsgi_req->uh.modifier1, wsgi_req->uh.modifier2);
+			uwsgi_debug("uwsgi payload size: %d (0x%X) modifier1: %d modifier2: %d\n", wsgi_req->uh._pktsize, wsgi_req->uh._pktsize, wsgi_req->uh.modifier1, wsgi_req->uh.modifier2);
 #endif
 
-			if (wsgi_req->uh->pktsize > uwsgi.buffer_size) {
+			if (wsgi_req->uh->_pktsize > uwsgi.buffer_size) {
 				return -1;
 			}
 
-			if (!wsgi_req->uh->pktsize)
+			if (!wsgi_req->uh->_pktsize)
 				return UWSGI_OK;
 
 		}
@@ -163,7 +164,7 @@ int uwsgi_proto_uwsgi_parser_unix(struct wsgi_request *wsgi_req) {
 	}
 
 	else if (wsgi_req->proto_parser_status == PROTO_STATUS_RECV_VARS) {
-		len = read(wsgi_req->fd, wsgi_req->buffer + wsgi_req->proto_parser_pos, wsgi_req->uh->pktsize - wsgi_req->proto_parser_pos);
+		len = read(wsgi_req->fd, wsgi_req->buffer + wsgi_req->proto_parser_pos, wsgi_req->uh->_pktsize - wsgi_req->proto_parser_pos);
 		if (len <= 0) {
 			uwsgi_error("read()");
 			return -1;
@@ -171,7 +172,7 @@ int uwsgi_proto_uwsgi_parser_unix(struct wsgi_request *wsgi_req) {
 		wsgi_req->proto_parser_pos += len;
 
 		// body ready ?
-		if (wsgi_req->proto_parser_pos >= wsgi_req->uh->pktsize) {
+		if (wsgi_req->proto_parser_pos >= wsgi_req->uh->_pktsize) {
 
 			// older OSX versions make mess with CMSG_FIRSTHDR
 #ifdef __APPLE__
diff --git a/setup.cpyext.py b/setup.cpyext.py
new file mode 100644
index 0000000..ee89dbc
--- /dev/null
+++ b/setup.cpyext.py
@@ -0,0 +1,131 @@
+# encoding: utf-8
+
+"""
+This is a hack allowing you installing
+uWSGI and uwsgidecorators via pip and easy_install
+since 1.9.11 it automatically detects pypy
+"""
+
+import os
+import sys
+import errno
+import shlex
+import shutil
+import uwsgiconfig
+
+from setuptools import setup
+from setuptools.dist import Distribution
+from setuptools.command.install import install
+from setuptools.command.install_lib import install_lib
+from setuptools.command.build_ext import build_ext
+from distutils.core import Extension
+
+
+class uWSGIBuildExt(build_ext):
+
+    UWSGI_NAME = 'uwsgi'
+    UWSGI_PLUGIN = 'pyuwsgi'
+
+    def build_extensions(self):
+        self.uwsgi_setup()
+        #XXX: needs uwsgiconfig fix
+        self.uwsgi_build()
+        if 'UWSGI_USE_DISTUTILS' not in os.environ:
+            #XXX: needs uwsgiconfig fix
+            #uwsgiconfig.build_uwsgi(self.uwsgi_config)
+            return
+
+        else:
+            #XXX: needs uwsgiconfig fix
+            os.unlink(self.uwsgi_config.get('bin_name'))
+
+        #FIXME: else build fails :(
+        for baddie in set(self.compiler.compiler_so) & set((
+            '-Wstrict-prototypes',
+            )):
+            self.compiler.compiler_so.remove(baddie)
+
+        build_ext.build_extensions(self)
+
+    def uwsgi_setup(self):
+        default = (
+            '__pypy__' in sys.builtin_module_names
+                and 'pypy'
+                or 'default'
+                )
+        profile = (
+            os.environ.get('UWSGI_PROFILE')
+                or 'buildconf/%s.ini' % default
+                )
+
+        if not profile.endswith('.ini'):
+            profile = profile + '.ini'
+        if not '/' in profile:
+            profile = 'buildconf/' + profile
+
+        #FIXME: update uwsgiconfig to properly set _EVERYTHING_!
+        config = uwsgiconfig.uConf(profile)
+        # insert in the beginning so UWSGI_PYTHON_NOLIB is exported
+        # before the python plugin compiles
+        ep = config.get('embedded_plugins').split(',')
+        if self.UWSGI_PLUGIN in ep:
+            ep.remove(self.UWSGI_PLUGIN)
+        ep.insert(0, self.UWSGI_PLUGIN)
+        config.set('embedded_plugins', ','.join(ep))
+        config.set('as_shared_library', 'true')
+        config.set('bin_name', self.get_ext_fullpath(self.UWSGI_NAME))
+        try:
+            os.makedirs(os.path.dirname(config.get('bin_name')))
+        except OSError as e:
+            if e.errno != errno.EEXIST:
+                raise
+
+        self.uwsgi_profile = profile
+        self.uwsgi_config = config
+
+    def uwsgi_build(self):
+        uwsgiconfig.build_uwsgi(self.uwsgi_config)
+
+        #XXX: merge uwsgi_setup (see other comments)
+        for ext in self.extensions:
+            if ext.name == self.UWSGI_NAME:
+                ext.sources = [s + '.c' for s in self.uwsgi_config.gcc_list]
+                ext.library_dirs = self.uwsgi_config.include_path[:]
+                ext.libraries = list()
+                ext.extra_compile_args = list()
+
+                for x in uwsgiconfig.uniq_warnings(
+                    self.uwsgi_config.ldflags + self.uwsgi_config.libs,
+                    ):
+                    for y in shlex.split(x):
+                        if y.startswith('-l'):
+                            ext.libraries.append(y[2:])
+                        elif y.startswith('-L'):
+                            ext.library_dirs.append(y[2:])
+
+                for x in self.uwsgi_config.cflags:
+                    for y in shlex.split(x):
+                        if y:
+                            ext.extra_compile_args.append(y)
+
+
+setup(
+    name='uWSGI',
+    license='GPL2',
+    version=uwsgiconfig.uwsgi_version,
+    author='Unbit',
+    author_email='info@unbit.it',
+    description='The uWSGI server',
+    cmdclass={
+        'build_ext': uWSGIBuildExt,
+        },
+    py_modules=[
+        'uwsgidecorators',
+        ],
+    ext_modules=[
+        Extension(uWSGIBuildExt.UWSGI_NAME, sources=[]),
+        ],
+    entry_points={
+        'console_scripts': ['uwsgi=%s:run' % uWSGIBuildExt.UWSGI_NAME],
+        },
+    )
diff --git a/t/python/spooler_decorators/spooler_decorator_test.ini b/t/python/spooler_decorators/spooler_decorator_test.ini
new file mode 100644
index 0000000..352f1ae
--- /dev/null
+++ b/t/python/spooler_decorators/spooler_decorator_test.ini
@@ -0,0 +1,18 @@
+[uwsgi]
+socket = /tmp/temporary_socket
+
+; Spooler!
+
+spooler-import = %d/spooler_handlers.py
+; Specify the spooler
+spooler = $(SPOOLER_DIR)
+; And the number of processes
+spooler-processes = 1
+; Spooler ordered scanning (only works with "numbered" dirs)
+spooler-ordered = 1
+; Spooler frequency
+spooler-frequency = 1
+
+pyrun = %d/spooler_decorator_tests.py
+master = 1
+
diff --git a/t/python/spooler_decorators/spooler_decorator_tests.py b/t/python/spooler_decorators/spooler_decorator_tests.py
new file mode 100644
index 0000000..ec72e39
--- /dev/null
+++ b/t/python/spooler_decorators/spooler_decorator_tests.py
@@ -0,0 +1,31 @@
+# run it with:
+# export SPOOLER_DIR=t/python/spooler_priority/temporary_spooler; # or your spooler dir
+# ./uwsgi t/python/spooler_decorators/spooler_decorator_test.ini
+
+import unittest
+import uwsgi
+import spooler_handlers
+from os import remove, path
+
+
+class BitmapTest(unittest.TestCase):
+
+    def setUp(self):
+        try:
+            remove(spooler_handlers.ghostpath)
+        except OSError:  # file does not exist
+            pass
+
+        spooler_handlers.controlled_task.spool(arg='alive', ghost='world')
+        spooler_handlers.controlled_task.spool(arg='barbis')
+        spooler_handlers.controlled_raw_task.spool(arg='alive', ghost='world')
+        spooler_handlers.controlled_raw_task.spool(arg='barbis')
+
+        for i in range(4):
+            uwsgi.signal_wait(20)
+        print("Signal received!")
+
+    def test_spooler(self):
+        self.assertFalse(path.exists(spooler_handlers.ghostpath))
+
+unittest.main()
diff --git a/t/python/spooler_decorators/spooler_handlers.py b/t/python/spooler_decorators/spooler_handlers.py
new file mode 100644
index 0000000..5298f91
--- /dev/null
+++ b/t/python/spooler_decorators/spooler_handlers.py
@@ -0,0 +1,23 @@
+# See spooler_decorator_tests
+
+from uwsgidecorators import *
+import uwsgi
+
+ghostpath = "/tmp/ghost"
+
+
+@spool
+def controlled_task(arguments):
+    if arguments['arg'] != 'alive' and 'ghost' in arguments:
+        print("We have a problem!")
+        open(ghostpath, 'w').close()
+    uwsgi.signal(20)
+
+
+@spoolraw
+def controlled_raw_task(arguments):
+    if arguments['arg'] != 'alive' and 'ghost' in arguments:
+        print("We have a problem!")
+        open(ghostpath, 'w').close()
+    uwsgi.signal(20)
+    return uwsgi.SPOOL_OK
diff --git a/t/python/spooler_handler.py b/t/python/spooler_handler.py
new file mode 100644
index 0000000..dfaa46e
--- /dev/null
+++ b/t/python/spooler_handler.py
@@ -0,0 +1,34 @@
+#! /usr/bin/env python2
+# coding = utf-8
+
+from __future__ import print_function
+from constants import tasks, LOGFILE
+from os import remove
+import uwsgi
+
+counter = 0
+
+
+def spoolerHandler(env):
+	global counter
+	# Spooler is handling a task
+	with open(LOGFILE, "a") as log:
+		print("%s" % (env['name']), file=log)
+
+	counter += 1
+
+	if counter == len(tasks):
+		# Each task has been processed.
+		uwsgi.signal(17)
+
+	# Spooler has done handling the task
+	return uwsgi.SPOOL_OK
+
+uwsgi.spooler = spoolerHandler
+
+# Clear the logfile
+try:
+	remove(LOGFILE)
+except OSError, e:  # log does not exist
+	pass
+	# print(e)
diff --git a/t/python/spooler_priority/spooler_priority_constants.py b/t/python/spooler_priority/spooler_priority_constants.py
new file mode 100644
index 0000000..4e77d15
--- /dev/null
+++ b/t/python/spooler_priority/spooler_priority_constants.py
@@ -0,0 +1,22 @@
+#! /usr/bin/env python2
+# coding = utf-8
+
+tasks = [
+	(101, "101"),
+	(101, "101Bis"),
+	(2, "2"),
+	(1, "1"),
+	(0, "0"),
+	(None, "NoPriority")
+]
+
+ordered_tasks = [
+	"0",
+	"1",
+	"2",
+	"101",
+	"101Bis",
+	"NoPriority"
+]
+
+LOGFILE = "/tmp/spoolerlog"
diff --git a/t/python/spooler_priority/spooler_priority_handler.py b/t/python/spooler_priority/spooler_priority_handler.py
new file mode 100644
index 0000000..97d9a7d
--- /dev/null
+++ b/t/python/spooler_priority/spooler_priority_handler.py
@@ -0,0 +1,33 @@
+#! /usr/bin/env python
+# coding = utf-8
+
+from __future__ import print_function
+from spooler_priority_constants import tasks, LOGFILE
+from os import remove
+import uwsgi
+
+counter = 0
+
+
+def spoolerHandler(env):
+	global counter
+	# Spooler is handling a task
+	with open(LOGFILE, "a") as log:
+		print("%s" % (env['name']), file=log)
+
+	counter += 1
+
+	if counter == len(tasks):
+		# Each task has been processed.
+		uwsgi.signal(17)
+
+	# Spooler has done handling the task
+	return uwsgi.SPOOL_OK
+
+uwsgi.spooler = spoolerHandler
+
+# Clear the logfile
+try:
+	remove(LOGFILE)
+except OSError, e:  # log does not exist
+	print(e)
diff --git a/t/python/spooler_priority/spooler_priority_test.ini b/t/python/spooler_priority/spooler_priority_test.ini
new file mode 100644
index 0000000..0076fe6
--- /dev/null
+++ b/t/python/spooler_priority/spooler_priority_test.ini
@@ -0,0 +1,17 @@
+[uwsgi]
+socket = /tmp/temporary-socket
+
+; Specify the spooler
+spooler = %d/temporary_spooler
+; Spooler handler
+spooler-import = %d/spooler_priority_handler.py
+; And the number of processes
+spooler-processes = 1
+; Spooler ordered scanning (only works with "numbered" dirs)
+spooler-ordered = 1
+; Spooler scans folder each second
+spooler-frequency = 1
+
+pyrun = %d/spooler_priority_test.py
+master = 1
+
diff --git a/t/python/spooler_priority/spooler_priority_test.py b/t/python/spooler_priority/spooler_priority_test.py
new file mode 100644
index 0000000..a30dc88
--- /dev/null
+++ b/t/python/spooler_priority/spooler_priority_test.py
@@ -0,0 +1,82 @@
+#! /usr/bin/env python
+# coding = utf-8
+
+import uwsgi
+import unittest
+import os
+import fcntl
+from shutil import rmtree
+import time
+from signal import *
+import spooler_priority_constants
+
+
+def spoolersTaskList():
+	# Get the list of tasks
+	tasks = [
+			os.path.join(s, fn)
+			for s in uwsgi.spoolers
+			for fn in os.listdir(s)
+		]
+
+	for t in tasks[:]:
+		if os.path.isdir(t):
+			tasks += [os.path.join(t, fn) for fn in os.listdir(t)]
+			tasks.remove(t)
+
+	return tasks
+
+
+def is_locked(filepath):
+	# Check if file is locked
+	with open(filepath, "a+") as f:
+		try:
+			fcntl.lockf(f.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
+			is_locked = False
+		except IOError:
+			is_locked = True
+	return is_locked
+
+
+def lockedTasks(tasklist):
+	# List of locked tasks
+	return [fp for fp in spoolersTaskList() if is_locked(fp)]
+
+
+def taskParameters(filepath):
+	# Retrieve parameters
+	return uwsgi.parsefile(filepath)
+
+
+def cleanTasks():
+	# Clean any remaining task
+	for s in uwsgi.spoolers:
+		for f in os.listdir(s):
+			path = os.path.join(s, f)
+			if os.path.isdir(path):
+				rmtree(os.path.join(s, f))
+			else:
+				os.remove(path)
+
+
+class BitmapTest(unittest.TestCase):
+
+	def setUp(self):
+		for priority, name in spooler_priority_constants.tasks:
+			task = {'name': name, 'at': int(time.time() + 10)}
+			if priority is not None:
+				task['priority'] = str(priority)
+			uwsgi.spool(task)
+
+	def test_priority(self):
+		uwsgi.signal_wait(17)
+		print("Signal received.")
+
+		with open(spooler_priority_constants.LOGFILE, "r") as log:
+			# Check logging ordering.
+			loglines = [line.rstrip() for line in log]
+			self.assertEqual(loglines, spooler_priority_constants.ordered_tasks)
+
+signal(SIGINT, cleanTasks)
+unittest.main()
+
diff --git a/uwsgi.gemspec b/uwsgi.gemspec
index aca819b..c7753c5 100644
--- a/uwsgi.gemspec
+++ b/uwsgi.gemspec
@@ -2,7 +2,7 @@ Gem::Specification.new do |s|
   s.name        = 'uwsgi'
   s.license     = 'GPL-2'
   s.version     = `python -c "import uwsgiconfig as uc; print uc.uwsgi_version"`.sub(/-dev-.*/,'')
-  s.date        = '2014-06-02'
+  s.date        = '2014-09-05'
   s.summary     = "uWSGI"
   s.description = "The uWSGI server for Ruby/Rack"
   s.authors     = ["Unbit"]
diff --git a/uwsgi.h b/uwsgi.h
index 1c76383..40c0646 100644
--- a/uwsgi.h
+++ b/uwsgi.h
@@ -6,6 +6,10 @@
 extern "C" {
 #endif
 
+#define UWSGI_PLUGIN_API	2
+
+#define UWSGI_HAS_OFFLOAD_UBUFS 1
+
 #define UMAX16	65536
 #define UMAX8	256
 
@@ -604,6 +608,8 @@ struct uwsgi_daemon {
 
 	int ns_pid;
 	int throttle;
+
+	char *chdir;
 };
 
 struct uwsgi_logger {
@@ -830,6 +836,8 @@ struct uwsgi_cache {
 	int purge_lru;
 	uint64_t lru_head;
 	uint64_t lru_tail;
+
+	int store_delete;
 };
 
 struct uwsgi_option {
@@ -996,6 +1004,7 @@ struct uwsgi_protocol {
 };
 
 struct uwsgi_server;
+struct uwsgi_instance;
 
 struct uwsgi_plugin {
 
@@ -1054,6 +1063,9 @@ struct uwsgi_plugin {
         struct uwsgi_buffer* (*exception_msg)(struct wsgi_request *);
         struct uwsgi_buffer* (*exception_repr)(struct wsgi_request *);
         void (*exception_log)(struct wsgi_request *);
+
+	void (*vassal)(struct uwsgi_instance *);
+	void (*vassal_before_exec)(struct uwsgi_instance *, char **);
 };
 
 #ifdef UWSGI_PCRE
@@ -1271,7 +1283,7 @@ struct uwsgi_alarm_log {
 
 struct __attribute__ ((packed)) uwsgi_header {
 	uint8_t modifier1;
-	uint16_t pktsize;
+	uint16_t _pktsize;
 	uint8_t modifier2;
 };
 
@@ -1572,6 +1584,9 @@ struct wsgi_request {
 	int do_not_account_avg_rt;
 	// used for protocol parsers requiring EOF signaling
 	int proto_parser_eof;
+
+	// uWSGI 2.1
+	uint64_t len;
 };
 
 
@@ -1687,6 +1702,8 @@ struct uwsgi_fsmon {
 	struct uwsgi_fsmon *next;
 };
 
+struct uwsgi_subscription_client;
+
 struct uwsgi_server {
 
 	// store the machine hostname
@@ -2359,7 +2376,8 @@ struct uwsgi_server {
 
 	int udp_fd;
 
-	uint16_t buffer_size;
+	// removed in 2.1, here for ABI compatibility
+	uint16_t __buffer_size;
 	int signal_bufsize;
 
 	// post buffering
@@ -2636,7 +2654,7 @@ struct uwsgi_server {
 	struct uwsgi_string_list *subscriptions;
 	struct uwsgi_string_list *subscriptions2;
 
-	struct uwsgi_subscribe_node *(*subscription_algo) (struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *);
+	struct uwsgi_subscribe_node *(*subscription_algo) (struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *);
 	int subscription_dotsplit;
 
 	int never_swap;
@@ -2717,12 +2735,44 @@ struct uwsgi_server {
 
 	int mule_reload_mercy;
 	int alarm_cheap;
-
 	int emperor_no_blacklist;
 	int metrics_no_cores;
 	int stats_no_cores;
 	int stats_no_metrics;
 
+	// uWSGI 2.0.7
+	int vassal_sos;
+
+	// uWSGI 2.0.8
+	struct uwsgi_string_list *wait_for_fs;
+	struct uwsgi_string_list *wait_for_dir;
+	struct uwsgi_string_list *wait_for_file;
+	int wait_for_fs_timeout;
+	struct uwsgi_string_list *wait_for_mountpoint;
+
+	// uWSGI 2.1
+	char *fork_socket;
+	int new_argc;
+	char **new_argv;
+	char *emperor_use_fork_server;
+	struct uwsgi_string_list *vassal_fork_base;
+	struct uwsgi_string_list *emperor_collect_attributes;
+	char *emperor_fork_server_attr;
+	char *emperor_wrapper_attr;
+	int emperor_subreaper;
+        struct uwsgi_string_list *hook_as_on_demand_vassal;
+	uint64_t max_requests_delta;
+	char *emperor_chdir_attr;
+	struct uwsgi_string_list *subscription_algos;
+	int subscription_mountpoints;
+	struct uwsgi_string_list *hook_as_emperor_before_vassal;
+	struct uwsgi_string_list *hook_as_vassal_before_drop;
+	struct uwsgi_string_list *hook_as_emperor_setns;
+	int emperor_force_config_pipe;
+	struct uwsgi_string_list *hook_as_on_config_vassal;
+	int async_warn_if_queue_full;
+	char *zeus;
+	uint64_t buffer_size;
 };
 
 struct uwsgi_rpc {
@@ -2850,7 +2900,6 @@ struct uwsgi_shared {
 
 struct uwsgi_core {
 
-	//time_t harakiri;
 
 	uint64_t requests;
 	uint64_t failed_requests;
@@ -2876,6 +2925,10 @@ struct uwsgi_core {
 	char *post_buf;
 
 	struct wsgi_request req;
+
+	// uWSGI 2.1
+	time_t harakiri;
+	time_t user_harakiri;
 };
 
 struct uwsgi_worker {
@@ -2891,8 +2944,10 @@ struct uwsgi_worker {
 	uint64_t delta_requests;
 	uint64_t failed_requests;
 
-	time_t harakiri;
-	time_t user_harakiri;
+	// renamed in 2.1 (was 'harakiri')
+	time_t harakiri_unused;
+	// renamed in 2.1 (was 'user_harakiri')
+	time_t user_harakiri_unused;
 	uint64_t harakiri_count;
 	int pending_harakiri;
 
@@ -3014,6 +3069,7 @@ void uwsgi_xml_config(char *, struct wsgi_request *, char *[]);
 void uwsgi_500(struct wsgi_request *);
 void uwsgi_403(struct wsgi_request *);
 void uwsgi_404(struct wsgi_request *);
+void uwsgi_405(struct wsgi_request *);
 void uwsgi_redirect_to_slash(struct wsgi_request *);
 
 void manage_snmp(int, uint8_t *, int, struct sockaddr_in *);
@@ -3025,15 +3081,21 @@ char *uwsgi_spool_request(struct wsgi_request *, char *, size_t, char *, size_t)
 void spooler(struct uwsgi_spooler *);
 pid_t spooler_start(struct uwsgi_spooler *);
 
+#ifdef _GNU_SOURCE
+#define uwsgi_versionsort versionsort
+#else
+int uwsgi_versionsort(const struct dirent **da, const struct dirent **db);
+#endif
+
 void uwsgi_curse(int, int);
 void uwsgi_curse_mule(int, int);
 void uwsgi_destroy_processes(void);
 
-void set_harakiri(int);
-void set_user_harakiri(int);
+void set_harakiri(struct wsgi_request *, int);
+void set_user_harakiri(struct wsgi_request *, int);
 void set_mule_harakiri(int);
 void set_spooler_harakiri(int);
-void inc_harakiri(int);
+void inc_harakiri(struct wsgi_request *, int);
 
 #ifdef __BIG_ENDIAN__
 uint16_t uwsgi_swap16(uint16_t);
@@ -3057,6 +3119,7 @@ struct wsgi_request *find_first_accepting_wsgi_req(void);
 struct wsgi_request *find_wsgi_req_by_fd(int);
 struct wsgi_request *find_wsgi_req_by_id(int);
 void async_schedule_to_req_green(void);
+void async_schedule_to_req(void);
 
 int async_add_fd_write(struct wsgi_request *, int, int);
 int async_add_fd_read(struct wsgi_request *, int, int);
@@ -3221,7 +3284,7 @@ int uwsgi_register_signal(uint8_t, char *, void *, uint8_t);
 int uwsgi_add_file_monitor(uint8_t, char *);
 int uwsgi_add_timer(uint8_t, int);
 int uwsgi_signal_add_rb_timer(uint8_t, int, int);
-int uwsgi_signal_handler(uint8_t);
+int uwsgi_signal_handler(struct wsgi_request *, uint8_t);
 
 void uwsgi_route_signal(uint8_t);
 
@@ -3310,6 +3373,13 @@ struct uwsgi_subscribe_req {
 
 	char *notify;
 	uint16_t notify_len;
+
+	uint64_t backup_level;
+
+	char *proto;
+	uint16_t proto_len;
+
+	struct uwsgi_subscribe_node *(*algo) (struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *);
 };
 
 void uwsgi_nuclear_blast();
@@ -3391,14 +3461,15 @@ void uwsgi_proto_base_close(struct wsgi_request *);
 int uwsgi_proto_ssl_accept(struct wsgi_request *, int);
 void uwsgi_proto_ssl_close(struct wsgi_request *);
 #endif
-uint16_t proto_base_add_uwsgi_header(struct wsgi_request *, char *, uint16_t, char *, uint16_t);
-uint16_t proto_base_add_uwsgi_var(struct wsgi_request *, char *, uint16_t, char *, uint16_t);
+uint64_t proto_base_add_uwsgi_header(struct wsgi_request *, char *, uint16_t, char *, uint16_t);
+uint64_t proto_base_add_uwsgi_var(struct wsgi_request *, char *, uint16_t, char *, uint16_t);
 
 // protocols
 void uwsgi_proto_uwsgi_setup(struct uwsgi_socket *);
 void uwsgi_proto_puwsgi_setup(struct uwsgi_socket *);
 void uwsgi_proto_raw_setup(struct uwsgi_socket *);
 void uwsgi_proto_http_setup(struct uwsgi_socket *);
+void uwsgi_proto_http11_setup(struct uwsgi_socket *);
 #ifdef UWSGI_SSL
 void uwsgi_proto_https_setup(struct uwsgi_socket *);
 void uwsgi_proto_suwsgi_setup(struct uwsgi_socket *);
@@ -3539,6 +3610,11 @@ struct uwsgi_mule_farm *uwsgi_mule_farm_new(struct uwsgi_mule_farm **, struct uw
 int uwsgi_farm_has_mule(struct uwsgi_farm *, int);
 struct uwsgi_farm *get_farm_by_name(char *);
 
+struct uwsgi_subscription_client {
+	int fd;
+	union uwsgi_sockaddr *sockaddr;
+	char *cookie;
+};
 
 struct uwsgi_subscribe_node {
 
@@ -3578,6 +3654,11 @@ struct uwsgi_subscribe_node {
 	struct uwsgi_subscribe_slot *slot;
 
 	struct uwsgi_subscribe_node *next;
+
+	// uWSGI 2.1
+	uint64_t backup_level;
+	//here the solution is a bit hacky, we take the first letter of the proto ('u','\0' -> uwsgi, 'h' -> http, 'f' -> fastcgi, 's' -> scgi)
+	char proto;
 };
 
 struct uwsgi_subscribe_slot {
@@ -3600,6 +3681,9 @@ struct uwsgi_subscribe_slot {
 	uint8_t sni_enabled;
 #endif
 
+	// uWSGI 2.1 (algo is required)
+        struct uwsgi_subscribe_node *(*algo) (struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *);
+
 };
 
 void mule_send_msg(int, char *, size_t);
@@ -3609,13 +3693,13 @@ void create_signal_pipe(int *);
 void create_msg_pipe(int *, int);
 struct uwsgi_subscribe_slot *uwsgi_get_subscribe_slot(struct uwsgi_subscribe_slot **, char *, uint16_t);
 struct uwsgi_subscribe_node *uwsgi_get_subscribe_node_by_name(struct uwsgi_subscribe_slot **, char *, uint16_t, char *, uint16_t);
-struct uwsgi_subscribe_node *uwsgi_get_subscribe_node(struct uwsgi_subscribe_slot **, char *, uint16_t);
+struct uwsgi_subscribe_node *uwsgi_get_subscribe_node(struct uwsgi_subscribe_slot **, char *, uint16_t, struct uwsgi_subscription_client *);
 int uwsgi_remove_subscribe_node(struct uwsgi_subscribe_slot **, struct uwsgi_subscribe_node *);
 struct uwsgi_subscribe_node *uwsgi_add_subscribe_node(struct uwsgi_subscribe_slot **, struct uwsgi_subscribe_req *);
 
 ssize_t uwsgi_mule_get_msg(int, int, char *, size_t, int);
 
-int uwsgi_signal_wait(int);
+int uwsgi_signal_wait(struct wsgi_request *, int);
 struct uwsgi_app *uwsgi_add_app(int, uint8_t, char *, int, void *, void *);
 int uwsgi_signal_send(int, uint8_t);
 int uwsgi_remote_signal_send(char *, uint8_t);
@@ -3790,6 +3874,8 @@ int uwsgi_logic_opt_if_reload(char *, char *);
 int uwsgi_logic_opt_if_not_reload(char *, char *);
 int uwsgi_logic_opt_if_plugin(char *, char *);
 int uwsgi_logic_opt_if_not_plugin(char *, char *);
+int uwsgi_logic_opt_if_hostname(char *, char *);
+int uwsgi_logic_opt_if_not_hostname(char *, char *);
 
 
 void uwsgi_opt_resolve(char *, char *, void *);
@@ -3875,7 +3961,7 @@ int uwsgi_is_file2(char *, struct stat *);
 int uwsgi_is_dir(char *);
 int uwsgi_is_link(char *);
 
-void uwsgi_receive_signal(int, char *, int);
+void uwsgi_receive_signal(struct wsgi_request *, int, char *, int);
 void uwsgi_exec_atexit(void);
 
 struct uwsgi_stats {
@@ -4070,6 +4156,11 @@ struct uwsgi_instance {
 	int on_demand_fd;
 	char *socket_name;
 	time_t cursed_at;
+
+	int adopted;
+
+	// uWSGI 2.1 (vassal's attributes)
+	struct uwsgi_dyn_dict *attrs;
 };
 
 struct uwsgi_instance *emperor_get_by_fd(int);
@@ -4078,6 +4169,7 @@ void emperor_stop(struct uwsgi_instance *);
 void emperor_curse(struct uwsgi_instance *);
 void emperor_respawn(struct uwsgi_instance *, time_t);
 void emperor_add(struct uwsgi_emperor_scanner *, char *, time_t, char *, uint32_t, uid_t, gid_t, char *);
+void emperor_add_with_attrs(struct uwsgi_emperor_scanner *, char *, time_t, char *, uint32_t, uid_t, gid_t, char *, struct uwsgi_dyn_dict *);
 void emperor_back_to_ondemand(struct uwsgi_instance *);
 
 void uwsgi_exec_command_with_args(char *);
@@ -4158,6 +4250,7 @@ void uwsgi_master_cleanup_hooks(void);
 pid_t uwsgi_daemonize2();
 
 void uwsgi_emperor_simple_do(struct uwsgi_emperor_scanner *, char *, char *, time_t, uid_t, gid_t, char *);
+void uwsgi_emperor_simple_do_with_attrs(struct uwsgi_emperor_scanner *, char *, char *, time_t, uid_t, gid_t, char *, struct uwsgi_dyn_dict *);
 
 #if defined(__linux__)
 #define UWSGI_ELF
@@ -4228,6 +4321,28 @@ struct uwsgi_offload_request {
 
 	struct uwsgi_offload_request *prev;
 	struct uwsgi_offload_request *next;
+
+	// added in 2.1
+	struct uwsgi_buffer *ubuf1;
+	struct uwsgi_buffer *ubuf2;
+	struct uwsgi_buffer *ubuf3;
+	struct uwsgi_buffer *ubuf4;
+	struct uwsgi_buffer *ubuf5;
+	struct uwsgi_buffer *ubuf6;
+	struct uwsgi_buffer *ubuf7;
+	struct uwsgi_buffer *ubuf8;
+
+	int64_t custom1;
+	int64_t custom2;
+	int64_t custom3;
+	int64_t custom4;
+	int64_t custom5;
+	int64_t custom6;
+	int64_t custom7;
+	int64_t custom8;
+
+	void *data;
+	void (*free)(struct uwsgi_offload_request *);
 };
 
 struct uwsgi_offload_engine {
@@ -4568,6 +4683,7 @@ int uwsgi_umount(char *, char *);
 int uwsgi_mount_hook(char *);
 int uwsgi_umount_hook(char *);
 
+int uwsgi_hooks_run_and_return(struct uwsgi_string_list *, char *, char *, int);
 void uwsgi_hooks_run(struct uwsgi_string_list *, char *, int);
 void uwsgi_register_hook(char *, int (*)(char *));
 struct uwsgi_hook *uwsgi_hook_by_name(char *);
@@ -4585,6 +4701,7 @@ void uwsgi_master_fifo_prepare();
 int uwsgi_master_fifo();
 int uwsgi_master_fifo_manage(int);
 
+void uwsgi_log_do_rotate(char *, char *, off_t, int);
 void uwsgi_log_rotate();
 void uwsgi_log_reopen();
 void uwsgi_reload_workers();
@@ -4600,7 +4717,7 @@ void uwsgi_go_cheap();
 
 char **uwsgi_split_quoted(char *, size_t, char *, size_t *);
 
-void uwsgi_master_manage_emperor_proxy();
+void uwsgi_master_manage_emperor_proxy(int, int, int, int);
 struct uwsgi_string_list *uwsgi_register_scheme(char *, char * (*)(char *, size_t *, int));
 void uwsgi_setup_schemes(void);
 
@@ -4783,7 +4900,42 @@ mode_t uwsgi_mode_t(char *, int *);
 
 int uwsgi_notify_socket_manage(int);
 int uwsgi_notify_msg(char *, char *, size_t);
+void vassal_sos();
+
+int uwsgi_send_fds_and_body(int, int *, int, char *, size_t);
+ssize_t uwsgi_recv_cred_and_fds(int, char *, size_t buf_len, pid_t *, uid_t *, gid_t *, int *, int *);
+void uwsgi_fork_server(char *);
+
+void uwsgi_emperor_ini_attrs(char *, char *, struct uwsgi_dyn_dict **);
+
+int uwsgi_buffer_httpdate(struct uwsgi_buffer *, time_t);
+int uwsgi_buffer_append_xml(struct uwsgi_buffer *, char *, size_t);
+
+struct uwsgi_buffer *uwsgi_webdav_multistatus_new();
+int uwsgi_webdav_propfind_item_add(struct uwsgi_buffer *, char *, uint16_t, uint64_t, time_t, char *, uint16_t, char *, uint16_t, char *, uint16_t);
+int uwsgi_webdav_multistatus_close(struct uwsgi_buffer *);
+int uwsgi_webdav_multistatus_response_new(struct uwsgi_buffer *);
+int uwsgi_webdav_multistatus_response_close(struct uwsgi_buffer *);
+int uwsgi_webdav_multistatus_propstat_new(struct uwsgi_buffer *);
+int uwsgi_webdav_multistatus_propstat_close(struct uwsgi_buffer *);
+int uwsgi_webdav_multistatus_prop_new(struct uwsgi_buffer *);
+int uwsgi_webdav_multistatus_prop_close(struct uwsgi_buffer *);
+
+struct uwsgi_subscribe_node *(*uwsgi_subscription_algo_get(char * , size_t))(struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *);
+
+void uwsgi_subscription_init_algos(void);
+void uwsgi_register_subscription_algo(char *, struct uwsgi_subscribe_node *(*) (struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *));
+char *uwsgi_subscription_algo_name(void *);
+
+int uwsgi_wait_for_fs(char *, int);
+int uwsgi_wait_for_mountpoint(char *);
+void uwsgi_hooks_setns_run(struct uwsgi_string_list *, pid_t, uid_t, gid_t);
+char *vassal_attr_get(struct uwsgi_instance *, char *);
+int vassal_attr_get_multi(struct uwsgi_instance *, char *, int (*)(struct uwsgi_instance *, char *, void *), void *);
+
+int uwsgi_zeus_spawn_instance(struct uwsgi_instance *);
 
+time_t uwsgi_parse_http_date(char *, uint16_t);
 #ifdef __cplusplus
 }
 #endif
diff --git a/uwsgiconfig.py b/uwsgiconfig.py
index a4bc987..b8aa948 100644
--- a/uwsgiconfig.py
+++ b/uwsgiconfig.py
@@ -53,6 +53,11 @@ if CPUCOUNT < 1:
         except:
             CPUCOUNT = 1
 
+
+# force single cpu in cygwin mode
+if uwsgi_os.startswith('CYGWIN'):
+    CPUCOUNT=1
+
 binary_list = []
 
 started_at = time.time()
@@ -398,18 +403,26 @@ def build_uwsgi(uc, print_only=False, gcll=None):
 
                 path = path.rstrip('/')
 
-                if not os.path.isdir(path):
+                up = {}
+
+               	if os.path.isfile(path):
+                    bname = os.path.basename(path)
+                    # override path
+                    path = os.path.dirname(path)
+                    up['GCC_LIST'] = [bname]
+                    up['NAME'] = bname.split('.')[0]
+                    if not path: path = '.' 
+                elif os.path.isdir(path):
+                    try:
+                        execfile('%s/uwsgiplugin.py' % path, up)
+                    except:
+                        f = open('%s/uwsgiplugin.py' % path)
+                        exec(f.read(), up)
+                        f.close() 
+                else:
                     print("Error: plugin '%s' not found" % p)
                     sys.exit(1)
 
-                up = {}
-                try:
-                    execfile('%s/uwsgiplugin.py' % path, up)
-                except:
-                    f = open('%s/uwsgiplugin.py' % path)
-                    exec(f.read(), up)
-                    f.close()
-
                 p_cflags = cflags[:]
                 try:
                     p_cflags += up['CFLAGS']
@@ -602,7 +615,7 @@ class uConf(object):
             'core/setup_utils', 'core/clock', 'core/init', 'core/buffer', 'core/reader', 'core/writer', 'core/alarm', 'core/cron', 'core/hooks',
             'core/plugins', 'core/lock', 'core/cache', 'core/daemons', 'core/errors', 'core/hash', 'core/master_events', 'core/chunked',
             'core/queue', 'core/event', 'core/signal', 'core/strings', 'core/progress', 'core/timebomb', 'core/ini', 'core/fsmon', 'core/mount',
-            'core/metrics', 'core/plugins_builder', 'core/sharedarea',
+            'core/metrics', 'core/plugins_builder', 'core/sharedarea', 'core/fork_server', 'core/webdav', 'core/zeus',
             'core/rpc', 'core/gateway', 'core/loop', 'core/cookie', 'core/querystring', 'core/rb_timers', 'core/transformations', 'core/uwsgi']
         # add protocols
         self.gcc_list.append('proto/base')
diff --git a/uwsgidecorators.py b/uwsgidecorators.py
index ec24edc..290ee66 100644
--- a/uwsgidecorators.py
+++ b/uwsgidecorators.py
@@ -18,6 +18,29 @@ mule_functions = {}
 postfork_chain = []
 
 
+# Python3 compatibility
+def _encode1(val):
+    if sys.version_info >= (3, 0) and isinstance(val, str):
+        return val.encode('utf-8')
+    else:
+        return val
+
+
+def _decode1(val):
+    if sys.version_info >= (3, 0) and isinstance(val, bytes):
+        return val.decode('utf-8')
+    else:
+        return val
+
+
+def _encode_to_spooler(vars):
+    return dict((_encode1(K), _encode1(V)) for (K, V) in vars.items())
+
+
+def _decode_from_spooler(vars):
+    return dict((_decode1(K), _decode1(V)) for (K, V) in vars.items())
+
+
 def get_free_signal():
     for signum in range(0, 256):
         if not uwsgi.signal_registered(signum):
@@ -27,6 +50,7 @@ def get_free_signal():
 
 
 def manage_spool_request(vars):
+    vars = _decode_from_spooler(vars)
     f = spooler_functions[vars['ud_spool_func']]
     if 'args' in vars:
         args = pickle.loads(vars.pop('args'))
@@ -48,6 +72,7 @@ uwsgi.post_fork_hook = postfork_chain_hook
 
 
 class postfork(object):
+
     def __init__(self, f):
         if callable(f):
             self.wid = 0
@@ -56,6 +81,7 @@ class postfork(object):
             self.f = None
             self.wid = f
         postfork_chain.append(self)
+
     def __call__(self, *args, **kwargs):
         if self.f:
             if self.wid > 0 and self.wid != uwsgi.worker_id():
@@ -67,7 +93,7 @@ class postfork(object):
 class _spoolraw(object):
 
     def __call__(self, *args, **kwargs):
-        arguments = self.base_dict
+        arguments = self.base_dict.copy()
         if not self.pass_arguments:
             if len(args) > 0:
                 arguments.update(args[0])
@@ -79,8 +105,9 @@ class _spoolraw(object):
                 if key in kwargs:
                     spooler_args.update({key: kwargs.pop(key)})
             arguments.update(spooler_args)
-            arguments.update({'args': pickle.dumps(args), 'kwargs': pickle.dumps(kwargs)})
-        return uwsgi.spool(arguments)
+            arguments.update(
+                {'args': pickle.dumps(args), 'kwargs': pickle.dumps(kwargs)})
+        return uwsgi.spool(_encode_to_spooler(arguments))
 
     # For backward compatibility (uWSGI < 1.9.13)
     def spool(self, *args, **kwargs):
@@ -234,6 +261,7 @@ class mule_brainloop(mule_brain):
 
 
 class mule(object):
+
     def __init__(self, num):
         self.num = num
 
@@ -242,6 +270,7 @@ class mule(object):
 
 
 class muleloop(mule):
+
     def __call__(self, f):
         postfork_chain.append(mule_brainloop(f, self.num))
 
@@ -261,6 +290,7 @@ class mulemsg_loop(object):
 
 
 class mulemsg(object):
+
     def __init__(self, num):
         self.num = num
 
@@ -306,7 +336,7 @@ class cron(object):
     def __call__(self, f):
         uwsgi.register_signal(self.num, self.target, f)
         uwsgi.add_cron(self.num, self.minute, self.hour,
-            self.day, self.month, self.dayweek)
+                       self.day, self.month, self.dayweek)
         return f
 
 
@@ -347,6 +377,7 @@ class erlang(object):
 
 
 class lock(object):
+
     def __init__(self, f):
         self.f = f
 
