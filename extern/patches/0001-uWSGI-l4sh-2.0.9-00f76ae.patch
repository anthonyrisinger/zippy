diff --git a/.gitignore b/.gitignore
index 299bd35..6ee1a02 100644
--- a/.gitignore
+++ b/.gitignore
@@ -22,3 +22,7 @@ core/dot_h.c
 +# coverity
 +/cov-int/
 +uwsgi.tar.xz
+
+/build/
+/dist/
+/uWSGI.egg-info/
diff --git a/CONTRIBUTORS b/CONTRIBUTORS
index 12979d6..f331222 100644
--- a/CONTRIBUTORS
+++ b/CONTRIBUTORS
@@ -29,4 +29,5 @@ Danila Shtan <danila@shtan.ru>
 Ævar Arnfjörð Bjarmason
 Yu Zhao (getcwd)
 Mathieu Dupuy
+Mike Kaplinskiy
 Adriano Di Luzio (adriano@unbit.it)
diff --git a/apache2/mod_proxy_uwsgi.c b/apache2/mod_proxy_uwsgi.c
index 262ba58..533950c 100644
--- a/apache2/mod_proxy_uwsgi.c
+++ b/apache2/mod_proxy_uwsgi.c
@@ -365,13 +365,12 @@ static int uwsgi_response(request_rec *r, proxy_conn_rec *backend, proxy_server_
                 ap_set_content_type(r, apr_pstrdup(r->pool, buf));
             }
 	
-	int finish = 0;
-	while(!finish) {
+	for(;;) {
 		rv = ap_get_brigade(rp->input_filters, bb,
                                         AP_MODE_READBYTES, mode,
                                         conf->io_buffer_size);
-		if (APR_STATUS_IS_EAGAIN(rv)
-                        || (rv == APR_SUCCESS && APR_BRIGADE_EMPTY(bb)) ) {
+		if (mode == APR_NONBLOCK_READ && (APR_STATUS_IS_EAGAIN(rv)
+                        || (rv == APR_SUCCESS && APR_BRIGADE_EMPTY(bb)))) {
 			e = apr_bucket_flush_create(c->bucket_alloc);
 			APR_BRIGADE_INSERT_TAIL(bb, e);
 			if (ap_pass_brigade(r->output_filters, bb) || c->aborted) {
@@ -402,16 +401,7 @@ static int uwsgi_response(request_rec *r, proxy_conn_rec *backend, proxy_server_
 
 		ap_proxy_buckets_lifetime_transform(r, bb, pass_bb);
 
-		// found the last brigade?
-		if (APR_BUCKET_IS_EOS(APR_BRIGADE_LAST(bb))) finish = 1;
-
-		// do not pass chunk if it is zero_sized
-		apr_brigade_length(pass_bb, 0, &readbytes);
-
-		if ((readbytes > 0 && ap_pass_brigade(r->output_filters, pass_bb) != APR_SUCCESS) || c->aborted) {
-			finish = 1;
-		}
-
+		ap_pass_brigade(r->output_filters, pass_bb);
 		apr_brigade_cleanup(bb);
 		apr_brigade_cleanup(pass_bb);
 	}
diff --git a/buildconf/all.ini b/buildconf/all.ini
index 2410a7d..7d2a223 100644
--- a/buildconf/all.ini
+++ b/buildconf/all.ini
@@ -1,3 +1,3 @@
 [uwsgi]
-main_plugin = python,gevent,psgi,lua,php,rack,jvm,jwsgi,ring,mono,transformation_toupper,coroae,v8,cgi,xslt,webdav,ssi,ldap,gccgo,rados,pypy,zabbix,curl_cron,tornado,tuntap,pty,mongrel2,alarm_curl,router_radius,airbrake
+main_plugin = python,gevent,psgi,lua,php,rack,jvm,jwsgi,ring,mono,transformation_toupper,coroae,v8,cgi,xslt,webdav,ssi,ldap,gccgo,rados,pypy,zabbix,curl_cron,tornado,tuntap,pty,mongrel2,alarm_curl,router_radius,airbrake,gridfs
 inherit = base
diff --git a/contrib/pypy/uwsgi_pypy_greenlets.py b/contrib/pypy/uwsgi_pypy_greenlets.py
index f915caf..7843f17 100644
--- a/contrib/pypy/uwsgi_pypy_greenlets.py
+++ b/contrib/pypy/uwsgi_pypy_greenlets.py
@@ -54,7 +54,7 @@ def uwsgi_pypy_greenlet_switch(wsgi_req):
     # update current running greenlet
     lib.uwsgi.wsgi_req = wsgi_req
 
-if lib.uwsgi.async <= 1:
+if lib.uwsgi.async < 1:
     raise Exception("pypy greenlets require async mode !!!")
 lib.uwsgi.schedule_to_main = uwsgi_pypy_greenlet_switch
 lib.uwsgi.schedule_to_req = uwsgi_pypy_greenlet_schedule
diff --git a/core/async.c b/core/async.c
index 6c89ed2..c3da5cd 100644
--- a/core/async.c
+++ b/core/async.c
@@ -21,7 +21,7 @@ extern struct uwsgi_server uwsgi;
 
 // this is called whenever a new connection is ready, but there are no cores to handle it
 void uwsgi_async_queue_is_full(time_t now) {
-	if (now > uwsgi.async_queue_is_full) {
+	if (now > uwsgi.async_queue_is_full && uwsgi.async_warn_if_queue_full) {
 		uwsgi_log_verbose("[DANGER] async queue is full !!!\n");
 		uwsgi.async_queue_is_full = now;
 	}
@@ -165,7 +165,7 @@ static void async_expire_timeouts(uint64_t now) {
 
 int async_add_fd_read(struct wsgi_request *wsgi_req, int fd, int timeout) {
 
-	if (uwsgi.async < 2 || !uwsgi.async_waiting_fd_table){ 
+	if (uwsgi.async < 1 || !uwsgi.async_waiting_fd_table){ 
 		uwsgi_log_verbose("ASYNC call without async mode !!!\n");
 		return -1;
 	}
@@ -257,7 +257,7 @@ static int async_wait_fd_read2(int fd0, int fd1, int timeout, int *fd) {
 
 void async_add_timeout(struct wsgi_request *wsgi_req, int timeout) {
 
-	if (uwsgi.async < 2 || !uwsgi.rb_async_timeouts) {
+	if (uwsgi.async < 1 || !uwsgi.rb_async_timeouts) {
 		uwsgi_log_verbose("ASYNC call without async mode !!!\n");
 		return;
 	}
@@ -272,7 +272,7 @@ void async_add_timeout(struct wsgi_request *wsgi_req, int timeout) {
 
 int async_add_fd_write(struct wsgi_request *wsgi_req, int fd, int timeout) {
 
-	if (uwsgi.async < 2 || !uwsgi.async_waiting_fd_table) {
+	if (uwsgi.async < 1 || !uwsgi.async_waiting_fd_table) {
 		uwsgi_log_verbose("ASYNC call without async mode !!!\n");
 		return -1;
 	}
@@ -370,7 +370,7 @@ void async_schedule_to_req_green(void) {
 		}
                 // switch after each yield
 		if (uwsgi.schedule_to_main)
-			uwsgi.schedule_to_main(wsgi_req);
+                	uwsgi.schedule_to_main(wsgi_req);
         }
 
 #ifdef UWSGI_ROUTING
@@ -385,7 +385,6 @@ end:
         wsgi_req->async_status = UWSGI_OK;
 	uwsgi.async_queue_unused_ptr++;
         uwsgi.async_queue_unused[uwsgi.async_queue_unused_ptr] = wsgi_req;
-	
 }
 
 static int uwsgi_async_wait_milliseconds_hook(int timeout) {
@@ -407,7 +406,7 @@ static int uwsgi_async_wait_milliseconds_hook(int timeout) {
 
 void async_loop() {
 
-	if (uwsgi.async < 2) {
+	if (uwsgi.async < 1) {
 		uwsgi_log("the async loop engine requires async mode (--async <n>)\n");
 		exit(1);
 	}
@@ -482,7 +481,12 @@ void async_loop() {
 
 			// signals are executed in the main stack... in the future we could have dedicated stacks for them
 			if (uwsgi.signal_socket > -1 && (interesting_fd == uwsgi.signal_socket || interesting_fd == uwsgi.my_signal_socket)) {
-				uwsgi_receive_signal(interesting_fd, "worker", uwsgi.mywid);
+				uwsgi.wsgi_req = find_first_available_wsgi_req();
+                                if (uwsgi.wsgi_req == NULL) {
+                                	uwsgi_async_queue_is_full((time_t)now);
+                                        continue; 
+                                }
+				uwsgi_receive_signal(uwsgi.wsgi_req, interesting_fd, "worker", uwsgi.mywid);
 				continue;
 			}
 
diff --git a/core/buffer.c b/core/buffer.c
index d1f3f3a..e880069 100644
--- a/core/buffer.c
+++ b/core/buffer.c
@@ -150,6 +150,32 @@ int uwsgi_buffer_append_json(struct uwsgi_buffer *ub, char *buf, size_t len) {
 	return 0;
 }
 
+int uwsgi_buffer_append_xml(struct uwsgi_buffer *ub, char *buf, size_t len) {
+        // need to escape \ and "
+        size_t i;
+        for(i=0;i<len;i++) {
+                if (buf[i] == '"') {
+                        if (uwsgi_buffer_append(ub, "&quot;", 6)) return -1;
+                }
+                else if (buf[i] == '\'') {
+                        if (uwsgi_buffer_append(ub, "&apos;", 6)) return -1;
+                }
+                else if (buf[i] == '<') {
+                        if (uwsgi_buffer_append(ub, "&lt;", 4)) return -1;
+                }
+                else if (buf[i] == '>') {
+                        if (uwsgi_buffer_append(ub, "&gt;", 4)) return -1;
+                }
+                else if (buf[i] == '&') {
+                        if (uwsgi_buffer_append(ub, "&amp;", 5)) return -1;
+                }
+                else {
+                        if (uwsgi_buffer_append(ub, buf+i, 1)) return -1;
+                }
+        }
+        return 0;
+}
+
 int uwsgi_buffer_u16le(struct uwsgi_buffer *ub, uint16_t num) {
 	uint8_t buf[2];
 	buf[0] = (uint8_t) (num & 0xff);
@@ -418,3 +444,10 @@ void uwsgi_buffer_map(struct uwsgi_buffer *ub, char *buf, size_t len) {
 	ub->pos = len;
 	ub->len = len;
 }
+
+int uwsgi_buffer_httpdate(struct uwsgi_buffer *ub, time_t t) {
+	char http_last_modified[49];
+        int size = uwsgi_http_date(t, http_last_modified);
+	if (size <= 0) return -1;
+	return uwsgi_buffer_append(ub, http_last_modified, size);
+}
diff --git a/core/cache.c b/core/cache.c
index 8939501..c45d069 100644
--- a/core/cache.c
+++ b/core/cache.c
@@ -24,49 +24,6 @@ extern struct uwsgi_server uwsgi;
 
 */
 
-static void cache_full(struct uwsgi_cache *uc) {
-	uint64_t i;
-	int force_clear = 0;
-
-	if (!uc->ignore_full) {
-        	if (uc->purge_lru)
-                	uwsgi_log("LRU item will be purged from cache \"%s\"\n", uc->name);
-                else
-                	uwsgi_log("*** DANGER cache \"%s\" is FULL !!! ***\n", uc->name);
-	}
-
-        uc->full++;
-
-        if (uc->purge_lru && uc->lru_head)
-        	uwsgi_cache_del2(uc, NULL, 0, uc->lru_head, UWSGI_CACHE_FLAG_LOCAL);
-
-	// we do not need locking here !
-	if (uc->sweep_on_full) {
-		uint64_t removed = 0;
-		uint64_t now = (uint64_t) uwsgi_now();
-		if (uc->next_scan <= now) {
-			uc->next_scan = now + uc->sweep_on_full;
-                	for (i = 1; i < uc->max_items; i++) {
-				struct uwsgi_cache_item *uci = cache_item(i);
-				if (uci->expires > 0 && uci->expires <= now) {
-                			if (!uwsgi_cache_del2(uc, NULL, 0, i, 0)) {
-						removed++;
-					}
-				}
-			}
-			if (removed == 0) {
-				force_clear = 1;
-			}
-                }
-	}
-
-	if (uc->clear_on_full || force_clear) {
-                for (i = 1; i < uc->max_items; i++) {
-                	uwsgi_cache_del2(uc, NULL, 0, i, 0);
-                }
-	}
-}
-
 static uint64_t uwsgi_cache_find_free_blocks(struct uwsgi_cache *uc, uint64_t need) {
 	// how many blocks we need ?
 	uint64_t needed_blocks = need/uc->blocksize;
@@ -463,17 +420,6 @@ void uwsgi_cache_init(struct uwsgi_cache *uc) {
 
 }
 
-static uint64_t check_lazy(struct uwsgi_cache *uc, struct uwsgi_cache_item *uci, uint64_t slot) {
-	if (!uci->expires || !uc->lazy_expire) return slot;
-	uint64_t now = (uint64_t) uwsgi_now();
-	// expired ?
-	if (uci->expires <= now) {
-		uwsgi_cache_del2(uc, NULL, 0, slot, UWSGI_CACHE_FLAG_LOCAL);
-		return 0;
-	}
-	return slot;
-}
-
 static uint64_t uwsgi_cache_get_index(struct uwsgi_cache *uc, char *key, uint16_t keylen) {
 
 	uint32_t hash = uc->hash->func(key, keylen);
@@ -499,7 +445,7 @@ static uint64_t uwsgi_cache_get_index(struct uwsgi_cache *uc, char *key, uint16_
 	if (memcmp(uci->key, key, keylen))
 		goto cycle;
 
-	return check_lazy(uc, uci, slot);
+	return slot;
 
 cycle:
 	while (uci->next) {
@@ -522,9 +468,8 @@ cycle:
 			continue;
 		if (uci->keysize != keylen)
 			continue;
-		if (!memcmp(uci->key, key, keylen)) {
-			return check_lazy(uc, uci, slot);
-		}
+		if (!memcmp(uci->key, key, keylen))
+			return slot;
 	}
 
 	return 0;
@@ -773,7 +718,15 @@ int uwsgi_cache_set2(struct uwsgi_cache *uc, char *key, uint16_t keylen, char *v
 	index = uwsgi_cache_get_index(uc, key, keylen);
 	if (!index) {
 		if (!uc->unused_blocks_stack_ptr) {
-			cache_full(uc);
+			if (!uc->ignore_full) {
+				if (uc->purge_lru)
+					uwsgi_log("LRU item will be purged from cache \"%s\"\n", uc->name);
+				else
+					uwsgi_log("*** DANGER cache \"%s\" is FULL !!! ***\n", uc->name);
+			}
+			uc->full++;
+			if (uc->purge_lru && uc->lru_head)
+				uwsgi_cache_del2(uc, NULL, 0, uc->lru_head, UWSGI_CACHE_FLAG_LOCAL);
 			if (!uc->unused_blocks_stack_ptr)
 				goto end;
 		}
@@ -788,8 +741,16 @@ int uwsgi_cache_set2(struct uwsgi_cache *uc, char *key, uint16_t keylen, char *v
 		else {
 			uci->first_block = uwsgi_cache_find_free_blocks(uc, vallen);
 			if (uci->first_block == 0xffffffffffffffffLLU) {
+				if (!uc->ignore_full) {
+					if (uc->purge_lru)
+                                        	uwsgi_log("LRU item will be purged from cache \"%s\"\n", uc->name);
+					else
+						uwsgi_log("*** DANGER cache \"%s\" is FULL !!! ***\n", uc->name);
+				}
+                                uc->full++;
 				uc->unused_blocks_stack_ptr++;
-				cache_full(uc);
+				if (uc->purge_lru && uc->lru_head)
+                                	uwsgi_cache_del2(uc, NULL, 0, uc->lru_head, UWSGI_CACHE_FLAG_LOCAL);
                                 goto end;
 			}
 			// mark used blocks;
@@ -890,8 +851,16 @@ int uwsgi_cache_set2(struct uwsgi_cache *uc, char *key, uint16_t keylen, char *v
 			uint64_t old_first_block = uci->first_block;
 			uci->first_block = uwsgi_cache_find_free_blocks(uc, vallen);
                         if (uci->first_block == 0xffffffffffffffffLLU) {
+				if (!uc->ignore_full) {
+                                        if (uc->purge_lru)
+                                                uwsgi_log("LRU item will be purged from cache \"%s\"\n", uc->name);
+                                        else
+                                                uwsgi_log("*** DANGER cache \"%s\" is FULL !!! ***\n", uc->name);
+                                }
+                                uc->full++;
 				uci->first_block = old_first_block;
-				cache_full(uc);
+				if (uc->purge_lru && uc->lru_head)
+                                        uwsgi_cache_del2(uc, NULL, 0, uc->lru_head, UWSGI_CACHE_FLAG_LOCAL);
                                 goto end;
                         }
                         // mark used blocks;
@@ -979,7 +948,7 @@ static void cache_send_udp_command(struct uwsgi_cache *uc, char *key, uint16_t k
 		iov[2].iov_base = key;
 		iov[2].iov_len = keylen;
 
-		uh.pktsize = 2 + keylen;
+		uh._pktsize = 2 + keylen;
 
 		if (cmd == 10) {
 			u_v[0] = (uint8_t) (vallen16 & 0xff);
@@ -1003,7 +972,7 @@ static void cache_send_udp_command(struct uwsgi_cache *uc, char *key, uint16_t k
                 	iov[6].iov_base = es;
                 	iov[6].iov_len = es_size;
 
-			uh.pktsize += 2 + vallen16 + 2 + es_size;
+			uh._pktsize += 2 + vallen16 + 2 + es_size;
 		}
 
 		uh.modifier1 = 111;
@@ -1103,7 +1072,7 @@ static uint64_t cache_sweeper_free_items(struct uwsgi_cache *uc) {
 	uint64_t i;
 	uint64_t freed_items = 0;
 
-	if (uc->no_expire || uc->purge_lru || uc->lazy_expire)
+	if (uc->no_expire || uc->purge_lru)
 		return 0;
 
 	uwsgi_rlock(uc->lock);
@@ -1182,24 +1151,20 @@ void uwsgi_cache_start_sweepers() {
 	if (uwsgi.cache_no_expire)
 		return;
 
-	int need_to_run = 0;
 	while(uc) {
-		if (!uc->no_expire && !uc->purge_lru && !uc->lazy_expire) {
-			need_to_run = 1;
+		pthread_t cache_sweeper;
+		if (!uc->no_expire && !uc->purge_lru) {
+                	if (pthread_create(&cache_sweeper, NULL, cache_sweeper_loop, uwsgi.caches)) {
+                        	uwsgi_error("pthread_create()");
+                        	uwsgi_log("unable to run the sweeper!!!\n");
+			}
+                	else {
+                        	uwsgi_log("sweeper thread enabled\n");
+                	}
 			break;
 		}
 		uc = uc->next;
         }
-
-	if (!need_to_run) return;
-
-	pthread_t cache_sweeper;
-        if (pthread_create(&cache_sweeper, NULL, cache_sweeper_loop, uwsgi.caches)) {
-        	uwsgi_error("uwsgi_cache_start_sweepers()/pthread_create()");
-                uwsgi_log("unable to run the cache sweeper!!!\n");
-		return;
-	}
-        uwsgi_log("cache sweeper thread enabled\n");
 }
 
 void uwsgi_cache_start_sync_servers() {
@@ -1276,10 +1241,6 @@ struct uwsgi_cache *uwsgi_cache_create(char *arg) {
 		char *c_math_initial = NULL;
 		char *c_ignore_full = NULL;
 		char *c_purge_lru = NULL;
-		char *c_lazy_expire = NULL;
-		char *c_sweep_on_full = NULL;
-		char *c_clear_on_full = NULL;
-		char *c_no_expire = NULL;
 
 		if (uwsgi_kvlist_parse(arg, strlen(arg), ',', '=',
                         "name", &c_name,
@@ -1312,11 +1273,6 @@ struct uwsgi_cache *uwsgi_cache_create(char *arg) {
                         "ignore_full", &c_ignore_full,
 			"purge_lru", &c_purge_lru,
 			"lru", &c_purge_lru,
-			"lazy_expire", &c_lazy_expire,
-			"lazy", &c_lazy_expire,
-			"sweep_on_full", &c_sweep_on_full,
-			"clear_on_full", &c_clear_on_full,
-			"no_expire", &c_no_expire,
                 	NULL)) {
 			uwsgi_log("unable to parse cache definition\n");
 			exit(1);
@@ -1370,13 +1326,6 @@ struct uwsgi_cache *uwsgi_cache_create(char *arg) {
 
 		if (c_math_initial) uc->math_initial = strtol(c_math_initial, NULL, 10);
 
-		if (c_lazy_expire) uc->lazy_expire = 1;
-		if (c_sweep_on_full) {
-			uc->sweep_on_full = uwsgi_n64(c_sweep_on_full);
-		}
-		if (c_clear_on_full) uc->clear_on_full = 1;
-		if (c_no_expire) uc->no_expire = 1;
-
 		uc->store_sync = uwsgi.cache_store_sync;
 		if (c_store_sync) { uc->store_sync = uwsgi_n64(c_store_sync); }
 
diff --git a/core/emperor.c b/core/emperor.c
index bfa709e..19d0f71 100644
--- a/core/emperor.c
+++ b/core/emperor.c
@@ -5,7 +5,6 @@ The uWSGI Emperor
 */
 #include <uwsgi.h>
 
-
 extern struct uwsgi_server uwsgi;
 extern char **environ;
 
@@ -13,7 +12,6 @@ void emperor_send_stats(int);
 
 time_t emperor_throttle;
 int emperor_throttle_level;
-int emperor_warming_up = 1;
 
 struct uwsgi_instance *ui;
 
@@ -38,6 +36,142 @@ struct uwsgi_emperor_blacklist_item {
 
 struct uwsgi_emperor_blacklist_item *emperor_blacklist;
 
+char *vassal_attr_get(struct uwsgi_instance *c_ui, char *attr) {
+	if (!attr) return NULL;
+	struct uwsgi_dyn_dict *attrs = c_ui->attrs;
+	while(attrs) {
+		if (!strcmp(attrs->key, attr)) {
+			return attrs->value;
+		}
+		attrs = attrs->next;
+	}
+	return NULL;
+}
+
+int vassal_attr_get_multi(struct uwsgi_instance *c_ui, char *attr, int (*func)(struct uwsgi_instance *, char *, void *), void *data) {
+	if (!attr) return -1;
+        struct uwsgi_dyn_dict *attrs = c_ui->attrs;
+        while(attrs) {
+                if (!strcmp(attrs->key, attr)) {
+			if (func(c_ui, attrs->value, data)) {
+				return -1;
+			}
+                }
+                attrs = attrs->next;
+        }
+        return 0;
+}
+
+// this generates the argv for the new vassal
+static char **vassal_new_argv(struct uwsgi_instance *n_ui, int *slot_to_free) {
+
+	int counter = 4;
+	struct uwsgi_string_list *uct;
+	uwsgi_foreach(uct, uwsgi.vassals_templates_before) counter += 2;
+	uwsgi_foreach(uct, uwsgi.vassals_includes_before) counter += 2;
+	uwsgi_foreach(uct, uwsgi.vassals_set) counter += 2;
+	uwsgi_foreach(uct, uwsgi.vassals_templates) counter += 2;
+	uwsgi_foreach(uct, uwsgi.vassals_includes) counter += 2;
+
+	char **vassal_argv = uwsgi_malloc(sizeof(char *) * counter);
+	// set args
+	vassal_argv[0] = uwsgi.emperor_wrapper ? uwsgi.emperor_wrapper : uwsgi.binary_path;
+	char *wrapper_attr = vassal_attr_get(n_ui, uwsgi.emperor_wrapper_attr);
+	if (wrapper_attr) vassal_argv[0] = wrapper_attr;
+
+	// reset counter
+	counter = 1;
+
+	uwsgi_foreach(uct, uwsgi.vassals_templates_before) {
+		vassal_argv[counter] = "--inherit";
+		vassal_argv[counter + 1] = uct->value;
+		counter += 2;
+	}
+
+	uwsgi_foreach(uct, uwsgi.vassals_includes_before) {
+		vassal_argv[counter] = "--include";
+		vassal_argv[counter + 1] = uct->value;
+		counter += 2;
+	}
+
+	uwsgi_foreach(uct, uwsgi.vassals_set) {
+		vassal_argv[counter] = "--set";
+		vassal_argv[counter + 1] = uct->value;
+		counter += 2;
+	}
+
+	char *colon = NULL;
+	if (uwsgi.emperor_broodlord) {
+		colon = strchr(n_ui->name, ':');
+		if (colon) {
+			colon[0] = 0;
+		}
+	}
+	// initialize to a default value
+	vassal_argv[counter] = "--inherit";
+
+	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 4), ".xml"))
+		vassal_argv[counter] = "--xml";
+	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 4), ".ini"))
+		vassal_argv[counter] = "--ini";
+	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 4), ".yml"))
+		vassal_argv[counter] = "--yaml";
+	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 5), ".yaml"))
+		vassal_argv[counter] = "--yaml";
+	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 3), ".js"))
+		vassal_argv[counter] = "--json";
+	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 5), ".json"))
+		vassal_argv[counter] = "--json";
+	struct uwsgi_string_list *usl = uwsgi.emperor_extra_extension;
+	while (usl) {
+		if (uwsgi_endswith(n_ui->name, usl->value)) {
+			vassal_argv[counter] = "--config";
+			break;
+		}
+		usl = usl->next;
+	}
+	if (colon)
+		colon[0] = ':';
+
+	// start config filename...
+	counter++;
+
+	vassal_argv[counter] = n_ui->name;
+	if (uwsgi.emperor_magic_exec) {
+		if (!access(n_ui->name, R_OK | X_OK)) {
+			vassal_argv[counter] = uwsgi_concat2("exec://", n_ui->name);
+			if (slot_to_free)
+				*slot_to_free = counter;
+		}
+
+	}
+	else if (n_ui->use_config) {
+		vassal_argv[counter] = uwsgi_concat2("emperor://", n_ui->name);
+		if (slot_to_free)
+			*slot_to_free = counter;
+	}
+
+	// start templates,includes,inherit...
+	counter++;
+
+	uwsgi_foreach(uct, uwsgi.vassals_templates) {
+		vassal_argv[counter] = "--inherit";
+		vassal_argv[counter + 1] = uct->value;
+		counter += 2;
+	}
+
+	uwsgi_foreach(uct, uwsgi.vassals_includes) {
+		vassal_argv[counter] = "--include";
+		vassal_argv[counter + 1] = uct->value;
+		counter += 2;
+	}
+
+	vassal_argv[counter] = NULL;
+
+	return vassal_argv;
+}
+
+
 /*
 this should be placed in core/socket.c but we realized it was needed
 only after 2.0 so we cannot change uwsgi.h
@@ -117,7 +251,7 @@ struct uwsgi_emperor_blacklist_item *uwsgi_emperor_blacklist_check(char *id) {
 
 void uwsgi_emperor_blacklist_add(char *id) {
 
-	// check if the item is already in the blacklist        
+	// check if the item is already in the blacklist
 	struct uwsgi_emperor_blacklist_item *uebi = uwsgi_emperor_blacklist_check(id);
 	if (uebi) {
 		gettimeofday(&uebi->last_attempt, NULL);
@@ -212,7 +346,7 @@ int uwsgi_emperor_is_valid(char *name) {
 	return 0;
 }
 
-static char *emperor_check_on_demand_socket(char *filename) {
+static char *emperor_check_on_demand_socket(char *filename, struct uwsgi_dyn_dict *attrs) {
 	size_t len = 0;
 	if (uwsgi.emperor_on_demand_extension) {
 		char *tmp = uwsgi_concat2(filename, uwsgi.emperor_on_demand_extension);
@@ -254,7 +388,7 @@ static char *emperor_check_on_demand_socket(char *filename) {
 	else if (uwsgi.emperor_on_demand_exec) {
 		int cpipe[2];
 		if (pipe(cpipe)) {
-			uwsgi_error("emperor_check_on_demand_socket()pipe()");
+			uwsgi_error("emperor_check_on_demand_socket()/pipe()");
 			return NULL;
 		}
 		char *cmd = uwsgi_concat4(uwsgi.emperor_on_demand_exec, " \"", filename, "\"");
@@ -345,12 +479,41 @@ void uwsgi_imperial_monitor_directory(struct uwsgi_emperor_scanner *ues) {
 			}
 			// check if mtime is changed and the uWSGI instance must be reloaded
 			if (st.st_mtime > ui_current->last_mod) {
+				if (uwsgi.emperor_force_config_pipe) {
+					char *config = uwsgi_simple_file_read(de->d_name);
+					if (!config) {
+						uwsgi_log_verbose("[emperor] unable to read %s\n", de->d_name);
+						emperor_stop(ui_current);
+                                        	continue;
+					}
+					if (ui_current->config)
+                                        	free(ui_current->config);
+                                	ui_current->config = config;
+                                	ui_current->config_len = strlen(ui_current->config);
+				}
 				emperor_respawn(ui_current, st.st_mtime);
 			}
 		}
 		else {
-			char *socket_name = emperor_check_on_demand_socket(de->d_name);
-			emperor_add(ues, de->d_name, st.st_mtime, NULL, 0, t_uid, t_gid, socket_name);
+			struct uwsgi_dyn_dict *attrs = NULL;
+			if (uwsgi.emperor_collect_attributes) {
+				if (uwsgi_endswith(de->d_name, ".ini")) {
+					uwsgi_emperor_ini_attrs(de->d_name, NULL, &attrs);
+				}
+			}
+			char *socket_name = emperor_check_on_demand_socket(de->d_name, attrs);
+			if (uwsgi.emperor_force_config_pipe) {
+				char *config = uwsgi_simple_file_read(de->d_name);
+				if (config) {
+					emperor_add_with_attrs(ues, de->d_name, st.st_mtime, config, strlen(config), t_uid, t_gid, socket_name, attrs);
+				}
+				else {
+					uwsgi_log_verbose("[emperor] unable to read %s\n", de->d_name);
+				}
+			}
+			else {
+				emperor_add_with_attrs(ues, de->d_name, st.st_mtime, NULL, 0, t_uid, t_gid, socket_name, attrs);
+			}
 			if (socket_name)
 				free(socket_name);
 		}
@@ -466,14 +629,43 @@ void uwsgi_imperial_monitor_glob(struct uwsgi_emperor_scanner *ues) {
 			}
 			// check if mtime is changed and the uWSGI instance must be reloaded
 			if (st.st_mtime > ui_current->last_mod) {
+				if (uwsgi.emperor_force_config_pipe) {
+                                        char *config = uwsgi_simple_file_read(g.gl_pathv[i]);
+                                        if (!config) {
+                                                uwsgi_log_verbose("[emperor] unable to read %s\n", g.gl_pathv[i]);
+                                                emperor_stop(ui_current);
+                                                continue;
+                                        }
+                                        if (ui_current->config)
+                                                free(ui_current->config);
+                                        ui_current->config = config;
+                                        ui_current->config_len = strlen(ui_current->config);
+                                }
 				emperor_respawn(ui_current, st.st_mtime);
 			}
 		}
 		else {
-			char *socket_name = emperor_check_on_demand_socket(g.gl_pathv[i]);
-			emperor_add(ues, g.gl_pathv[i], st.st_mtime, NULL, 0, t_uid, t_gid, socket_name);
-			if (socket_name)
-				free(socket_name);
+			struct uwsgi_dyn_dict *attrs = NULL;
+                        if (uwsgi.emperor_collect_attributes) {
+                                if (uwsgi_endswith(g.gl_pathv[i], ".ini")) {
+                                        uwsgi_emperor_ini_attrs(g.gl_pathv[i], NULL, &attrs);
+                                }
+                        }
+                        char *socket_name = emperor_check_on_demand_socket(g.gl_pathv[i], attrs);
+			if (uwsgi.emperor_force_config_pipe) {
+                                char *config = uwsgi_simple_file_read(g.gl_pathv[i]);
+                                if (config) {
+                                        emperor_add_with_attrs(ues, g.gl_pathv[i], st.st_mtime, config, strlen(config), t_uid, t_gid, socket_name, attrs);
+                                }
+                                else {
+                                        uwsgi_log_verbose("[emperor] unable to read %s\n", g.gl_pathv[i]);
+                                }
+                        }
+                        else {
+                                emperor_add_with_attrs(ues, g.gl_pathv[i], st.st_mtime, NULL, 0, t_uid, t_gid, socket_name, attrs);
+                        }	
+                        if (socket_name)
+                                free(socket_name);
 		}
 
 	}
@@ -667,16 +859,12 @@ void emperor_del(struct uwsgi_instance *c_ui) {
 	}
 
 	// this will destroy the whole uWSGI instance (and workers)
-	if (c_ui->pipe[0] != -1)
-		close(c_ui->pipe[0]);
-	if (c_ui->pipe[1] != -1)
-		close(c_ui->pipe[1]);
+	if (c_ui->pipe[0] != -1) close(c_ui->pipe[0]);
+	if (c_ui->pipe[1] != -1) close(c_ui->pipe[1]);
 
 	if (c_ui->use_config) {
-		if (c_ui->pipe_config[0] != -1)
-			close(c_ui->pipe_config[0]);
-		if (c_ui->pipe_config[1] != -1)
-			close(c_ui->pipe_config[1]);
+		if (c_ui->pipe_config[0] != -1) close(c_ui->pipe_config[0]);
+		if (c_ui->pipe_config[1] != -1) close(c_ui->pipe_config[1]);
 	}
 
 	if (uwsgi.vassals_stop_hook) {
@@ -704,15 +892,20 @@ void emperor_del(struct uwsgi_instance *c_ui) {
 		free(c_ui->socket_name);
 	}
 
-	if (c_ui->config)
-		free(c_ui->config);
-
 	if (c_ui->on_demand_fd > -1) {
 		close(c_ui->on_demand_fd);
 	}
+	if (c_ui->config) free(c_ui->config);
 
-	free(c_ui);
+	struct uwsgi_dyn_dict *attr = c_ui->attrs;
+        while(attr) {
+        	struct uwsgi_dyn_dict *tmp = attr;
+                attr = attr->next;
+		if (tmp->value) free(tmp->value);
+                free(tmp);
+        }
 
+	free(c_ui);
 }
 
 void emperor_back_to_ondemand(struct uwsgi_instance *c_ui) {
@@ -738,6 +931,12 @@ void emperor_stop(struct uwsgi_instance *c_ui) {
 		return;
 	// remove uWSGI instance
 
+	// in Zeus mode we need to send
+	// the DESTROY message to all of the nodes
+	if (uwsgi.zeus) {
+		return;
+	}
+
 	if (c_ui->pid != -1) {
 		if (write(c_ui->pipe[0], "\0", 1) != 1) {
 			uwsgi_error("emperor_stop()/write()");
@@ -770,7 +969,7 @@ static void emperor_push_config(struct uwsgi_instance *c_ui) {
 
 	if (c_ui->use_config) {
 		uh.modifier1 = 115;
-		uh.pktsize = c_ui->config_len;
+		uh._pktsize = c_ui->config_len;
 		uh.modifier2 = 0;
 		if (write(c_ui->pipe_config[0], &uh, 4) != 4) {
 			uwsgi_error("[uwsgi-emperor] write() header config");
@@ -789,6 +988,12 @@ void emperor_respawn(struct uwsgi_instance *c_ui, time_t mod) {
 	if (c_ui->status > 0)
 		return;
 
+	// if in Zeus mode, we need to send
+	// the reload message to all of the nodes
+	if (uwsgi.zeus) {
+		return;
+	}
+
 	// check if we are in on_demand mode (the respawn will be ignored)
 	if (c_ui->pid == -1 && c_ui->on_demand_fd > -1) {
 		c_ui->last_mod = mod;
@@ -797,6 +1002,9 @@ void emperor_respawn(struct uwsgi_instance *c_ui, time_t mod) {
 		// reset accepting
 		c_ui->accepting = 0;
 		uwsgi_log_verbose("[emperor] updated configuration for \"on demand\" instance %s\n", c_ui->name);
+		if (uwsgi_hooks_run_and_return(uwsgi.hook_as_on_config_vassal, "as-on-config-vassal", c_ui->name, 0)) {
+			emperor_curse(c_ui);
+		}
 		return;
 	}
 
@@ -809,7 +1017,8 @@ void emperor_respawn(struct uwsgi_instance *c_ui, time_t mod) {
 	}
 
 	// push the config to the config pipe (if needed)
-	emperor_push_config(c_ui);
+	// changed in 2.1, the vassal asks for config blob
+	//emperor_push_config(c_ui);
 
 	c_ui->respawns++;
 	c_ui->last_mod = mod;
@@ -823,6 +1032,10 @@ void emperor_respawn(struct uwsgi_instance *c_ui, time_t mod) {
 }
 
 void emperor_add(struct uwsgi_emperor_scanner *ues, char *name, time_t born, char *config, uint32_t config_size, uid_t uid, gid_t gid, char *socket_name) {
+	emperor_add_with_attrs(ues, name, born, config, config_size, uid, gid, socket_name, NULL);
+}
+
+void emperor_add_with_attrs(struct uwsgi_emperor_scanner *ues, char *name, time_t born, char *config, uint32_t config_size, uid_t uid, gid_t gid, char *socket_name, struct uwsgi_dyn_dict *attrs) {
 
 	struct uwsgi_instance *c_ui = ui;
 	struct uwsgi_instance *n_ui = NULL;
@@ -868,16 +1081,7 @@ void emperor_add(struct uwsgi_emperor_scanner *ues, char *name, time_t born, cha
 #ifdef UWSGI_DEBUG
 	uwsgi_log("emperor throttle = %d\n", emperor_throttle_level);
 #endif
-	if (emperor_warming_up) {
-		if (emperor_throttle_level > 0) {
-			// wait 10 milliseconds in case of fork-bombing
-			// pretty random value, but should avoid the load average to increase
-			usleep(10);
-		}
-	}
-	else {
-		usleep(emperor_throttle_level);
-	}
+	usleep(emperor_throttle_level);
 
 	if (uwsgi.emperor_tyrant) {
 		if (uid == 0 || gid == 0) {
@@ -922,6 +1126,8 @@ void emperor_add(struct uwsgi_emperor_scanner *ues, char *name, time_t born, cha
 	n_ui->last_loyal = 0;
 	n_ui->loyal = 0;
 
+	n_ui->attrs = attrs;
+
 	n_ui->first_run = uwsgi_now();
 	n_ui->last_run = n_ui->first_run;
 	n_ui->on_demand_fd = -1;
@@ -947,6 +1153,9 @@ void emperor_add(struct uwsgi_emperor_scanner *ues, char *name, time_t born, cha
 
 		event_queue_add_fd_read(uwsgi.emperor_queue, n_ui->on_demand_fd);
 		uwsgi_log("[uwsgi-emperor] %s -> \"on demand\" instance detected, waiting for connections on socket \"%s\" ...\n", name, socket_name);
+		if (uwsgi_hooks_run_and_return(uwsgi.hook_as_on_demand_vassal, "as-on-demand-vassal", name, 0)) {
+			emperor_del(n_ui);
+		}
 		return;
 	}
 
@@ -958,6 +1167,117 @@ void emperor_add(struct uwsgi_emperor_scanner *ues, char *name, time_t born, cha
 
 static void uwsgi_emperor_spawn_vassal(struct uwsgi_instance *);
 
+static void vassal_fork_server_parser_hook(char *key, uint16_t key_len, char *value, uint16_t value_len, void *data) {
+	pid_t *pid = (pid_t *) data;
+
+        if (!uwsgi_strncmp(key, key_len, "pid", 3)) {
+		// ignore negative values
+		if (value_len > 0 && value[0] == '-') return;
+                *pid = uwsgi_str_num(value, value_len);
+        }
+}
+
+
+/*
+	there are max 3 file descriptors we need to pass to the fork server:
+
+	n_ui->pipe[1]
+	n_ui->pipe_config[1]
+	n_ui->on_demand_fd
+
+*/
+static pid_t emperor_connect_to_fork_server(char *socket, struct uwsgi_instance *n_ui) {
+	int fd = uwsgi_connect(socket, uwsgi.socket_timeout, 0);
+	if (fd < 0) {
+		uwsgi_error("emperor_connect_to_fork_server()/uwsgi_connect()");
+		return -1;
+	}
+
+	int slot_to_free = -1;
+	char **vassal_argv = vassal_new_argv(n_ui, &slot_to_free);
+
+	struct uwsgi_buffer *ub = uwsgi_buffer_new(uwsgi.page_size);
+	// leave space for uwsgi header
+	ub->pos = 4;
+	int error = 0, counter = 0;
+	while (vassal_argv[counter]) {
+		if (!error && uwsgi_buffer_u16le(ub, strlen(vassal_argv[counter])))
+			error = 1;
+		if (!error && uwsgi_buffer_append(ub, vassal_argv[counter], strlen(vassal_argv[counter])))
+			error = 1;
+		if (counter == slot_to_free)
+			free(vassal_argv[counter]);
+		counter++;
+	}
+
+	free(vassal_argv);
+	if (error) {
+		uwsgi_log_verbose("[uwsgi-emperor] %s: unable to complete fork-server session\n", n_ui->name);
+		goto end;
+	}
+
+	// bit 0 -> pipe (0x01)
+	// bit 1 -> config_pipe (0x02)
+	// bit 2 -> on_demand (0x04)
+	uint8_t modifier2_mask = 0x01;
+	int fds[8];
+	int fds_count = 1;
+	fds[0] = n_ui->pipe[1];
+
+	// add pipe config ?
+	if (n_ui->use_config) {
+		modifier2_mask |= 0x02;
+		fds[fds_count] = n_ui->pipe_config[1];
+		fds_count++;
+	}
+
+	// add ondemand ?
+	if (n_ui->on_demand_fd > -1) {
+		modifier2_mask |= 0x04;
+		fds[fds_count] = n_ui->on_demand_fd;
+		fds_count++;
+	}
+
+	// fix uwsgi header
+	if (uwsgi_buffer_set_uh(ub, 35, modifier2_mask)) goto end;
+
+	if (uwsgi_send_fds_and_body(fd, fds, fds_count, ub->buf, ub->pos)) {
+		uwsgi_log_verbose("[uwsgi-emperor] %s: unable to complete fork-server session\n", n_ui->name);
+		goto end;
+	}
+
+	uwsgi_buffer_destroy(ub);
+
+	// now wait for the response (the pid number)
+	// the response could contain various info, currently we only need the "pid" attribute
+	size_t buf_len = uwsgi.page_size;
+	char *buf = uwsgi_malloc(buf_len);
+	uint8_t modifier1 = 0;
+	uint8_t modifier2 = 0;
+	int ret = uwsgi_read_with_realloc(fd, &buf, &buf_len, uwsgi.socket_timeout, &modifier1, &modifier2);
+	if (ret) {
+		free(buf);
+		uwsgi_log_verbose("[uwsgi-emperor] %s: unable to complete fork-server session\n", n_ui->name);
+		goto end2;
+	}
+
+	pid_t pid = -1;
+	uwsgi_hooked_parse(buf, buf_len, vassal_fork_server_parser_hook, &pid);
+	free(buf);
+
+	// close the connection
+	close(fd);
+
+	// return the pid to the Emperor
+	return pid;
+
+end:
+	uwsgi_buffer_destroy(ub);
+end2:
+	close(fd);
+	return -1;
+}
+
 int uwsgi_emperor_vassal_start(struct uwsgi_instance *n_ui) {
 
 	pid_t pid;
@@ -982,20 +1302,36 @@ int uwsgi_emperor_vassal_start(struct uwsgi_instance *n_ui) {
 		uwsgi.emperor_broodlord_num++;
 	}
 
-	// TODO pre-start hook
 
-	// a new uWSGI instance will start 
+	if (uwsgi_hooks_run_and_return(uwsgi.hook_as_emperor_before_vassal, "as-emperor-before-vassal", NULL, 0)) {
+        	emperor_del(n_ui);
+        }
+
+	if (uwsgi.zeus) {
+		uwsgi_log("[zeus] ready to spawn instance \"%s\" ...\n", n_ui->name);
+		return uwsgi_zeus_spawn_instance(n_ui);
+	}
+
+	// check for fork server
+	char *fork_server = uwsgi.emperor_use_fork_server;
+	char *fork_server_attr = vassal_attr_get(n_ui, uwsgi.emperor_fork_server_attr);
+	if (fork_server_attr) fork_server = fork_server_attr;
+	// a new uWSGI instance will start
+	if (fork_server && !uwsgi_string_list_has_item(uwsgi.vassal_fork_base, n_ui->name, strlen(n_ui->name))) {
+		// pid can only be > 0 or -1
+		n_ui->adopted = 1;
+		pid = emperor_connect_to_fork_server(fork_server, n_ui);
+	}
 #if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL) && !defined(__ia64__)
-	if (uwsgi.emperor_clone) {
+	else if (uwsgi.emperor_clone) {
 		char stack[PTHREAD_STACK_MIN];
 		pid = clone((int (*)(void *)) uwsgi_emperor_spawn_vassal, stack + PTHREAD_STACK_MIN, SIGCHLD | uwsgi.emperor_clone, (void *) n_ui);
 	}
-	else {
 #endif
+	else {
 		pid = fork();
-#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL) && !defined(__ia64__)
 	}
-#endif
+
 	if (pid < 0) {
 		uwsgi_error("uwsgi_emperor_spawn_vassal()/fork()")
 	}
@@ -1094,6 +1430,10 @@ int uwsgi_emperor_vassal_start(struct uwsgi_instance *n_ui) {
 				func(n_ui->name, n_ui->pid, n_ui->uid, n_ui->gid);
 			}
 		}
+
+#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL)
+		uwsgi_hooks_setns_run(uwsgi.hook_as_emperor_setns, n_ui->pid, n_ui->uid, n_ui->gid);
+#endif
 		return 0;
 	}
 	else {
@@ -1131,6 +1471,8 @@ static void uwsgi_emperor_spawn_vassal(struct uwsgi_instance *n_ui) {
 	}
 #endif
 
+	uwsgi_hooks_run(uwsgi.hook_as_vassal_before_drop, "as-vassal-before-drop", 1);
+
 #ifdef UWSGI_CAP
 #if defined(CAP_LAST_CAP) && defined(PR_CAPBSET_READ) && defined(PR_CAPBSET_DROP)
 	if (uwsgi.emperor_cap && uwsgi.emperor_cap_count > 0) {
@@ -1260,103 +1602,8 @@ static void uwsgi_emperor_spawn_vassal(struct uwsgi_instance *n_ui) {
 		close(n_ui->pipe_config[0]);
 	}
 
-	int counter = 4;
-	struct uwsgi_string_list *uct;
-	uwsgi_foreach(uct, uwsgi.vassals_templates_before) counter += 2;
-	uwsgi_foreach(uct, uwsgi.vassals_includes_before) counter += 2;
-	uwsgi_foreach(uct, uwsgi.vassals_set) counter += 2;
-	uwsgi_foreach(uct, uwsgi.vassals_templates) counter += 2;
-	uwsgi_foreach(uct, uwsgi.vassals_includes) counter += 2;
-
-	char **vassal_argv = uwsgi_malloc(sizeof(char *) * counter);
-	// set args
-	vassal_argv[0] = uwsgi.emperor_wrapper ? uwsgi.emperor_wrapper : uwsgi.binary_path;
+	char **vassal_argv = vassal_new_argv(n_ui, NULL);
 
-	// reset counter
-	counter = 1;
-
-	uwsgi_foreach(uct, uwsgi.vassals_templates_before) {
-		vassal_argv[counter] = "--inherit";
-		vassal_argv[counter + 1] = uct->value;
-		counter += 2;
-	}
-
-	uwsgi_foreach(uct, uwsgi.vassals_includes_before) {
-		vassal_argv[counter] = "--include";
-		vassal_argv[counter + 1] = uct->value;
-		counter += 2;
-	}
-
-	uwsgi_foreach(uct, uwsgi.vassals_set) {
-		vassal_argv[counter] = "--set";
-		vassal_argv[counter + 1] = uct->value;
-		counter += 2;
-	}
-
-	char *colon = NULL;
-	if (uwsgi.emperor_broodlord) {
-		colon = strchr(n_ui->name, ':');
-		if (colon) {
-			colon[0] = 0;
-		}
-	}
-	// initialize to a default value
-	vassal_argv[counter] = "--inherit";
-
-	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 4), ".xml"))
-		vassal_argv[counter] = "--xml";
-	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 4), ".ini"))
-		vassal_argv[counter] = "--ini";
-	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 4), ".yml"))
-		vassal_argv[counter] = "--yaml";
-	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 5), ".yaml"))
-		vassal_argv[counter] = "--yaml";
-	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 3), ".js"))
-		vassal_argv[counter] = "--json";
-	if (!strcmp(n_ui->name + (strlen(n_ui->name) - 5), ".json"))
-		vassal_argv[counter] = "--json";
-	struct uwsgi_string_list *usl = uwsgi.emperor_extra_extension;
-	while (usl) {
-		if (uwsgi_endswith(n_ui->name, usl->value)) {
-			vassal_argv[counter] = "--config";
-			break;
-		}
-		usl = usl->next;
-	}
-	if (colon)
-		colon[0] = ':';
-
-	// start config filename...
-	counter++;
-
-	vassal_argv[counter] = n_ui->name;
-	if (uwsgi.emperor_magic_exec) {
-		if (!access(n_ui->name, R_OK | X_OK)) {
-			vassal_argv[counter] = uwsgi_concat2("exec://", n_ui->name);
-		}
-
-	}
-
-	if (n_ui->use_config) {
-		vassal_argv[counter] = uwsgi_concat2("emperor://", n_ui->name);
-	}
-
-	// start templates,includes,inherit...
-	counter++;
-
-	uwsgi_foreach(uct, uwsgi.vassals_templates) {
-		vassal_argv[counter] = "--inherit";
-		vassal_argv[counter + 1] = uct->value;
-		counter += 2;
-	}
-
-	uwsgi_foreach(uct, uwsgi.vassals_includes) {
-		vassal_argv[counter] = "--include";
-		vassal_argv[counter + 1] = uct->value;
-		counter += 2;
-	}
-
-	vassal_argv[counter] = NULL;
 
 	// disable stdin OR map it to the "on demand" socket
 	if (n_ui->on_demand_fd > -1) {
@@ -1399,6 +1646,7 @@ static void uwsgi_emperor_spawn_vassal(struct uwsgi_instance *n_ui) {
 
 	uwsgi_hooks_run(uwsgi.hook_as_vassal, "as-vassal", 1);
 
+	struct uwsgi_string_list *usl = NULL;
 	uwsgi_foreach(usl, uwsgi.mount_as_vassal) {
 		uwsgi_log("mounting \"%s\" (as-vassal)...\n", usl->value);
 		if (uwsgi_mount_hook(usl->value)) {
@@ -1451,16 +1699,24 @@ static void uwsgi_emperor_spawn_vassal(struct uwsgi_instance *n_ui) {
 		func(n_ui->name, n_ui->uid, n_ui->gid);
 	}
 
+	char *force_chdir = vassal_attr_get(n_ui, uwsgi.emperor_chdir_attr);
+	if (force_chdir) {
+		if (chdir(force_chdir)) {
+			uwsgi_error("--emperor-chdir-attr/chdir()");
+			exit(UWSGI_EXILE_CODE);
+		}
+	}
+
 	// ->vassal_before_exec
 	for (i = 0; i < 256; i++) {
                 if (uwsgi.p[i]->vassal_before_exec) {
-                        uwsgi.p[i]->vassal_before_exec(n_ui);
+                        uwsgi.p[i]->vassal_before_exec(n_ui, vassal_argv);
                 }
         }
 
         for (i = 0; i < uwsgi.gp_cnt; i++) {
-                if (uwsgi.gp[i]->vassal) {
-                        uwsgi.gp[i]->vassal_before_exec(n_ui);
+                if (uwsgi.gp[i]->vassal_before_exec) {
+                        uwsgi.gp[i]->vassal_before_exec(n_ui, vassal_argv);
                 }
         }
 
@@ -1564,7 +1820,6 @@ void uwsgi_emperor_run_scanners(void) {
 		ues->monitor->func(ues);
 		ues = ues->next;
 	}
-	emperor_warming_up = 0;
 }
 
 void emperor_build_scanners() {
@@ -1625,6 +1880,20 @@ static void emperor_cleanup() {
 
 void emperor_loop() {
 
+#if defined(__linux__) && defined(PR_SET_CHILD_SUBREAPER)
+        if (uwsgi.emperor_use_fork_server || uwsgi.emperor_subreaper || uwsgi.emperor_fork_server_attr) {
+                if (prctl(PR_SET_CHILD_SUBREAPER, 1, 0, 0, 0)) {
+                        uwsgi_error("uwsgi_fork_server()/fork()");
+                        exit(1);
+                }
+        }
+#else
+	if (uwsgi.emperor_use_fork_server || uwsgi.emperor_subreaper || uwsgi.emperor_fork_server_attr) {
+		uwsgi_log("*** DANGER: your kernel misses PR_SET_CHILD_SUBREAPER feature, required by the fork server ***\n");
+		uwsgi_log("*** your Emperor will not be able to correctly wait() on vassals ***\n");
+	}
+#endif
+
 	// monitor a directory
 
 	struct uwsgi_instance ui_base;
@@ -1800,7 +2069,7 @@ void emperor_loop() {
 						ui_current->last_heartbeat = uwsgi_now();
 					}
 					else if (byte == 22) {
-						// command 22 changes meaning when in "on_demand" mode  
+						// command 22 changes meaning when in "on_demand" mode
 						if (ui_current->on_demand_fd != -1) {
 							emperor_back_to_ondemand(ui_current);
 						}
@@ -1913,6 +2182,7 @@ recheck:
 				uwsgi_error("waitpid()");
 			}
 		}
+
 		ui_current = ui;
 		while (ui_current->ui_next) {
 			ui_current = ui_current->ui_next;
@@ -1935,17 +2205,17 @@ recheck:
 							socket_name = uwsgi_str(ui_current->socket_name);
 						}
 						emperor_add(ui_current->scanner, ui_current->name, ui_current->last_mod, config, ui_current->config_len, ui_current->uid, ui_current->gid, socket_name);
-						// temporarily set frequency to 0, so we can eventually fast-restart the instance
 						emperor_del(ui_current);
-						freq = 0;
+						// temporarily set frequency to 1, so we can eventually fast-restart the instance
+						freq = 1;
 					}
 					break;
 				}
 				else if (ui_current->status == 1) {
 					// remove 'marked for dead' instance
 					emperor_del(ui_current);
-					// temporarily set frequency to 0, so we can eventually fast-restart the instance
-					freq = 0;
+					// temporarily set frequency to 1, so we can eventually fast-restart the instance
+					freq = 1;
 					break;
 				}
 				// back to on_demand mode ...
@@ -1963,14 +2233,18 @@ recheck:
 					ui_current->ready = 0;
 					ui_current->accepting = 0;
 					uwsgi_log("[uwsgi-emperor] %s -> back to \"on demand\" mode, waiting for connections on socket \"%s\" ...\n", ui_current->name, ui_current->socket_name);
+					if (uwsgi_hooks_run_and_return(uwsgi.hook_as_on_demand_vassal, "as-on-demand-vassal", ui_current->name, 0)) {
+						emperor_del(ui_current);
+						freq = 1;
+					}
 					break;
 				}
 			}
 			else if (ui_current->cursed_at > 0) {
 				if (ui_current->pid == -1) {
 					emperor_del(ui_current);
-					// temporarily set frequency to 0, so we can eventually fast-restart the instance
-					freq = 0;
+					// temporarily set frequency to 1, so we can eventually fast-restart the instance
+					freq = 1;
 					break;
 				}
 				else if (now - ui_current->cursed_at >= uwsgi.emperor_curse_tolerance) {
@@ -2104,6 +2378,9 @@ void emperor_send_stats(int fd) {
 		if (uwsgi_stats_keyval_comma(us, "on_demand", c_ui->socket_name ? c_ui->socket_name : ""))
 			goto end0;
 
+		if (uwsgi_stats_keylong_comma(us, "adopted", (unsigned long long) c_ui->adopted))
+			goto end0;
+
 		if (uwsgi_stats_keylong_comma(us, "uid", (unsigned long long) c_ui->uid))
 			goto end0;
 		if (uwsgi_stats_keylong_comma(us, "gid", (unsigned long long) c_ui->gid))
@@ -2112,6 +2389,31 @@ void emperor_send_stats(int fd) {
 		if (uwsgi_stats_keyval_comma(us, "monitor", c_ui->scanner->arg))
 			goto end0;
 
+		if (uwsgi_stats_key(us, "attrs"))
+                        goto end0;
+
+		if (uwsgi_stats_list_open(us))
+			goto end0;
+
+		struct uwsgi_dyn_dict *attrs = c_ui->attrs;
+		while(attrs) {
+			if (attrs->next) {
+				if (uwsgi_stats_keyval_comma(us, attrs->key, attrs->value))
+                        		goto end0;
+			}
+			else {
+				if (uwsgi_stats_keyval(us, attrs->key, attrs->value))
+                        		goto end0;
+			}
+			attrs = attrs->next;
+		}
+
+		if (uwsgi_stats_list_close(us))
+			goto end0;
+
+		if (uwsgi_stats_comma(us))
+                                goto end0;
+
 		if (uwsgi_stats_keylong(us, "respawns", (unsigned long long) c_ui->respawns))
 			goto end0;
 
@@ -2250,7 +2552,7 @@ void uwsgi_check_emperor() {
 				sleep(1);
 				continue;
 			}
-			int count = 2;
+			int count = 3;
 			int *fds = uwsgi_attach_fd(proxy_fd, &count, "uwsgi-emperor", 13);
 			if (fds && count > 0) {
 				char *env_emperor_fd = uwsgi_num2str(fds[0]);
@@ -2263,17 +2565,42 @@ void uwsgi_check_emperor() {
 					goto next;
 				}
 				free(env_emperor_fd);
-				if (count > 1) {
-					char *env_emperor_fd_config = uwsgi_num2str(fds[1]);
-					if (setenv("UWSGI_EMPEROR_FD_CONFIG", env_emperor_fd_config, 1)) {
-						uwsgi_error("uwsgi_check_emperor()/setenv(UWSGI_EMPEROR_FD_CONFIG)");
-						free(env_emperor_fd_config);
-						int i;
-						for (i = 0; i < count; i++)
+				int i;
+				for(i=1;i<count;i++) {
+					if (fds[i] < 0) continue;
+
+					char *socket_name = uwsgi_getsockname(fds[i]);
+					if (!socket_name) {
+						int j;
+                                                for (j = 0; j < count; j++)
+                                                        close(fds[j]);
+                                                goto next;
+					}
+					if (socket_name[0] != 0) {
+						// map the socket to fd0
+						if (fds[i] != 0) {
+							if (dup2(fds[i], 0) < 0) {
+								uwsgi_error("uwsgi_check_emperor()/dup2()");
+								int j;
+                                                		for (j = 0; j < count; j++)
+                                                        		close(fds[j]);
+                                                		goto next;
+							}
 							close(fds[i]);
-						goto next;
+						}
+					}
+					else {
+						char *env_emperor_fd_config = uwsgi_num2str(fds[i]);
+						if (setenv("UWSGI_EMPEROR_FD_CONFIG", env_emperor_fd_config, 1)) {
+							uwsgi_error("uwsgi_check_emperor()/setenv(UWSGI_EMPEROR_FD_CONFIG)");
+							free(env_emperor_fd_config);
+							int j;
+							for (j = 0; j < count; j++)
+								close(fds[j]);
+							goto next;
+						}
+						free(env_emperor_fd_config);
 					}
-					free(env_emperor_fd_config);
 				}
 				break;
 			}
@@ -2300,6 +2627,34 @@ next:
 
 }
 
+void uwsgi_emperor_simple_do_with_attrs(struct uwsgi_emperor_scanner *ues, char *name, char *config, time_t ts, uid_t uid, gid_t gid, char *socket_name, struct uwsgi_dyn_dict *attrs) {
+	uwsgi_emperor_simple_do(ues, name, config, ts, uid, gid, socket_name);
+	struct uwsgi_instance *ui_current = emperor_get(name);
+	// free attrs ?
+	if (!ui_current) {
+		struct uwsgi_dyn_dict *attr = attrs;
+		while(attr) {
+			struct uwsgi_dyn_dict *tmp = attr;
+			attr = attr->next;
+			if (tmp->value) free(tmp->value);
+			free(tmp);
+		}
+		return;
+	}
+
+	// if the instance has attrs mapped, let's free them
+	if (ui_current->attrs) {
+		struct uwsgi_dyn_dict *attr = ui_current->attrs;
+		while(attr) {
+			struct uwsgi_dyn_dict *tmp = attr;
+			attr = attr->next;
+			if (tmp->value) free(tmp->value);
+			free(tmp);
+		}
+	}
+	ui_current->attrs = attrs;
+}
+
 void uwsgi_emperor_simple_do(struct uwsgi_emperor_scanner *ues, char *name, char *config, time_t ts, uid_t uid, gid_t gid, char *socket_name) {
 
 	if (!uwsgi_emperor_is_valid(name))
@@ -2410,19 +2765,21 @@ void uwsgi_master_manage_emperor() {
 
 }
 
-void uwsgi_master_manage_emperor_proxy() {
+void uwsgi_master_manage_emperor_proxy(int server_fd, int emperor_fd, int emperor_fd_config, int socket_fd) {
 
 	struct sockaddr_un epsun;
 	socklen_t epsun_len = sizeof(struct sockaddr_un);
 
-	int ep_client = accept(uwsgi.emperor_fd_proxy, (struct sockaddr *) &epsun, &epsun_len);
+	int ep_client = accept(server_fd, (struct sockaddr *) &epsun, &epsun_len);
 	if (ep_client < 0) {
 		uwsgi_error("uwsgi_master_manage_emperor_proxy()/accept()");
 		return;
 	}
 
 	int num_fds = 1;
-	if (uwsgi.emperor_fd_config > -1)
+	if (emperor_fd_config > -1)
+		num_fds++;
+	if (socket_fd > -1)
 		num_fds++;
 
 	struct msghdr ep_msg;
@@ -2452,9 +2809,15 @@ void uwsgi_master_manage_emperor_proxy() {
 
 	unsigned char *ep_fd_ptr = CMSG_DATA(cmsg);
 
-	memcpy(ep_fd_ptr, &uwsgi.emperor_fd, sizeof(int));
-	if (num_fds > 1) {
-		memcpy(ep_fd_ptr + sizeof(int), &uwsgi.emperor_fd_config, sizeof(int));
+	memcpy(ep_fd_ptr, &emperor_fd, sizeof(int));
+	if (emperor_fd_config > -1) {
+		ep_fd_ptr += sizeof(int);
+		memcpy(ep_fd_ptr, &emperor_fd_config, sizeof(int));
+	}
+
+	if (socket_fd > -1) {
+		ep_fd_ptr += sizeof(int);
+		memcpy(ep_fd_ptr, &socket_fd, sizeof(int));
 	}
 
 	if (sendmsg(ep_client, &ep_msg, 0) < 0) {
diff --git a/core/exceptions.c b/core/exceptions.c
index 63c1371..fc6fe1c 100644
--- a/core/exceptions.c
+++ b/core/exceptions.c
@@ -46,7 +46,7 @@ extern struct uwsgi_server uwsgi;
 
 struct uwsgi_buffer *uwsgi_exception_handler_object(struct wsgi_request *wsgi_req) {
 	struct uwsgi_buffer *ub = uwsgi_buffer_new(4096);
-	if (uwsgi_buffer_append_keyval(ub, "vars", 4, wsgi_req->buffer,wsgi_req->uh->pktsize)) goto error;
+	if (uwsgi_buffer_append_keyval(ub, "vars", 4, wsgi_req->buffer, wsgi_req->len)) goto error;
 	if (uwsgi.p[wsgi_req->uh->modifier1]->backtrace) {
                 struct uwsgi_buffer *bt = uwsgi.p[wsgi_req->uh->modifier1]->backtrace(wsgi_req);
 		if (bt) {
@@ -280,7 +280,7 @@ notavail4:
 
         if (uwsgi_buffer_append(ub, "\n\n", 2)) goto error;
 
-	if (uwsgi_hooked_parse(wsgi_req->buffer, wsgi_req->uh->pktsize, append_vars_to_ubuf, ub)) {
+	if (uwsgi_hooked_parse(wsgi_req->buffer, wsgi_req->len, append_vars_to_ubuf, ub)) {
 		goto error;
 	}
 
diff --git a/core/fork_server.c b/core/fork_server.c
new file mode 100644
index 0000000..5a0baaa
--- /dev/null
+++ b/core/fork_server.c
@@ -0,0 +1,226 @@
+#include <uwsgi.h>
+
+extern struct uwsgi_server uwsgi;
+
+/*
+
+on connection retrieve the uid,gid and pid of the connecting process, in addition to up to 3
+file descriptors (emperor pipe, emperor pipe_config, on_demand socket dup()'ed to 0)
+
+if authorized, double fork, get the pid of the second child and exit()
+its parent (this will force the Emperor to became its subreaper).
+
+from now on, we can consider the new child as a full-featured vassal
+
+*/
+
+#define VASSAL_HAS_CONFIG 0x02
+#define VASSAL_HAS_ON_DEMAND 0x04
+
+static void parse_argv_hook(uint16_t item, char *value, uint16_t vlen, void *data) {
+	struct uwsgi_string_list **usl = (struct uwsgi_string_list **) data;
+	uwsgi_string_new_list(usl, uwsgi_concat2n(value, vlen, "", 0));
+}
+
+
+void uwsgi_fork_server(char *socket) {
+	// map fd 0 to /dev/null to avoid mess
+	uwsgi_remap_fd(0, "/dev/null");
+
+	int fd = bind_to_unix(socket, uwsgi.listen_queue, uwsgi.chmod_socket, uwsgi.abstract_socket);
+	if (fd < 0) exit(1);
+
+	// automatically receive credentials (TODO make something useful with them, like checking the pid is from the Emperor)
+	if (uwsgi_socket_passcred(fd)) exit(1);
+
+	// initialize the event queue
+	int eq = event_queue_init();
+	if (uwsgi.has_emperor) {
+		event_queue_add_fd_read(eq, uwsgi.emperor_fd);
+	}
+	event_queue_add_fd_read(eq, fd);
+
+	// now start waiting for connections
+	for(;;) {
+		int interesting_fd = -1;
+		int rlen = event_queue_wait(eq, -1, &interesting_fd);
+		if (rlen <= 0) continue;
+		if (uwsgi.has_emperor && interesting_fd == uwsgi.emperor_fd) {
+			char byte;
+        		ssize_t rlen = read(uwsgi.emperor_fd, &byte, 1);
+        		if (rlen > 0) {
+                		uwsgi_log_verbose("received message %d from emperor\n", byte);
+			}
+			exit(0);
+		}
+		if (interesting_fd != fd) continue;
+		struct sockaddr_un client_src;
+        	socklen_t client_src_len = 0;
+        	int client_fd = accept(fd, (struct sockaddr *) &client_src, &client_src_len);
+        	if (client_fd < 0) {
+                	uwsgi_error("uwsgi_fork_server()/accept()");
+			continue;
+        	}
+		char hbuf[4];
+		pid_t ppid = -1;
+		uid_t uid = -1;
+		gid_t gid = -1;
+		int fds_count = 8;
+		size_t remains = 4;
+		// we can receive upto 8 fds (generally from 1 to 3)
+		int fds[8];
+		// we only read 4 bytes header
+		ssize_t len = uwsgi_recv_cred_and_fds(client_fd, hbuf, remains, &ppid, &uid, &gid, fds, &fds_count);
+		uwsgi_log_verbose("[uwsgi-fork-server] connection from pid: %d uid: %d gid:%d fds:%d\n", ppid, uid, gid, fds_count);
+		if (len <= 0 || fds_count < 1) {
+			uwsgi_error("uwsgi_fork_server()/recvmsg()");
+			goto end;
+		}
+		remains -= len;
+	
+		if (uwsgi_read_nb(client_fd, hbuf + (4-remains), remains, uwsgi.socket_timeout)) {
+			uwsgi_error("uwsgi_fork_server()/uwsgi_read_nb()");
+			goto end;
+		}
+
+		struct uwsgi_header *uh = (struct uwsgi_header *) hbuf;
+		// this memory area must be freed in the right place !!!
+		char *body_argv = uwsgi_malloc(uh->_pktsize);
+		if (uwsgi_read_nb(client_fd, body_argv, uh->_pktsize, uwsgi.socket_timeout)) {
+			free(body_argv);
+                        uwsgi_error("uwsgi_fork_server()/uwsgi_read_nb()");
+                        goto end;
+                }
+
+		pid_t pid = fork();
+		if (pid < 0) {
+			free(body_argv);
+			int i;
+			for(i=0;i<fds_count;i++) close(fds[i]);
+			// error on fork()
+			uwsgi_error("uwsgi_fork_server()/fork()");
+			goto end;		
+		}
+		else if (pid > 0) {
+			free(body_argv);
+			// close inherited decriptors 
+			int i;
+			for(i=0;i<fds_count;i++) close(fds[i]);
+			// wait for child death...
+			waitpid(pid, NULL, 0);
+			goto end;
+		}
+		else {
+			// close Emperor channels
+			// we do not close others file desctiptor as lot
+			// of funny tricks could be accomplished with them
+			if (uwsgi.has_emperor) {
+				close(uwsgi.emperor_fd);
+				if (uwsgi.emperor_fd_config > -1) close(uwsgi.emperor_fd_config);
+			}
+			
+			// set EMPEROR_FD and FD_CONFIG env vars	
+			char *uef = uwsgi_num2str(fds[0]);
+        		if (setenv("UWSGI_EMPEROR_FD", uef, 1)) {
+                		uwsgi_error("uwsgi_fork_server()/setenv()");
+                		exit(1);
+        		}
+        		free(uef);
+
+			int pipe_config = -1;
+			int on_demand = -1;
+
+			if (uh->modifier2 & VASSAL_HAS_CONFIG && fds_count > 1) {
+				pipe_config = fds[1];	
+				char *uef = uwsgi_num2str(pipe_config);
+				if (setenv("UWSGI_EMPEROR_FD_CONFIG", uef, 1)) {
+                                	uwsgi_error("uwsgi_fork_server()/setenv()");
+                                	exit(1);
+                        	}
+                        	free(uef);
+			}
+
+			if (uh->modifier2 & VASSAL_HAS_ON_DEMAND && fds_count > 1) {
+				if (pipe_config > -1) {
+					if (fds_count > 2) {
+						on_demand = fds[2];
+					}
+				}
+				else {
+					on_demand = fds[1];
+				}
+			}
+			// dup the on_demand socket to 0 and close it
+			if (on_demand > -1) {
+				if (dup2(on_demand, 0) < 0) {
+					uwsgi_error("uwsgi_fork_server()/dup2()");
+					exit(1);
+				}
+				close(on_demand);
+			}
+
+			// now fork again and die
+			pid_t new_pid = fork();
+			if (new_pid < 0) {
+                        	uwsgi_error("uwsgi_fork_server()/fork()");
+				exit(1);
+			}
+			else if (new_pid > 0) {
+				exit(0);
+			}
+			else {
+				// send the pid to the client_fd and close it
+				struct uwsgi_buffer *ub = uwsgi_buffer_new(uwsgi.page_size);
+				// leave space for header
+				ub->pos = 4;
+				if (uwsgi_buffer_append_keynum(ub, "pid", 3, getpid())) exit(1); 
+				// fix uwsgi header
+        			if (uwsgi_buffer_set_uh(ub, 35, 0)) goto end;
+				// send_pid()
+				if (uwsgi_write_nb(client_fd, ub->buf, ub->pos, uwsgi.socket_timeout)) exit(1);
+				close(client_fd);
+				uwsgi_log("double fork() and reparenting successfull (new pid: %d)\n", getpid());
+
+
+				// now parse the uwsgi packet array and build the argv
+				struct uwsgi_string_list *usl = NULL, *usl_argv = NULL;
+				uwsgi_hooked_parse_array(body_argv, uh->_pktsize, parse_argv_hook, &usl_argv);
+				free(body_argv);
+
+				// build new argc/argv
+				uwsgi.new_argc = 0;
+				size_t procname_len = 1;
+				uwsgi_foreach(usl, usl_argv) {
+					uwsgi.new_argc++;
+					procname_len += usl->len + 1;
+				}
+
+				char *new_procname = uwsgi_calloc(procname_len);
+				
+				uwsgi.new_argv = uwsgi_calloc(sizeof(char *) * (uwsgi.new_argc + 1));
+				int counter = 0;
+				uwsgi_foreach(usl, usl_argv) {
+					uwsgi.new_argv[counter] = usl->value;
+					strcat(new_procname, usl->value);
+					strcat(new_procname, " ");
+					counter++;
+				}
+				// fix process name
+				uwsgi_set_processname(new_procname);
+				free(new_procname);
+				// this is the only step required to have a consistent environment
+				uwsgi.fork_socket = NULL;
+				// this avoids the process to re-exec itself
+				uwsgi.exit_on_reload = 1;
+				// fixup the Emperor communication
+				uwsgi_check_emperor();
+				// continue with uWSGI startup
+				return;
+			}
+		}	
+
+end:
+		close(client_fd);
+		
+	}
+}
diff --git a/core/hooks.c b/core/hooks.c
index 8ada89b..0ad8d89 100644
--- a/core/hooks.c
+++ b/core/hooks.c
@@ -233,26 +233,17 @@ static int uwsgi_hook_writen(char *arg) {
 
 static int uwsgi_hook_appendn(char *arg) {
         char *space = strchr(arg, ' ');
-	if (space)
-        	*space = 0;
+        if (!space) {
+                uwsgi_log("invalid hook appendn syntax, must be: <file> <string>\n");
+                return -1;
+        }
+        *space = 0;
         int fd = open(arg, O_WRONLY|O_CREAT|O_APPEND, 0666);
         if (fd < 0) {
                 uwsgi_error_open(arg);
-		if (space)
-                	*space = ' ';
+                *space = ' ';
                 return -1;
         }
-	if (!space) {
-		// simple newline
-		if (write(fd, "\n", 1) != 1) {
-                	uwsgi_error("uwsgi_hook_appendn()/write()");
-			close(fd);
-			return -1;
-		}
-		close(fd);
-		return 0;
-	}
-
         *space = ' ';
         size_t l = strlen(space+1);
         char *buf = uwsgi_malloc(l + 1);
@@ -549,6 +540,18 @@ static int uwsgi_hook_retryrpc(char *arg) {
 	return 0;
 }
 
+static int uwsgi_hook_wait_for_fs(char *arg) {
+	return uwsgi_wait_for_fs(arg, 0);
+}
+
+static int uwsgi_hook_wait_for_file(char *arg) {
+	return uwsgi_wait_for_fs(arg, 1);
+}
+
+static int uwsgi_hook_wait_for_dir(char *arg) {
+	return uwsgi_wait_for_fs(arg, 2);
+}
+
 void uwsgi_register_base_hooks() {
 	uwsgi_register_hook("cd", uwsgi_hook_chdir);
 	uwsgi_register_hook("chdir", uwsgi_hook_chdir);
@@ -589,61 +592,182 @@ void uwsgi_register_base_hooks() {
 	uwsgi_register_hook("rpc", uwsgi_hook_rpc);
 	uwsgi_register_hook("retryrpc", uwsgi_hook_retryrpc);
 
+	uwsgi_register_hook("wait_for_fs", uwsgi_hook_wait_for_fs);
+	uwsgi_register_hook("wait_for_file", uwsgi_hook_wait_for_file);
+	uwsgi_register_hook("wait_for_dir", uwsgi_hook_wait_for_dir);
+
 	// for testing
 	uwsgi_register_hook("exit", uwsgi_hook_exit);
 	uwsgi_register_hook("print", uwsgi_hook_print);
 	uwsgi_register_hook("log", uwsgi_hook_print);
 }
 
-void uwsgi_hooks_run(struct uwsgi_string_list *l, char *phase, int fatal) {
+int uwsgi_hooks_run_and_return(struct uwsgi_string_list *l, char *phase, char *context, int fatal) {
+	int final_ret = 0;
 	struct uwsgi_string_list *usl = NULL;
-	uwsgi_foreach(usl, l) {
-		char *colon = strchr(usl->value, ':');
-		if (!colon) {
-			uwsgi_log("invalid hook syntax, must be hook:args\n");
-			exit(1);
-		}
-		*colon = 0;
-		int private = 0;
-		char *action = usl->value;
-		// private hook ?
-		if (action[0] == '!') {
-			action++;
-			private = 1;
+	if (context) {
+		if (setenv("UWSGI_HOOK_CONTEXT", context, 1)) {
+			uwsgi_error("uwsgi_hooks_run_and_return()/setenv()");
+			return -1;
 		}
-		struct uwsgi_hook *uh = uwsgi_hook_by_name(action);
-		if (!uh) {
-			uwsgi_log("hook action not found: %s\n", action);
-			exit(1);
+	}
+        uwsgi_foreach(usl, l) {
+                char *colon = strchr(usl->value, ':');
+                if (!colon) {
+                        uwsgi_log("invalid hook syntax, must be hook:args\n");
+                        exit(1);
+                }
+                *colon = 0;
+                int private = 0;
+                char *action = usl->value;
+                // private hook ?
+                if (action[0] == '!') {
+                        action++;
+                        private = 1;
+                }
+                struct uwsgi_hook *uh = uwsgi_hook_by_name(action);
+                if (!uh) {
+                        uwsgi_log("hook action not found: %s\n", action);
+                        exit(1);
+                }
+                *colon = ':';
+
+                if (private) {
+                        uwsgi_log("running --- PRIVATE HOOK --- (%s)...\n", phase);
+                }
+                else {
+                        uwsgi_log("running \"%s\" (%s)...\n", usl->value, phase);
+                }
+
+                int ret = uh->func(colon+1);
+		if (ret != 0) {
+			if (fatal) {
+				if (context) {
+					unsetenv("UWSGI_HOOK_CONTEXT");
+				}
+				return ret;
+			}
+			final_ret = ret;
 		}
-		*colon = ':';
+        }
 
-		if (private) {
-			uwsgi_log("running --- PRIVATE HOOK --- (%s)...\n", phase);
+	if (context) {
+		unsetenv("UWSGI_HOOK_CONTEXT");
+	}
+
+	return final_ret;
+}
+
+void uwsgi_hooks_run(struct uwsgi_string_list *l, char *phase, int fatal) {
+	int ret = uwsgi_hooks_run_and_return(l, phase, NULL, fatal);
+	if (fatal && ret != 0) {
+		uwsgi_log_verbose("FATAL hook failed, destroying instance\n");
+		if (uwsgi.master_process) {
+			if (uwsgi.workers) {
+				if (uwsgi.workers[0].pid == getpid()) {
+					kill_them_all(0);
+					return;
+				}
+				else {
+                                       	if (kill(uwsgi.workers[0].pid, SIGINT)) {
+						uwsgi_error("uwsgi_hooks_run()/kill()");
+						exit(1);
+					}
+					return;
+                               	}
+			}
 		}
-		else {
-			uwsgi_log("running \"%s\" (%s)...\n", usl->value, phase);
+		exit(1);
+	}
+}
+
+#if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL)
+/*
+this is a special hook, allowing the Emperor to enter a vassal
+namespace and call hooks in its namespace context.
+*/
+void uwsgi_hooks_setns_run(struct uwsgi_string_list *l, pid_t pid, uid_t uid, gid_t gid) {
+	int (*u_setns) (int, int) = (int (*)(int, int)) dlsym(RTLD_DEFAULT, "setns");
+        if (!u_setns) {
+                uwsgi_log("your system misses setns() syscall !!!\n");
+		return;
+        }
+
+	struct uwsgi_string_list *usl = NULL;
+	uwsgi_foreach(usl, l) {
+		// fist of all fork() the current process
+		pid_t new_pid = fork();
+		if (new_pid > 0) {
+			// wait for its death
+			int status;
+			if (waitpid(new_pid, &status, 0) < 0) {
+				uwsgi_error("uwsgi_hooks_setns_run()/waitpid()");
+			}
 		}
-			
-		int ret = uh->func(colon+1);
-		if (fatal && ret != 0) {
-			uwsgi_log_verbose("FATAL hook failed, destroying instance\n");
-			if (uwsgi.master_process) {
-				if (uwsgi.workers) {
-					if (uwsgi.workers[0].pid == getpid()) {
-						kill_them_all(0);
-						return;
-					}
-					else {
-                                        	if (kill(uwsgi.workers[0].pid, SIGINT)) {
-							uwsgi_error("uwsgi_hooks_run()/kill()");
-							exit(1);
-						}
-						return;
-                                	}
+		else if (new_pid == 0) {
+			// from now on, freeing memory is useless
+			// now split args to know which namespaces to join
+			char *action = strchr(usl->value, ' ');
+			if (!action) {
+				uwsgi_log("invalid setns hook syntax, must be \"namespaces_list action:...\"\n");
+				exit(1);
+			}
+			char *pidstr = uwsgi_num2str(pid);
+			char *uidstr = uwsgi_num2str(uid);
+			char *gidstr = uwsgi_num2str(gid);
+
+			char *namespaces = uwsgi_concat2n(usl->value, action-usl->value, "", 0);
+        		char *p, *ctx = NULL;
+        		uwsgi_foreach_token(namespaces, ",", p, ctx) {
+				char *procfile = uwsgi_concat4("/proc/", pidstr, "/ns/", p);
+				int fd = open(procfile, O_RDONLY);
+				if (fd < 0) {
+					uwsgi_error_open(procfile);
+					exit(1);
+				}
+				if (u_setns(fd, 0) < 0){
+					uwsgi_error("uwsgi_hooks_setns_run()/setns()");
+					exit(1);
 				}
+
+                	}
+
+			if (setenv("UWSGI_VASSAL_PID", pidstr, 1)) {
+				uwsgi_error("uwsgi_hooks_setns_run()/setenv()");
+				exit(1);
+			}
+
+			if (setenv("UWSGI_VASSAL_UID", uidstr, 1)) {
+				uwsgi_error("uwsgi_hooks_setns_run()/setenv()");
+				exit(1);
 			}
-			exit(1);
+
+			if (setenv("UWSGI_VASSAL_GID", gidstr, 1)) {
+				uwsgi_error("uwsgi_hooks_setns_run()/setenv()");
+				exit(1);
+			}
+
+			// now run the action and then exit
+			action++;
+			char *colon = strchr(action, ':');
+			if (!colon) {
+				uwsgi_log("invalid hook syntax must be action:arg\n");
+				exit(1);
+			}
+			*colon = 0;
+			struct uwsgi_hook *uh = uwsgi_hook_by_name(action);
+                	if (!uh) {
+                        	uwsgi_log("hook action not found: %s\n", action);
+                        	exit(1);
+                	}
+                	*colon = ':';
+
+                        uwsgi_log("running \"%s\" (setns)...\n", usl->value);
+                	exit(uh->func(colon+1));
+		}
+		else {
+			uwsgi_error("uwsgi_hooks_setns_run()/fork()");
 		}
 	}
 }
+#endif
diff --git a/core/ini.c b/core/ini.c
index 9069fcb..61a3c26 100644
--- a/core/ini.c
+++ b/core/ini.c
@@ -9,7 +9,7 @@ extern struct uwsgi_server uwsgi;
 
 static char *last_file = NULL;
 
-void ini_rstrip(char *line) {
+static void ini_rstrip(char *line) {
 
 	off_t i;
 
@@ -22,7 +22,7 @@ void ini_rstrip(char *line) {
 	}
 }
 
-char *ini_lstrip(char *line) {
+static char *ini_lstrip(char *line) {
 
 	off_t i;
 	char *ptr = line;
@@ -38,7 +38,7 @@ char *ini_lstrip(char *line) {
 	return ptr;
 }
 
-char *ini_get_key(char *key) {
+static char *ini_get_key(char *key) {
 
 	off_t i;
 	char *ptr = key;
@@ -54,7 +54,7 @@ char *ini_get_key(char *key) {
 	return ptr;
 }
 
-char *ini_get_line(char *ini, size_t size) {
+static char *ini_get_line(char *ini, size_t size) {
 
 	size_t i;
 	char *ptr = ini;
@@ -171,5 +171,58 @@ void uwsgi_ini_config(char *file, char *magic_table[]) {
 		colon[0] = ':';
 	}
 
+}
+
+void uwsgi_emperor_ini_attrs(char *filename, char *section_asked, struct uwsgi_dyn_dict **attrs) {
+	if (!section_asked) section_asked = "emperor";
+
+	char *ini = uwsgi_simple_file_read(filename);
+	if (!ini) return;
+
+	char *orig_ini = ini;
 
+	size_t len = strlen(ini);
+	char *section = "";
+	char *key, *val, *ini_line;
+
+	while (len) {
+                ini_line = ini_get_line(ini, len);
+                if (ini_line == NULL) {
+                        break;
+                }
+                // skip empty line
+                key = ini_lstrip(ini);
+                ini_rstrip(key);
+                if (key[0] != 0) {
+                        if (key[0] == '[') {
+                                section = key + 1;
+                                section[strlen(section) - 1] = 0;
+                        }
+                        else if (key[0] == ';' || key[0] == '#') {
+                                // this is a comment
+                        }
+                        else {
+                                // val is always valid, but (obviously) can be ignored
+                                val = ini_get_key(key);
+
+                                if (!strcmp(section, section_asked)) {
+                                        ini_rstrip(key);
+					struct uwsgi_string_list *usl = uwsgi_string_list_has_item(uwsgi.emperor_collect_attributes, key, strlen(key));
+					if (usl) {
+                                        	val = ini_lstrip(val);
+                                        	ini_rstrip(val);
+						char *value = uwsgi_str(val);
+                                        	uwsgi_dyn_dict_new(attrs, usl->value, usl->len, value, strlen(value));
+					}
+                                }
+                        }
+                }
+
+
+                len -= (ini_line - ini);
+                ini += (ini_line - ini);
+
+        }
+	
+	free(orig_ini);
 }
diff --git a/core/init.c b/core/init.c
index 6ee0159..ea4121a 100644
--- a/core/init.c
+++ b/core/init.c
@@ -61,6 +61,7 @@ struct http_status_codes hsc[] = {
 void uwsgi_init_default() {
 
 	uwsgi.cpus = 1;
+	uwsgi.new_argc = -1;
 
 	uwsgi.backtrace_depth = 64;
 	uwsgi.max_apps = 64;
@@ -105,7 +106,8 @@ void uwsgi_init_default() {
 
 	uwsgi.forkbomb_delay = 2;
 
-	uwsgi.async = 1;
+	uwsgi.async = 0;
+	uwsgi.async_warn_if_queue_full = 1;
 	uwsgi.listen_queue = 100;
 
 	uwsgi.cheaper_overload = 3;
@@ -252,9 +254,20 @@ void uwsgi_commandline_config() {
 	int i;
 
 	uwsgi.option_index = -1;
+	// required in case we want to call getopt_long from the beginning
+	optind = 0;
+
+	int argc = uwsgi.argc;
+	char **argv = uwsgi.argv;
+
+	if (uwsgi.new_argc > -1 && uwsgi.new_argv) {
+		argc = uwsgi.new_argc;
+		argv = uwsgi.new_argv;
+	}
+
 
 	char *optname;
-	while ((i = getopt_long(uwsgi.argc, uwsgi.argv, uwsgi.short_options, uwsgi.long_options, &uwsgi.option_index)) != -1) {
+	while ((i = getopt_long(argc, argv, uwsgi.short_options, uwsgi.long_options, &uwsgi.option_index)) != -1) {
 
 		if (i == '?') {
 			uwsgi_log("getopt_long() error\n");
@@ -280,9 +293,9 @@ void uwsgi_commandline_config() {
 	uwsgi_log("optind:%d argc:%d\n", optind, uwsgi.argc);
 #endif
 
-	if (optind < uwsgi.argc) {
-		for (i = optind; i < uwsgi.argc; i++) {
-			char *lazy = uwsgi.argv[i];
+	if (optind < argc) {
+		for (i = optind; i < argc; i++) {
+			char *lazy = argv[i];
 			if (lazy[0] != '[') {
 				uwsgi_opt_load(NULL, lazy, NULL);
 				// manage magic mountpoint
@@ -407,7 +420,7 @@ pid_t uwsgi_daemonize2() {
 // fix/check related options
 void sanitize_args() {
 
-        if (uwsgi.async > 1) {
+        if (uwsgi.async > 0) {
                 uwsgi.cores = uwsgi.async;
         }
 
diff --git a/core/io.c b/core/io.c
index 2167d71..dc492b0 100644
--- a/core/io.c
+++ b/core/io.c
@@ -90,7 +90,7 @@ char *uwsgi_simple_file_read(char *filename) {
 	}
 
 	if (fstat(fd, &sb)) {
-		uwsgi_error("fstat()");
+		uwsgi_error("uwsgi_simple_file_read()/fstat()");
 		close(fd);
 		goto end;
 	}
@@ -99,7 +99,7 @@ char *uwsgi_simple_file_read(char *filename) {
 
 	len = read(fd, buffer, sb.st_size);
 	if (len != sb.st_size) {
-		uwsgi_error("read()");
+		uwsgi_error("uwsgi_simple_file_read()/read()");
 		free(buffer);
 		close(fd);
 		goto end;
@@ -112,7 +112,7 @@ char *uwsgi_simple_file_read(char *filename) {
 	buffer[sb.st_size] = 0;
 	return buffer;
 end:
-	return (char *) "";
+	return NULL;
 
 }
 
@@ -277,7 +277,7 @@ static char *uwsgi_scheme_emperor(char *url, size_t *size, int add_zero) {
 		remains-=rlen;
 	}
 
-	remains = uh.pktsize;
+	remains = uh._pktsize;
 	if (!remains) {
 		uwsgi_log("[uwsgi-vassal] invalid config from %s\n", url);
 		exit(1);
@@ -300,7 +300,7 @@ static char *uwsgi_scheme_emperor(char *url, size_t *size, int add_zero) {
                 remains-=rlen;
 	}
 
-	*size = uh.pktsize + add_zero;
+	*size = uh._pktsize + add_zero;
 	return buffer;
 }
 
@@ -1063,7 +1063,7 @@ readok:
         }
 
 	struct uwsgi_header *uh = (struct uwsgi_header *) buf;
-	uint16_t pktsize = uh->pktsize;
+	uint16_t pktsize = uh->_pktsize;
 	if (modifier1)
 		*modifier1 = uh->modifier1;
 	if (modifier2)
@@ -1502,3 +1502,129 @@ clear:
 #endif
 }
 
+ssize_t uwsgi_recv_cred_and_fds(int fd, char *buf, size_t buf_len, pid_t *pid, uid_t *uid, gid_t *gid, int *fds, int *fds_count) {
+#if defined(SCM_CREDENTIALS) && defined(SCM_RIGHTS)
+        ssize_t ret = -1;
+
+	size_t msg_len = CMSG_SPACE(sizeof(struct ucred)) + CMSG_SPACE(sizeof(int) * (*fds_count));
+
+	// allocate space for credentials and file descriptors
+        void *msg_control = uwsgi_calloc(msg_len);
+
+	// read into buf
+        struct iovec iov;
+        iov.iov_base = buf;
+        iov.iov_len = buf_len;
+
+        struct msghdr msg;
+        memset(&msg, 0, sizeof(msg));
+
+        msg.msg_name = NULL;
+        msg.msg_namelen = 0;
+
+        msg.msg_iov = &iov;
+        msg.msg_iovlen = 1;
+
+	// set cmsg
+        msg.msg_control = msg_control;
+        msg.msg_controllen = msg_len;
+
+        ssize_t len = recvmsg(fd, &msg, 0);
+        if (len <= 0) {
+                uwsgi_error("uwsgi_recv_cred_and_fds()/recvmsg()");
+                goto clear;
+        }
+
+	// reset the number of fds
+	*fds_count = 0;
+
+        struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
+	while(cmsg) {
+        	if (cmsg->cmsg_level != SOL_SOCKET) goto next;
+		if (cmsg->cmsg_type == SCM_RIGHTS) {
+			size_t fds_len = cmsg->cmsg_len - ((char *) CMSG_DATA(cmsg) - (char *) cmsg);			
+			memcpy(fds, CMSG_DATA(cmsg), fds_len);
+			*fds_count = fds_len/sizeof(int);
+		}
+		else if (cmsg->cmsg_type == SCM_CREDENTIALS) {
+        		struct ucred *u = (struct ucred *) CMSG_DATA(cmsg);
+        		*pid = u->pid;
+        		*uid = u->uid;
+        		*gid = u->gid;
+		}
+next:
+		cmsg=CMSG_NXTHDR(&msg,cmsg);
+        }
+
+        ret = len;
+
+clear:
+        free(msg_control);
+        return ret;
+#else
+        return -1;
+#endif
+}
+
+
+int uwsgi_send_fds_and_body(int fd, int *fds, int fds_count, char *body, size_t len) {
+
+	int ret = -1;
+
+        struct msghdr msg;
+        void *msg_control = uwsgi_malloc(CMSG_SPACE(sizeof(int) * fds_count));
+        struct iovec iov;
+        struct cmsghdr *cmsg;
+
+        iov.iov_base = body;
+        iov.iov_len = len;
+
+        msg.msg_name = NULL;
+        msg.msg_namelen = 0;
+
+        msg.msg_iov = &iov;
+        msg.msg_iovlen = 1;
+
+        msg.msg_flags = 0;
+        msg.msg_control = msg_control;
+        msg.msg_controllen = CMSG_SPACE(sizeof(int) * fds_count);
+
+        cmsg = CMSG_FIRSTHDR(&msg);
+        cmsg->cmsg_len = CMSG_LEN(sizeof(int) * fds_count);
+        cmsg->cmsg_level = SOL_SOCKET;
+        cmsg->cmsg_type = SCM_RIGHTS;
+
+        unsigned char *fd_ptr = CMSG_DATA(cmsg);
+
+        memcpy(fd_ptr, fds, sizeof(int) * fds_count);
+
+        ssize_t rlen = sendmsg(fd, &msg, 0);
+	if (rlen <= 0) {
+                uwsgi_error("uwsgi_send_fds_and_body()/sendmsg()");
+		goto end;	
+        }
+	else {
+		size_t remains = len - rlen;
+		while(remains > 0) {
+			char *buf = body + rlen;
+			ssize_t wlen = write(fd, buf, remains);
+			if (wlen == 0) goto end;
+			if (wlen < 0) {
+				if (uwsgi_is_again()) {
+					// wait for write
+					continue;
+				}
+				uwsgi_error("uwsgi_send_fds_and_body()/write()");
+				goto end;
+			}
+			rlen += wlen;
+			remains -= wlen;
+		}
+	}
+	ret = 0;
+
+end:
+        free(msg_control);
+	return ret;	
+}
+
diff --git a/core/legion.c b/core/legion.c
index 997bf0b..b767e3c 100644
--- a/core/legion.c
+++ b/core/legion.c
@@ -572,7 +572,7 @@ static void *legion_loop(void *foobar) {
 
 			d_len += d2_len;
 
-			if (d_len != uh->pktsize) {
+			if (d_len != uh->_pktsize) {
 				uwsgi_log("[uwsgi-legion] invalid packet size\n");
 				continue;
 			}
diff --git a/core/logging.c b/core/logging.c
index ec219ab..8c1d05f 100644
--- a/core/logging.c
+++ b/core/logging.c
@@ -715,12 +715,12 @@ void uwsgi_logit_simple(struct wsgi_request *wsgi_req) {
 
 	}
 
-	rlen = snprintf(logpkt, 4096, "[pid: %d|app: %d|req: %d/%llu] %.*s (%.*s) {%d vars in %d bytes} [%.*s] %.*s %.*s => generated %llu bytes in %llu %s%s(%.*s %d) %d headers in %llu bytes (%d switches on core %d)\n", (int) uwsgi.mypid, wsgi_req->app_id, app_req, (unsigned long long) uwsgi.workers[0].requests, wsgi_req->remote_addr_len, wsgi_req->remote_addr, wsgi_req->remote_user_len, wsgi_req->remote_user, wsgi_req->var_cnt, wsgi_req->uh->pktsize,
+	rlen = snprintf(logpkt, 4096, "[pid: %d|app: %d|req: %d/%llu] %.*s (%.*s) {%d vars in %llu bytes} [%.*s] %.*s %.*s => generated %llu bytes in %llu %s%s(%.*s %d) %d headers in %llu bytes (%d switches on core %d)\n", (int) uwsgi.mypid, wsgi_req->app_id, app_req, (unsigned long long) uwsgi.workers[0].requests, wsgi_req->remote_addr_len, wsgi_req->remote_addr, wsgi_req->remote_user_len, wsgi_req->remote_user, wsgi_req->var_cnt, (unsigned long long) wsgi_req->len,
 			24, time_request, wsgi_req->method_len, wsgi_req->method, wsgi_req->uri_len, wsgi_req->uri, (unsigned long long) wsgi_req->response_size, (unsigned long long) rt, tsize, via, wsgi_req->protocol_len, wsgi_req->protocol, wsgi_req->status, wsgi_req->header_cnt, (unsigned long long) wsgi_req->headers_size, wsgi_req->switches, wsgi_req->async_id);
 
 	// not enough space for logging the request, just log a (safe) minimal message
 	if (rlen > 4096) {
-		rlen = snprintf(logpkt, 4096, "[pid: %d|app: %d|req: %d/%llu] 0.0.0.0 () {%d vars in %d bytes} [%.*s] - - => generated %llu bytes in %llu %s%s(- %d) %d headers in %llu bytes (%d switches on core %d)\n", (int) uwsgi.mypid, wsgi_req->app_id, app_req, (unsigned long long) uwsgi.workers[0].requests, wsgi_req->var_cnt, wsgi_req->uh->pktsize,
+		rlen = snprintf(logpkt, 4096, "[pid: %d|app: %d|req: %d/%llu] 0.0.0.0 () {%d vars in %llu bytes} [%.*s] - - => generated %llu bytes in %llu %s%s(- %d) %d headers in %llu bytes (%d switches on core %d)\n", (int) uwsgi.mypid, wsgi_req->app_id, app_req, (unsigned long long) uwsgi.workers[0].requests, wsgi_req->var_cnt, (unsigned long long) wsgi_req->len,
 		24, time_request, (unsigned long long) wsgi_req->response_size, (unsigned long long) rt, tsize, via, wsgi_req->status, wsgi_req->header_cnt, (unsigned long long) wsgi_req->headers_size, wsgi_req->switches, wsgi_req->async_id);
 		// argh, last resort, truncate it
 		if (rlen > 4096) {
@@ -1215,7 +1215,7 @@ static ssize_t uwsgi_lf_rssM(struct wsgi_request * wsgi_req, char **buf) {
 }
 
 static ssize_t uwsgi_lf_pktsize(struct wsgi_request * wsgi_req, char **buf) {
-	*buf = uwsgi_num2str(wsgi_req->uh->pktsize);
+	*buf = uwsgi_num2str(wsgi_req->len);
 	return strlen(*buf);
 }
 
diff --git a/core/master.c b/core/master.c
index 07c0b64..00ae1fa 100644
--- a/core/master.c
+++ b/core/master.c
@@ -861,10 +861,7 @@ int master_loop(char **argv, char **environ) {
 						if (touched) {
 							uwsgi_log_verbose("*** %s has been touched... reloading daemon \"%s\" (pid: %d) !!! ***\n", touched, ud->command, (int) ud->pid);
 							if (kill(-ud->pid, ud->stop_signal)) {
-								// killing process group failed, try to kill by process id
-								if (kill(ud->pid, ud->stop_signal)) {
-									uwsgi_error("[uwsgi-daemon/touch] kill()");
-								}
+								uwsgi_error("[uwsgi-daemon/touch] kill()");
 							}
 						}
                 			}
@@ -967,7 +964,9 @@ next:
 		// ok a worker died...
 		uwsgi.workers[thewid].pid = 0;
 		// only to be safe :P
-		uwsgi.workers[thewid].harakiri = 0;
+		for(i=0;i<uwsgi.cores;i++) {
+			uwsgi.workers[thewid].cores[i].harakiri = 0;
+		}
 
 		// ok, if we are reloading or dying, just continue the master loop
 		// as soon as all of the workers have pid == 0, the action (exit, or reload) is triggered
diff --git a/core/master_checks.c b/core/master_checks.c
index 656ca90..7da0e53 100644
--- a/core/master_checks.c
+++ b/core/master_checks.c
@@ -138,25 +138,12 @@ void uwsgi_master_check_idle() {
 			uwsgi.workers[i].cheaped = 1;
 			if (uwsgi.workers[i].pid == 0)
 				continue;
-			// first send SIGINT
-			kill(uwsgi.workers[i].pid, SIGINT);
-			// and start waiting upto 3 seconds
-			int j;
-			for(j=0;j<3;j++) {
-				sleep(1);
-				int ret = waitpid(uwsgi.workers[i].pid, &waitpid_status, WNOHANG);
-				if (ret == 0) continue;
-				if (ret == (int) uwsgi.workers[i].pid) goto done;
-				// on error, directly send SIGKILL
-				break;
-			}
 			kill(uwsgi.workers[i].pid, SIGKILL);
 			if (waitpid(uwsgi.workers[i].pid, &waitpid_status, 0) < 0) {
 				if (errno != ECHILD)
 					uwsgi_error("uwsgi_master_check_idle()/waitpid()");
 			}
 			else {
-done:
 				uwsgi.workers[i].pid = 0;
 				uwsgi.workers[i].rss_size = 0;
 				uwsgi.workers[i].vsz_size = 0;
@@ -170,21 +157,27 @@ done:
 }
 
 int uwsgi_master_check_workers_deadline() {
-	int i;
+	int i,j;
 	int ret = 0;
 	for (i = 1; i <= uwsgi.numproc; i++) {
-		/* first check for harakiri */
-		if (uwsgi.workers[i].harakiri > 0) {
-			if (uwsgi.workers[i].harakiri < (time_t) uwsgi.current_time) {
-				trigger_harakiri(i);
-				ret = 1;
+		for(j=0;j<uwsgi.cores;j++) {
+			/* first check for harakiri */
+			if (uwsgi.workers[i].cores[j].harakiri > 0) {
+				if (uwsgi.workers[i].cores[j].harakiri < (time_t) uwsgi.current_time) {
+					uwsgi_log_verbose("HARAKIRI triggered by worker %d core %d !!!\n", i, j);
+					trigger_harakiri(i);
+					ret = 1;
+					break;
+				}
 			}
-		}
-		/* then user-defined harakiri */
-		if (uwsgi.workers[i].user_harakiri > 0) {
-			if (uwsgi.workers[i].user_harakiri < (time_t) uwsgi.current_time) {
-				trigger_harakiri(i);
-				ret = 1;
+			/* then user-defined harakiri */
+			if (uwsgi.workers[i].cores[j].user_harakiri > 0) {
+				uwsgi_log_verbose("HARAKIRI (user) triggered by worker %d core %d !!!\n", i, j);
+				if (uwsgi.workers[i].cores[j].user_harakiri < (time_t) uwsgi.current_time) {
+					trigger_harakiri(i);
+					ret = 1;
+					break;
+				}
 			}
 		}
 		// then for evil memory checkers
@@ -348,7 +341,6 @@ int uwsgi_master_check_daemons_death(int diedpid) {
 
 int uwsgi_worker_is_busy(int wid) {
 	int i;
-	if (uwsgi.workers[uwsgi.mywid].sig) return 1;
 	for(i=0;i<uwsgi.cores;i++) {
 		if (uwsgi.workers[wid].cores[i].in_request) {
 			return 1;
diff --git a/core/master_events.c b/core/master_events.c
index eac8d0d..a8bec0f 100644
--- a/core/master_events.c
+++ b/core/master_events.c
@@ -45,7 +45,7 @@ int uwsgi_master_manage_events(int interesting_fd) {
 	// emperor event ?
 	if (uwsgi.has_emperor) {
 		if (uwsgi.emperor_fd_proxy > -1 && interesting_fd == uwsgi.emperor_fd_proxy) {
-			uwsgi_master_manage_emperor_proxy();	
+			uwsgi_master_manage_emperor_proxy(uwsgi.emperor_fd_proxy, uwsgi.emperor_fd, uwsgi.emperor_fd_config, -1);	
 			return 0;
 		}
 
diff --git a/core/master_utils.c b/core/master_utils.c
index fcc0195..b0d3d28 100644
--- a/core/master_utils.c
+++ b/core/master_utils.c
@@ -162,7 +162,6 @@ int uwsgi_calc_cheaper(void) {
 			ignore_algo = 1;
 		}
 		uwsgi.cheaper_fifo_delta = 0;
-		goto safe;
 	}
 
 	// if cheaper limits wants to change worker count, then skip cheaper algo
@@ -173,7 +172,6 @@ int uwsgi_calc_cheaper(void) {
 		needed_workers = 0;
 	}
 
-safe:
 	if (needed_workers > 0) {
 		for (i = 1; i <= uwsgi.numproc; i++) {
 			if (uwsgi.workers[i].cheaped == 1 && uwsgi.workers[i].pid == 0) {
@@ -390,6 +388,8 @@ void uwsgi_reload(char **argv) {
 	int i;
 	int waitpid_status;
 
+	if (uwsgi.new_argv) argv = uwsgi.new_argv;
+
 	if (!uwsgi.master_is_reforked) {
 
 		// call a series of waitpid to ensure all processes (gateways, mules and daemons) are dead
@@ -632,7 +632,7 @@ void uwsgi_fixup_fds(int wid, int muleid, struct uwsgi_gateway *ug) {
 }
 
 int uwsgi_respawn_worker(int wid) {
-
+	int i;
 	int respawns = uwsgi.workers[wid].respawn_count;
 	// the workers is not accepting (obviously)
 	uwsgi.workers[wid].accepting = 0;
@@ -641,8 +641,10 @@ int uwsgi_respawn_worker(int wid) {
 	// ... same for update time
 	uwsgi.workers[wid].last_spawn = uwsgi.current_time;
 	// ... and memory/harakiri
-	uwsgi.workers[wid].harakiri = 0;
-	uwsgi.workers[wid].user_harakiri = 0;
+	for(i=0;i<uwsgi.cores;i++) {
+		uwsgi.workers[wid].cores[i].harakiri = 0;
+		uwsgi.workers[wid].cores[i].user_harakiri = 0;
+	}
 	uwsgi.workers[wid].pending_harakiri = 0;
 	uwsgi.workers[wid].rss_size = 0;
 	uwsgi.workers[wid].vsz_size = 0;
@@ -660,8 +662,6 @@ int uwsgi_respawn_worker(int wid) {
 	// this is required for various checks
 	uwsgi.workers[wid].delta_requests = 0;
 
-	int i;
-
 	if (uwsgi.threaded_logger) {
 		pthread_mutex_lock(&uwsgi.threaded_logger_lock);
 	}
diff --git a/core/mule.c b/core/mule.c
index 8a2211c..a40a177 100644
--- a/core/mule.c
+++ b/core/mule.c
@@ -198,7 +198,7 @@ void uwsgi_mule_handler() {
 #ifdef UWSGI_DEBUG
 			uwsgi_log_verbose("master sent signal %d to mule %d\n", uwsgi_signal, uwsgi.muleid);
 #endif
-			if (uwsgi_signal_handler(uwsgi_signal)) {
+			if (uwsgi_signal_handler(NULL, uwsgi_signal)) {
 				uwsgi_log_verbose("error managing signal %d on mule %d\n", uwsgi_signal, uwsgi.muleid);
 			}
 		}
@@ -362,7 +362,7 @@ retry:
 #ifdef UWSGI_DEBUG
 					uwsgi_log_verbose("master sent signal %d to mule %d\n", uwsgi_signal, uwsgi.muleid);
 #endif
-					if (uwsgi_signal_handler(uwsgi_signal)) {
+					if (uwsgi_signal_handler(NULL, uwsgi_signal)) {
 						uwsgi_log_verbose("error managing signal %d on mule %d\n", uwsgi_signal, uwsgi.muleid);
 					}
 					// set the error condition
diff --git a/core/offload.c b/core/offload.c
index d77bc9b..0ec75bd 100644
--- a/core/offload.c
+++ b/core/offload.c
@@ -613,6 +613,9 @@ int uwsgi_offload_run(struct wsgi_request *wsgi_req, struct uwsgi_offload_reques
 
         if (uor->takeover) {
                 wsgi_req->fd_closed = 1;
+		// avoid edge-triggered mode
+		if (wsgi_req->socket->retry)
+			wsgi_req->socket->retry[wsgi_req->async_id] = 0;
         }
 
 	if (uwsgi_offload_enqueue(wsgi_req, uor)) {
diff --git a/core/protocol.c b/core/protocol.c
index 2831968..5e650af 100644
--- a/core/protocol.c
+++ b/core/protocol.c
@@ -46,10 +46,10 @@ int uwsgi_read_response(int fd, struct uwsgi_header *uh, int timeout, char **buf
 		break;
 	}
 
-	if (buf && uh->pktsize > 0) {
+	if (buf && uh->_pktsize > 0) {
 		if (*buf == NULL)
-			*buf = uwsgi_malloc(uh->pktsize);
-		remains = uh->pktsize;
+			*buf = uwsgi_malloc(uh->_pktsize);
+		remains = uh->_pktsize;
 		ptr = *buf;
 		ret = -1;
 		while (remains > 0) {
@@ -578,7 +578,7 @@ int uwsgi_parse_vars(struct wsgi_request *wsgi_req) {
 	struct uwsgi_dyn_dict *udd;
 
 	ptrbuf = buffer;
-	bufferend = ptrbuf + wsgi_req->uh->pktsize;
+	bufferend = ptrbuf + wsgi_req->len;
 	int i;
 
 	/* set an HTTP 500 status as default */
@@ -736,40 +736,25 @@ next:
 			}
 
 			for (i = 0; i < uwsgi_apps_cnt; i++) {
-				char* mountpoint = uwsgi_apps[i].mountpoint;
-				int mountpoint_len = uwsgi_apps[i].mountpoint_len;
-
-				// Ignore trailing mountpoint slashes
-				if (mountpoint_len > 0 && mountpoint[mountpoint_len - 1] == '/') {
-					mountpoint_len -= 1;
-				}
-
 				//uwsgi_log("app mountpoint = %.*s\n", uwsgi_apps[i].mountpoint_len, uwsgi_apps[i].mountpoint);
-
-				// Check if mountpoint could be a possible candidate
-				if (orig_path_info_len < mountpoint_len || // it should be shorter than or equal to path_info
-					mountpoint_len <= best_found || // it should be better than the previous found
-					// should have the same prefix of path_info
-					uwsgi_startswith(orig_path_info, mountpoint, mountpoint_len) ||
-					// and should not be "misleading"
-					(orig_path_info_len > mountpoint_len && orig_path_info[mountpoint_len] != '/' )) {
-					continue;
-				}
-
-				best_found = mountpoint_len;
-				wsgi_req->script_name = uwsgi_apps[i].mountpoint;
-				wsgi_req->script_name_len = uwsgi_apps[i].mountpoint_len;
-				wsgi_req->path_info = orig_path_info + wsgi_req->script_name_len;
-				wsgi_req->path_info_len = orig_path_info_len - wsgi_req->script_name_len;
-
-				wsgi_req->hvec[wsgi_req->script_name_pos].iov_base = wsgi_req->script_name;
-				wsgi_req->hvec[wsgi_req->script_name_pos].iov_len = wsgi_req->script_name_len;
-
-				wsgi_req->hvec[wsgi_req->path_info_pos].iov_base = wsgi_req->path_info;
-				wsgi_req->hvec[wsgi_req->path_info_pos].iov_len = wsgi_req->path_info_len;
+				if (orig_path_info_len >= uwsgi_apps[i].mountpoint_len) {
+					if (!uwsgi_startswith(orig_path_info, uwsgi_apps[i].mountpoint, uwsgi_apps[i].mountpoint_len) && uwsgi_apps[i].mountpoint_len > best_found) {
+						best_found = uwsgi_apps[i].mountpoint_len;
+						wsgi_req->script_name = uwsgi_apps[i].mountpoint;
+						wsgi_req->script_name_len = uwsgi_apps[i].mountpoint_len;
+						wsgi_req->path_info = orig_path_info + wsgi_req->script_name_len;
+						wsgi_req->path_info_len = orig_path_info_len - wsgi_req->script_name_len;
+
+						wsgi_req->hvec[wsgi_req->script_name_pos].iov_base = wsgi_req->script_name;
+						wsgi_req->hvec[wsgi_req->script_name_pos].iov_len = wsgi_req->script_name_len;
+
+						wsgi_req->hvec[wsgi_req->path_info_pos].iov_base = wsgi_req->path_info;
+						wsgi_req->hvec[wsgi_req->path_info_pos].iov_len = wsgi_req->path_info_len;
 #ifdef UWSGI_DEBUG
-				uwsgi_log("managed SCRIPT_NAME = %.*s PATH_INFO = %.*s\n", wsgi_req->script_name_len, wsgi_req->script_name, wsgi_req->path_info_len, wsgi_req->path_info);
+						uwsgi_log("managed SCRIPT_NAME = %.*s PATH_INFO = %.*s\n", wsgi_req->script_name_len, wsgi_req->script_name, wsgi_req->path_info_len, wsgi_req->path_info);
 #endif
+					}
+				}
 			}
 		}
 	}
@@ -1050,7 +1035,7 @@ char *uwsgi_req_append(struct wsgi_request *wsgi_req, char *key, uint16_t keylen
 		}
 	}
 
-	if ((wsgi_req->uh->pktsize + (2 + keylen + 2 + vallen)) > uwsgi.buffer_size) {
+	if ((wsgi_req->len + (2 + keylen + 2 + vallen)) > uwsgi.buffer_size) {
 		uwsgi_log("not enough buffer space to add %.*s variable, consider increasing it with the --buffer-size option\n", keylen, key);
 		return NULL;
 	}
@@ -1060,7 +1045,7 @@ char *uwsgi_req_append(struct wsgi_request *wsgi_req, char *key, uint16_t keylen
 		return NULL;
 	}
 
-	char *ptr = wsgi_req->buffer + wsgi_req->uh->pktsize;
+	char *ptr = wsgi_req->buffer + wsgi_req->len;
 
 	*ptr++ = (uint8_t) (keylen & 0xff);
 	*ptr++ = (uint8_t) ((keylen >> 8) & 0xff);
@@ -1071,7 +1056,7 @@ char *uwsgi_req_append(struct wsgi_request *wsgi_req, char *key, uint16_t keylen
 	wsgi_req->var_cnt++;
 	ptr += keylen;
 
-
+	
 
 	*ptr++ = (uint8_t) (vallen & 0xff);
 	*ptr++ = (uint8_t) ((vallen >> 8) & 0xff);
@@ -1081,7 +1066,7 @@ char *uwsgi_req_append(struct wsgi_request *wsgi_req, char *key, uint16_t keylen
         wsgi_req->hvec[wsgi_req->var_cnt].iov_len = vallen;
 	wsgi_req->var_cnt++;
 
-	wsgi_req->uh->pktsize += (2 + keylen + 2 + vallen);
+	wsgi_req->len += (2 + keylen + 2 + vallen);
 
 	return ptr;
 }
@@ -1106,7 +1091,7 @@ int uwsgi_req_append_path_info_with_index(struct wsgi_request *wsgi_req, char *i
 	wsgi_req->path_info_len += need_slash + index_len;
 
 	// 2 + 9 + 2
-	if ((wsgi_req->uh->pktsize + (13 + wsgi_req->path_info_len)) > uwsgi.buffer_size) {
+	if ((wsgi_req->len + (13 + wsgi_req->path_info_len)) > uwsgi.buffer_size) {
                 uwsgi_log("not enough buffer space to transform the PATH_INFO variable, consider increasing it with the --buffer-size option\n");
                 return -1;
         }
@@ -1117,7 +1102,7 @@ int uwsgi_req_append_path_info_with_index(struct wsgi_request *wsgi_req, char *i
         }
 
 	uint16_t keylen = 9;
-	char *ptr = wsgi_req->buffer + wsgi_req->uh->pktsize;
+	char *ptr = wsgi_req->buffer + wsgi_req->len;
 	*ptr++ = (uint8_t) (keylen & 0xff);
         *ptr++ = (uint8_t) ((keylen >> 8) & 0xff);
 
@@ -1138,13 +1123,13 @@ int uwsgi_req_append_path_info_with_index(struct wsgi_request *wsgi_req, char *i
 		*ptr ++= '/';
 	}
 	memcpy(ptr, index, index_len);
-
+	
 	wsgi_req->hvec[wsgi_req->var_cnt].iov_base = new_path_info;
         wsgi_req->hvec[wsgi_req->var_cnt].iov_len = wsgi_req->path_info_len;
         wsgi_req->var_cnt++;
 
-	wsgi_req->uh->pktsize += 13 + wsgi_req->path_info_len;
+	wsgi_req->len += 13 + wsgi_req->path_info_len;
 	wsgi_req->path_info = new_path_info;
-
+	
 	return 0;
 }
diff --git a/core/reader.c b/core/reader.c
index 54743a2..23d1f92 100644
--- a/core/reader.c
+++ b/core/reader.c
@@ -477,7 +477,7 @@ int uwsgi_postbuffer_do_in_mem(struct wsgi_request *wsgi_req) {
 
         while (remains > 0) {
                 if (uwsgi.harakiri_options.workers > 0) {
-                        inc_harakiri(uwsgi.harakiri_options.workers);
+                        inc_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
                 }
 
                 ssize_t rlen = wsgi_req->socket->proto_read_body(wsgi_req, ptr, remains);
@@ -551,7 +551,7 @@ int uwsgi_postbuffer_do_in_disk(struct wsgi_request *wsgi_req) {
 
                 // during post buffering we need to constantly reset the harakiri
                 if (uwsgi.harakiri_options.workers > 0) {
-                        inc_harakiri(uwsgi.harakiri_options.workers);
+                        inc_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
                 }
 
                 // we use the already available post buffering buffer to read chunks....
diff --git a/core/routing.c b/core/routing.c
index 7dd1b88..8daab1c 100644
--- a/core/routing.c
+++ b/core/routing.c
@@ -702,7 +702,7 @@ static int uwsgi_router_simple_math_divide(struct uwsgi_route *ur, char *arg) {
 // harakiri router
 static int uwsgi_router_harakiri_func(struct wsgi_request *wsgi_req, struct uwsgi_route *route) {
 	if (route->custom > 0) {	
-		set_user_harakiri(route->custom);
+		set_user_harakiri(wsgi_req, route->custom);
 	}
 	return UWSGI_ROUTE_NEXT;
 }
@@ -2045,19 +2045,5 @@ next4:
 		usl->custom2 = strlen(space+1);
 		uwsgi_log("collecting header %.*s to var %s\n", usl->custom, usl->value, usl->custom_ptr);
 	}
-
-	uwsgi_foreach(usl, uwsgi.pull_headers) {
-                char *space = strchr(usl->value, ' ');
-                if (!space) {
-                        uwsgi_log("invalid pull header syntax, must be <header> <var>\n");
-                        exit(1);
-                }
-                *space = 0;
-                usl->custom = strlen(usl->value);
-                *space = ' ';
-                usl->custom_ptr = space+1;
-                usl->custom2 = strlen(space+1);
-                uwsgi_log("pulling header %.*s to var %s\n", usl->custom, usl->value, usl->custom_ptr);
-        }
 }
 #endif
diff --git a/core/rpc.c b/core/rpc.c
index a2ec004..0008483 100644
--- a/core/rpc.c
+++ b/core/rpc.c
@@ -7,6 +7,11 @@ int uwsgi_register_rpc(char *name, struct uwsgi_plugin *plugin, uint8_t args, vo
 	struct uwsgi_rpc *urpc;
 	int ret = -1;
 
+	if (!uwsgi.workers || !uwsgi.shared || !uwsgi.rpc_table_lock) {
+		uwsgi_log("RPC subsystem still not initialized\n");
+		return -1;
+	}
+
 	if (uwsgi.mywid == 0 && uwsgi.workers[0].pid != uwsgi.mypid) {
 		uwsgi_log("only the master and the workers can register RPC functions\n");
 		return -1;
@@ -140,7 +145,7 @@ char *uwsgi_do_rpc(char *node, char *func, uint8_t argc, char *argv[], uint16_t
 	// set the uwsgi header
 	uh = (struct uwsgi_header *) buffer;
 	uh->modifier1 = 173;
-	uh->pktsize = buffer_size;
+	uh->_pktsize = buffer_size;
 	uh->modifier2 = 0;
 
 	// add func to the array
diff --git a/core/signal.c b/core/signal.c
index 36f048b..093e598 100644
--- a/core/signal.c
+++ b/core/signal.c
@@ -2,7 +2,7 @@
 
 extern struct uwsgi_server uwsgi;
 
-int uwsgi_signal_handler(uint8_t sig) {
+int uwsgi_signal_handler(struct wsgi_request *wsgi_req, uint8_t sig) {
 
 	struct uwsgi_signal_entry *use = NULL;
 
@@ -41,12 +41,12 @@ int uwsgi_signal_handler(uint8_t sig) {
 
 	// set harakiri here (if required and if i am a worker)
 
-	if (uwsgi.mywid > 0) {
+	if (uwsgi.mywid > 0 && wsgi_req) {
 		uwsgi.workers[uwsgi.mywid].sig = 1;
 		uwsgi.workers[uwsgi.mywid].signum = sig;
 		uwsgi.workers[uwsgi.mywid].signals++;
 		if (uwsgi.harakiri_options.workers > 0) {
-			set_harakiri(uwsgi.harakiri_options.workers);
+			set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
 		}
 	}
 	else if (uwsgi.muleid > 0) {
@@ -65,10 +65,10 @@ int uwsgi_signal_handler(uint8_t sig) {
 
 	int ret = uwsgi.p[use->modifier1]->signal_handler(sig, use->handler);
 
-	if (uwsgi.mywid > 0) {
+	if (uwsgi.mywid > 0 && wsgi_req) {
 		uwsgi.workers[uwsgi.mywid].sig = 0;
-		if (uwsgi.workers[uwsgi.mywid].harakiri > 0) {
-			set_harakiri(0);
+		if (uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri > 0) {
+			set_harakiri(wsgi_req, 0);
 		}
 	}
 	else if (uwsgi.muleid > 0) {
@@ -266,7 +266,7 @@ int uwsgi_remote_signal_send(char *addr, uint8_t sig) {
 	struct uwsgi_header uh;
 
 	uh.modifier1 = 110;
-	uh.pktsize = 0;
+	uh._pktsize = 0;
 	uh.modifier2 = sig;
 
         int fd = uwsgi_connect(addr, 0, 1);
@@ -331,16 +331,6 @@ void uwsgi_route_signal(uint8_t sig) {
 			}
 		}
 	}
-	// send to al lactive workers
-	else if (!strcmp(use->receiver, "active-workers")) {
-                for (i = 1; i <= uwsgi.numproc; i++) {
-			if (uwsgi.workers[i].pid > 0 && !uwsgi.workers[i].cheaped && !uwsgi.workers[i].suspended) {
-                        	if (uwsgi_signal_send(uwsgi.workers[i].signal_pipe[0], sig)) {
-                                	uwsgi_log("could not deliver signal %d to worker %d\n", sig, i);
-                        	}
-			}
-                }
-        }
 	// route to specific worker
 	else if (!strncmp(use->receiver, "worker", 6)) {
 		i = atoi(use->receiver + 6);
@@ -415,7 +405,7 @@ void uwsgi_route_signal(uint8_t sig) {
 
 }
 
-int uwsgi_signal_wait(int signum) {
+int uwsgi_signal_wait(struct wsgi_request *wsgi_req, int signum) {
 
 	int wait_for_specific_signal = 0;
 	uint8_t uwsgi_signal = 0;
@@ -440,7 +430,7 @@ cycle:
 				uwsgi_error("read()");
 			}
 			else {
-				(void) uwsgi_signal_handler(uwsgi_signal);
+				(void) uwsgi_signal_handler(wsgi_req, uwsgi_signal);
 				if (wait_for_specific_signal) {
 					if (signum != uwsgi_signal)
 						goto cycle;
@@ -453,7 +443,7 @@ cycle:
 				uwsgi_error("read()");
 			}
 			else {
-				(void) uwsgi_signal_handler(uwsgi_signal);
+				(void) uwsgi_signal_handler(wsgi_req, uwsgi_signal);
 				if (wait_for_specific_signal) {
 					if (signum != uwsgi_signal)
 						goto cycle;
@@ -467,7 +457,7 @@ cycle:
 	return received_signal;
 }
 
-void uwsgi_receive_signal(int fd, char *name, int id) {
+void uwsgi_receive_signal(struct wsgi_request *wsgi_req, int fd, char *name, int id) {
 
 	uint8_t uwsgi_signal;
 
@@ -484,7 +474,7 @@ void uwsgi_receive_signal(int fd, char *name, int id) {
 #ifdef UWSGI_DEBUG
 		uwsgi_log_verbose("master sent signal %d to %s %d\n", uwsgi_signal, name, id);
 #endif
-		if (uwsgi_signal_handler(uwsgi_signal)) {
+		if (uwsgi_signal_handler(wsgi_req, uwsgi_signal)) {
 			uwsgi_log_verbose("error managing signal %d on %s %d\n", uwsgi_signal, name, id);
 		}
 	}
diff --git a/core/socket.c b/core/socket.c
index c4201c2..32a1b2e 100644
--- a/core/socket.c
+++ b/core/socket.c
@@ -51,6 +51,8 @@ char *uwsgi_getsockname(int fd) {
 
 	if (!getsockname(fd, gsa.sa, &socket_type_len)) {
 		if (gsa.sa->sa_family == AF_UNIX) {
+			// unnamed socket ?
+			if (socket_type_len == sizeof(sa_family_t)) return "";
 			if (usa.sa_un.sun_path[0] == 0) {
 				return uwsgi_concat2("@", usa.sa_un.sun_path + 1);
 			}
@@ -189,10 +191,7 @@ int bind_to_unix(char *socket_name, int listen_queue, int chmod_socket, int abst
 
 	memset(uws_addr, 0, sizeof(struct sockaddr_un));
 	serverfd = create_server_socket(AF_UNIX, SOCK_STREAM);
-	if (serverfd < 0) {
-		free(uws_addr);
-		return -1;
-	}
+	if (serverfd < 0) return -1;
 	if (abstract_socket == 0) {
 		if (unlink(socket_name) != 0 && errno != ENOENT) {
 			uwsgi_error("error removing unix socket, unlink()");
@@ -566,7 +565,6 @@ char *generate_socket_name(char *socket_name) {
 		ifa = ifap;
 		while (ifa) {
 			memset(new_addr, 0, 16);
-			if (!ifa->ifa_addr) goto next;
 			sin = (struct sockaddr_in *) ifa->ifa_addr;
 			if (inet_ntop(AF_INET, (void *) &sin->sin_addr.s_addr, new_addr, 16)) {
 				if (!strncmp(socket_name, new_addr, strlen(socket_name))) {
@@ -579,7 +577,6 @@ char *generate_socket_name(char *socket_name) {
 
 			}
 
-next:
 			ifaf = ifa;
 			ifa = ifaf->ifa_next;
 
@@ -1940,6 +1937,7 @@ void uwsgi_protocols_register() {
 	uwsgi_register_protocol("puwsgi", uwsgi_proto_puwsgi_setup);
 
 	uwsgi_register_protocol("http", uwsgi_proto_http_setup);
+	uwsgi_register_protocol("http11", uwsgi_proto_http11_setup);
 
 #ifdef UWSGI_SSL
 	uwsgi_register_protocol("suwsgi", uwsgi_proto_suwsgi_setup);
diff --git a/core/spooler.c b/core/spooler.c
index 9024f38..8f468cc 100644
--- a/core/spooler.c
+++ b/core/spooler.c
@@ -1,11 +1,13 @@
 #include "uwsgi.h"
 
+#ifdef __sun__
+#include "strings.h"
+#endif
+
 extern struct uwsgi_server uwsgi;
 
 static void spooler_readdir(struct uwsgi_spooler *, char *dir);
-#ifdef __linux__
 static void spooler_scandir(struct uwsgi_spooler *, char *dir);
-#endif
 static void spooler_manage_task(struct uwsgi_spooler *, char *, char *);
 
 // increment it whenever a signal is raised
@@ -301,9 +303,9 @@ char *uwsgi_spool_request(struct wsgi_request *wsgi_req, char *buf, size_t len,
 	struct uwsgi_header uh;
 	uh.modifier1 = 17;
 	uh.modifier2 = 0;
-	uh.pktsize = (uint16_t) len;
+	uh._pktsize = (uint16_t) len;
 #ifdef __BIG_ENDIAN__
-	uh.pktsize = uwsgi_swap16(uh.pktsize);
+	uh._pktsize = uwsgi_swap16(uh._pktsize);
 #endif
 
 	if (write(fd, &uh, 4) != 4) {
@@ -438,11 +440,7 @@ void spooler(struct uwsgi_spooler *uspool) {
 		}
 
 		if (uwsgi.spooler_ordered) {
-#ifdef __linux__
 			spooler_scandir(uspool, NULL);
-#else
-			spooler_readdir(uspool, NULL);
-#endif
 		}
 		else {
 			spooler_readdir(uspool, NULL);
@@ -456,7 +454,7 @@ void spooler(struct uwsgi_spooler *uspool) {
 		if (event_queue_wait(spooler_event_queue, timeout, &interesting_fd) > 0) {
 			if (uwsgi.master_process) {
 				if (interesting_fd == uwsgi.shared->spooler_signal_pipe[1]) {
-					uwsgi_receive_signal(interesting_fd, "spooler", (int) getpid());
+					uwsgi_receive_signal(NULL, interesting_fd, "spooler", (int) getpid());
 				}
 			}
 		}
@@ -471,7 +469,6 @@ void spooler(struct uwsgi_spooler *uspool) {
 	}
 }
 
-#ifdef __linux__
 static void spooler_scandir(struct uwsgi_spooler *uspool, char *dir) {
 
 	struct dirent **tasklist;
@@ -480,7 +477,8 @@ static void spooler_scandir(struct uwsgi_spooler *uspool, char *dir) {
 	if (!dir)
 		dir = uspool->dir;
 
-	n = scandir(dir, &tasklist, 0, versionsort);
+	n = scandir(dir, &tasklist, 0, uwsgi_versionsort);
+
 	if (n < 0) {
 		uwsgi_error("scandir()");
 		return;
@@ -493,7 +491,6 @@ static void spooler_scandir(struct uwsgi_spooler *uspool, char *dir) {
 
 	free(tasklist);
 }
-#endif
 
 
 static void spooler_readdir(struct uwsgi_spooler *uspool, char *dir) {
@@ -541,7 +538,6 @@ void spooler_manage_task(struct uwsgi_spooler *uspool, char *dir, char *task) {
 			return;
 		}
 
-#ifdef __linux__
 		if (S_ISDIR(sf_lstat.st_mode) && uwsgi.spooler_ordered) {
 			if (chdir(task)) {
 				uwsgi_error("chdir()");
@@ -555,7 +551,6 @@ void spooler_manage_task(struct uwsgi_spooler *uspool, char *dir, char *task) {
 			}
 			return;
 		}
-#endif
 		if (!S_ISREG(sf_lstat.st_mode)) {
 			return;
 		}
@@ -592,10 +587,10 @@ void spooler_manage_task(struct uwsgi_spooler *uspool, char *dir, char *task) {
 			}
 
 #ifdef __BIG_ENDIAN__
-			uh.pktsize = uwsgi_swap16(uh.pktsize);
+			uh._pktsize = uwsgi_swap16(uh._pktsize);
 #endif
 
-			if (uwsgi_protected_read(spool_fd, spool_buf, uh.pktsize) != uh.pktsize) {
+			if (uwsgi_protected_read(spool_fd, spool_buf, uh._pktsize) != uh._pktsize) {
 				uwsgi_error("read()");
 				destroy_spool(dir, task);
 				uwsgi_protected_close(spool_fd);
@@ -603,8 +598,8 @@ void spooler_manage_task(struct uwsgi_spooler *uspool, char *dir, char *task) {
 			}
 
 			// body available ?
-			if (sf_lstat.st_size > (uh.pktsize + 4)) {
-				body_len = sf_lstat.st_size - (uh.pktsize + 4);
+			if (sf_lstat.st_size > (uh._pktsize + 4)) {
+				body_len = sf_lstat.st_size - (uh._pktsize + 4);
 				body = uwsgi_malloc(body_len);
 				if ((size_t) uwsgi_protected_read(spool_fd, body, body_len) != body_len) {
 					uwsgi_error("read()");
@@ -636,7 +631,7 @@ void spooler_manage_task(struct uwsgi_spooler *uspool, char *dir, char *task) {
 					if (uwsgi.harakiri_options.spoolers > 0) {
 						set_spooler_harakiri(uwsgi.harakiri_options.spoolers);
 					}
-					ret = uwsgi.p[i]->spooler(task, spool_buf, uh.pktsize, body, body_len);
+					ret = uwsgi.p[i]->spooler(task, spool_buf, uh._pktsize, body, body_len);
 					if (uwsgi.harakiri_options.spoolers > 0) {
 						set_spooler_harakiri(0);
 					}
diff --git a/core/ssl.c b/core/ssl.c
index 94c3eaf..124343c 100644
--- a/core/ssl.c
+++ b/core/ssl.c
@@ -210,10 +210,6 @@ SSL_CTX *uwsgi_ssl_new_server_context(char *name, char *crt, char *key, char *ci
         ssloptions |= SSL_OP_NO_COMPRESSION;
 #endif
 
-	if (!uwsgi.sslv3) {
-		ssloptions |= SSL_OP_NO_SSLv3;
-	}
-
 // release/reuse buffers as soon as possibile
 #ifdef SSL_MODE_RELEASE_BUFFERS
         SSL_CTX_set_mode(ctx, SSL_MODE_RELEASE_BUFFERS);
@@ -400,11 +396,6 @@ SSL_CTX *uwsgi_ssl_new_server_context(char *name, char *crt, char *key, char *ci
 
         SSL_CTX_set_timeout(ctx, uwsgi.ssl_sessions_timeout);
 
-	struct uwsgi_string_list *usl = NULL;
-	uwsgi_foreach(usl, uwsgi.ssl_options) {
-		ssloptions |= atoi(usl->value);
-	}
-
         SSL_CTX_set_options(ctx, ssloptions);
 
 
@@ -503,6 +494,13 @@ clear:
 }
 
 char *uwsgi_sanitize_cert_filename(char *base, char *key, uint16_t keylen) {
+	// stop at the first slash if mountpoints are involved
+	if (uwsgi.subscription_mountpoints) {
+		char *slash = memchr(key, '/', keylen);
+		if (slash) {
+			keylen = slash - key;
+		}
+	}
         uint16_t i;
         char *filename = uwsgi_concat4n(base, strlen(base), "/", 1, key, keylen, ".pem\0", 5);
 
diff --git a/core/static.c b/core/static.c
index 86683be..a1a0ec8 100644
--- a/core/static.c
+++ b/core/static.c
@@ -167,6 +167,9 @@ static time_t parse_http_date(char *date, uint16_t len) {
 
 }
 
+time_t uwsgi_parse_http_date(char *buf, uint16_t len) {
+	return parse_http_date(buf, len);
+}
 
 
 int uwsgi_add_expires_type(struct wsgi_request *wsgi_req, char *mime_type, int mime_type_len, struct stat *st) {
diff --git a/core/stats.c b/core/stats.c
index c54b186..22a4b93 100644
--- a/core/stats.c
+++ b/core/stats.c
@@ -569,14 +569,13 @@ static void stats_dump_var(char *k, uint16_t kl, char *v, uint16_t vl, void *dat
 
 int uwsgi_stats_dump_vars(struct uwsgi_stats *us, struct uwsgi_core *uc) {
 	if (!uc->in_request) return 0;
-	struct uwsgi_header *uh = (struct uwsgi_header *) uc->buffer;
-	uint16_t pktsize = uh->pktsize;
+	uint64_t pktsize = uc->req.len;
 	if (!pktsize) return 0;
 	char *dst = uwsgi.workers[0].cores[0].buffer;
 	memcpy(dst, uc->buffer+4, uwsgi.buffer_size);
 	// ok now check if something changed...
 	if (!uc->in_request) return 0;
-	if (uh->pktsize != pktsize) return 0;
+	if (uc->req.len != pktsize) return 0;
 	if (memcmp(dst, uc->buffer+4, uwsgi.buffer_size)) return 0;
 	// nothing changed let's dump vars
 	int ret = uwsgi_hooked_parse(dst, pktsize, stats_dump_var, us);
diff --git a/core/strings.c b/core/strings.c
index cb4667a..c14cf31 100644
--- a/core/strings.c
+++ b/core/strings.c
@@ -65,16 +65,9 @@ char *uwsgi_lower(char *str, size_t size) {
         return str;
 }
 
-// check if a string is contained in another one
+// check if a char is contained in a string
 char *uwsgi_str_contains(char *str, int slen, char what) {
-
-        int i;
-        for (i = 0; i < slen; i++) {
-                if (str[i] == what) {
-                        return str + i;
-                }
-        }
-        return NULL;
+        return memchr(str, what, slen);
 }
 
 int uwsgi_contains_n(char *s1, size_t s1_len, char *s2, size_t s2_len) {
@@ -126,15 +119,7 @@ int uwsgi_starts_with(char *src, int slen, char *dst, int dlen) {
 
 // unsized check
 int uwsgi_startswith(char *src, char *what, int wlen) {
-
-        int i;
-
-        for (i = 0; i < wlen; i++) {
-                if (src[i] != what[i])
-                        return -1;
-        }
-
-        return 0;
+        return memcmp(what, src, wlen);
 }
 
 // concatenate strings
@@ -483,3 +468,22 @@ char ** uwsgi_split_quoted(char *what, size_t what_len, char *sep, size_t *rlen)
 
 	return ret;
 }
+
+char *uwsgi_get_last_char(char *what, char c) {
+	return strrchr(what, c);
+}
+
+// Note by Mathieu Dupuy: memrchr here is better, unfortunately it is not supported
+// everywhere. The only safe option looks checking for Linux :(
+char *uwsgi_get_last_charn(char *what, size_t len, char c) {
+#if defined(__linux__)
+	return memrchr(what, c, len);
+#else
+        while (len--) {
+                if (what[len] == c)
+                        return what + len;
+        }
+        return NULL;
+#endif
+}
+
diff --git a/core/subscription.c b/core/subscription.c
index 1b28d2e..3d18e3e 100644
--- a/core/subscription.c
+++ b/core/subscription.c
@@ -20,6 +20,17 @@
 
 extern struct uwsgi_server uwsgi;
 
+char *uwsgi_subscription_algo_name(void *ptr) {
+	struct uwsgi_string_list *usl = uwsgi.subscription_algos;
+	while(usl) {
+		if (usl->custom_ptr == ptr) {
+			return usl->value;
+		}
+		usl = usl->next;
+	}
+	return NULL;
+}
+
 #ifdef UWSGI_SSL
 static void uwsgi_subscription_sni_check(struct uwsgi_subscribe_slot *current_slot, struct uwsgi_subscribe_req *usr) {
 	if (usr->sni_key_len > 0 && usr->sni_crt_len > 0) {
@@ -72,6 +83,8 @@ int uwsgi_subscription_credentials_check(struct uwsgi_subscribe_slot *slot, stru
 }
 
 struct uwsgi_subscribe_slot *uwsgi_get_subscribe_slot(struct uwsgi_subscribe_slot **slot, char *key, uint16_t keylen) {
+	int retried = 0;
+retry:
 
 	if (keylen > 0xff)
 		return NULL;
@@ -125,136 +138,20 @@ struct uwsgi_subscribe_slot *uwsgi_get_subscribe_slot(struct uwsgi_subscribe_slo
 			break;
 	}
 
-	return NULL;
-}
-
-// least reference count
-static struct uwsgi_subscribe_node *uwsgi_subscription_algo_lrc(struct uwsgi_subscribe_slot *current_slot, struct uwsgi_subscribe_node *node) {
-	// if node is NULL we are in the second step (in lrc mode we do not use the first step)
-	if (node)
-		return NULL;
-
-	struct uwsgi_subscribe_node *choosen_node = NULL;
-	node = current_slot->nodes;
-	uint64_t min_rc = 0;
-	while (node) {
-		if (!node->death_mark) {
-			if (min_rc == 0 || node->reference < min_rc) {
-				min_rc = node->reference;
-				choosen_node = node;
-				if (min_rc == 0 && !(node->next && node->next->reference <= node->reference && node->next->last_requests <= node->last_requests))
-					break;
-			}
-		}
-		node = node->next;
-	}
-
-	if (choosen_node) {
-		choosen_node->reference++;
-	}
-
-	return choosen_node;
-}
-
-// weighted least reference count
-static struct uwsgi_subscribe_node *uwsgi_subscription_algo_wlrc(struct uwsgi_subscribe_slot *current_slot, struct uwsgi_subscribe_node *node) {
-	// if node is NULL we are in the second step (in wlrc mode we do not use the first step)
-	if (node)
-		return NULL;
-
-	struct uwsgi_subscribe_node *choosen_node = NULL;
-	node = current_slot->nodes;
-	double min_rc = 0;
-	while (node) {
-		if (!node->death_mark) {
-			// node->weight is always >= 1, we can safely use it as divider
-			double ref = (double) node->reference / (double) node->weight;
-			double next_node_ref = 0;
-			if (node->next)
-				next_node_ref = (double) node->next->reference / (double) node->next->weight;
-
-			if (min_rc == 0 || ref < min_rc) {
-				min_rc = ref;
-				choosen_node = node;
-				if (min_rc == 0 && !(node->next && next_node_ref <= ref && node->next->last_requests <= node->last_requests))
-					break;
-			}
-		}
-		node = node->next;
-	}
-
-	if (choosen_node) {
-		choosen_node->reference++;
-	}
-
-	return choosen_node;
-}
-
-// weighted round robin algo
-static struct uwsgi_subscribe_node *uwsgi_subscription_algo_wrr(struct uwsgi_subscribe_slot *current_slot, struct uwsgi_subscribe_node *node) {
-	// if node is NULL we are in the second step
-	if (node) {
-		if (node->death_mark == 0 && node->wrr > 0) {
-			node->wrr--;
-			node->reference++;
-			return node;
-		}
-		return NULL;
-	}
-
-	// no wrr > 0 node found, reset them
-	node = current_slot->nodes;
-	uint64_t min_weight = 0;
-	while (node) {
-		if (!node->death_mark) {
-			if (min_weight == 0 || node->weight < min_weight)
-				min_weight = node->weight;
-		}
-		node = node->next;
-	}
-
-	// now set wrr
-	node = current_slot->nodes;
-	struct uwsgi_subscribe_node *choosen_node = NULL;
-	while (node) {
-		if (!node->death_mark) {
-			node->wrr = node->weight / min_weight;
-			choosen_node = node;
+	// if we are here and in mountpoints mode, try the domain only variant
+	if (uwsgi.subscription_mountpoints && !retried) {
+		char *slash = memchr(key, '/', keylen);
+		if (slash) {
+			keylen = slash - key;
+			retried = 1;
+			goto retry;
 		}
-		node = node->next;
-	}
-	if (choosen_node) {
-		choosen_node->wrr--;
-		choosen_node->reference++;
-	}
-	return choosen_node;
-}
-
-void uwsgi_subscription_set_algo(char *algo) {
-
-	if (!algo)
-		goto wrr;
-
-	if (!strcmp(algo, "wrr")) {
-		uwsgi.subscription_algo = uwsgi_subscription_algo_wrr;
-		return;
-	}
-
-	if (!strcmp(algo, "lrc")) {
-		uwsgi.subscription_algo = uwsgi_subscription_algo_lrc;
-		return;
-	}
-
-	if (!strcmp(algo, "wlrc")) {
-		uwsgi.subscription_algo = uwsgi_subscription_algo_wlrc;
-		return;
 	}
 
-wrr:
-	uwsgi.subscription_algo = uwsgi_subscription_algo_wrr;
+	return NULL;
 }
 
-struct uwsgi_subscribe_node *uwsgi_get_subscribe_node(struct uwsgi_subscribe_slot **slot, char *key, uint16_t keylen) {
+struct uwsgi_subscribe_node *uwsgi_get_subscribe_node(struct uwsgi_subscribe_slot **slot, char *key, uint16_t keylen, struct uwsgi_subscription_client *client) {
 
 	if (keylen > 0xff)
 		return NULL;
@@ -287,14 +184,14 @@ struct uwsgi_subscribe_node *uwsgi_get_subscribe_node(struct uwsgi_subscribe_slo
 			continue;
 		}
 
-		struct uwsgi_subscribe_node *choosen_node = uwsgi.subscription_algo(current_slot, node);
+		struct uwsgi_subscribe_node *choosen_node = current_slot->algo(current_slot, node, client);
 		if (choosen_node)
 			return choosen_node;
 
 		node = node->next;
 	}
 
-	return uwsgi.subscription_algo(current_slot, node);
+	return current_slot->algo(current_slot, node, client);
 }
 
 struct uwsgi_subscribe_node *uwsgi_get_subscribe_node_by_name(struct uwsgi_subscribe_slot **slot, char *key, uint16_t keylen, char *val, uint16_t vallen) {
@@ -436,6 +333,10 @@ struct uwsgi_subscribe_node *uwsgi_add_subscribe_node(struct uwsgi_subscribe_slo
 				node->cores = usr->cores;
 				node->load = usr->load;
 				node->weight = usr->weight;
+				node->backup_level = usr->backup_level;
+				if (usr->proto_len > 0) {
+					node->proto = usr->proto[0];
+				}	
 				if (!node->weight)
 					node->weight = 1;
 				node->last_requests = 0;
@@ -468,6 +369,10 @@ struct uwsgi_subscribe_node *uwsgi_add_subscribe_node(struct uwsgi_subscribe_slo
 		node->cores = usr->cores;
 		node->load = usr->load;
 		node->weight = usr->weight;
+		node->backup_level = usr->backup_level;
+		if (usr->proto_len > 0) {
+			node->proto = usr->proto[0];
+		}
 		node->unix_check = usr->unix_check;
 		if (!node->weight)
 			node->weight = 1;
@@ -488,7 +393,7 @@ struct uwsgi_subscribe_node *uwsgi_add_subscribe_node(struct uwsgi_subscribe_slo
 		}
 		node->next = NULL;
 
-		uwsgi_log("[uwsgi-subscription for pid %d] %.*s => new node: %.*s\n", (int) uwsgi.mypid, usr->keylen, usr->key, usr->address_len, usr->address);
+		uwsgi_log("[uwsgi-subscription for pid %d] %.*s => new node: %.*s (weight: %d, backup: %d)\n", (int) uwsgi.mypid, usr->keylen, usr->key, usr->address_len, usr->address, usr->weight, usr->backup_level);
 		if (node->notify[0]) {
 			char buf[1024];
 			int ret = snprintf(buf, 1024, "[subscription ack] %.*s => new node: %.*s", usr->keylen, usr->key, usr->address_len, usr->address);
@@ -539,6 +444,10 @@ struct uwsgi_subscribe_node *uwsgi_add_subscribe_node(struct uwsgi_subscribe_slo
 		current_slot->nodes->cores = usr->cores;
 		current_slot->nodes->load = usr->load;
 		current_slot->nodes->weight = usr->weight;
+		current_slot->nodes->backup_level = usr->backup_level;
+		if (usr->proto_len > 0) {
+			current_slot->nodes->proto = usr->proto[0];
+		}
 		current_slot->nodes->unix_check = usr->unix_check;
 		if (!current_slot->nodes->weight)
 			current_slot->nodes->weight = 1;
@@ -570,13 +479,16 @@ struct uwsgi_subscribe_node *uwsgi_add_subscribe_node(struct uwsgi_subscribe_slo
 		current_slot->prev = old_slot;
 		current_slot->next = NULL;
 
+		current_slot->algo = usr->algo;
+		if (!current_slot->algo) current_slot->algo = uwsgi.subscription_algo;
+
 
 		if (!slot[hash_key] || current_slot->prev == NULL) {
 			slot[hash_key] = current_slot;
 		}
 
-		uwsgi_log("[uwsgi-subscription for pid %d] new pool: %.*s (hash key: %d)\n", (int) uwsgi.mypid, usr->keylen, usr->key, current_slot->hash);
-		uwsgi_log("[uwsgi-subscription for pid %d] %.*s => new node: %.*s\n", (int) uwsgi.mypid, usr->keylen, usr->key, usr->address_len, usr->address);
+		uwsgi_log("[uwsgi-subscription for pid %d] new pool: %.*s (hash key: %d, algo: %s)\n", (int) uwsgi.mypid, usr->keylen, usr->key, current_slot->hash, uwsgi_subscription_algo_name(current_slot->algo));
+		uwsgi_log("[uwsgi-subscription for pid %d] %.*s => new node: %.*s (weight: %d, backup: %d)\n", (int) uwsgi.mypid, usr->keylen, usr->key, usr->address_len, usr->address, usr->weight, usr->backup_level);
 
 		if (current_slot->nodes->notify[0]) {
 			char buf[1024];
@@ -669,6 +581,30 @@ static void send_subscription(int sfd, char *host, char *message, uint16_t messa
 		close(fd);
 }
 
+static int uwsgi_subscription_ub_fix(struct uwsgi_buffer *ub, uint8_t modifier1, uint8_t modifier2, uint8_t cmd, char *sign) {
+	#ifdef UWSGI_SSL
+        if (sign) {
+                if (uwsgi_buffer_append_keynum(ub, "unix", 4, (uwsgi_now() + (time_t) cmd)))
+                        return -1;
+
+                unsigned int signature_len = 0;
+                char *signature = uwsgi_rsa_sign(sign, ub->buf + 4, ub->pos - 4, &signature_len);
+                if (signature && signature_len > 0) {
+                        if (uwsgi_buffer_append_keyval(ub, "sign", 4, signature, signature_len)) {
+                                free(signature);
+				return -1;
+                        }
+                        free(signature);
+                }
+        }
+#endif
+
+        // add uwsgi header
+        if (uwsgi_buffer_set_uh(ub, 224, cmd)) return -1;
+
+	return 0;
+}
+
 static struct uwsgi_buffer *uwsgi_subscription_ub(char *key, size_t keysize, uint8_t modifier1, uint8_t modifier2, uint8_t cmd, char *socket_name, char *sign, char *sni_key, char *sni_crt, char *sni_ca) {
 	struct uwsgi_buffer *ub = uwsgi_buffer_new(4096);
 
@@ -679,10 +615,6 @@ static struct uwsgi_buffer *uwsgi_subscription_ub(char *key, size_t keysize, uin
 		goto end;
 	if (uwsgi_buffer_append_keyval(ub, "address", 7, socket_name, strlen(socket_name)))
 		goto end;
-
-	if (uwsgi.subscribe_with_modifier1) {
-		modifier1 = atoi(uwsgi.subscribe_with_modifier1);
-	}
 	if (uwsgi_buffer_append_keynum(ub, "modifier1", 9, modifier1))
 		goto end;
 	if (uwsgi_buffer_append_keynum(ub, "modifier2", 9, modifier2))
@@ -724,26 +656,7 @@ static struct uwsgi_buffer *uwsgi_subscription_ub(char *key, size_t keysize, uin
 			goto end;
 	}
 
-#ifdef UWSGI_SSL
-	if (sign) {
-		if (uwsgi_buffer_append_keynum(ub, "unix", 4, (uwsgi_now() + (time_t) cmd)))
-			goto end;
-
-		unsigned int signature_len = 0;
-		char *signature = uwsgi_rsa_sign(sign, ub->buf + 4, ub->pos - 4, &signature_len);
-		if (signature && signature_len > 0) {
-			if (uwsgi_buffer_append_keyval(ub, "sign", 4, signature, signature_len)) {
-				free(signature);
-				goto end;
-			}
-			free(signature);
-		}
-	}
-#endif
-
-	// add uwsgi header
-	if (uwsgi_buffer_set_uh(ub, 224, cmd))
-		goto end;
+	if (uwsgi_subscription_ub_fix(ub, modifier1, modifier2, cmd, sign)) goto end;
 
 	return ub;
 
@@ -865,13 +778,6 @@ int uwsgi_no_subscriptions(struct uwsgi_subscribe_slot **slot) {
 	return 1;
 }
 
-struct uwsgi_subscribe_slot **uwsgi_subscription_init_ht() {
-	if (!uwsgi.subscription_algo) {
-		uwsgi_subscription_set_algo(NULL);
-	}
-	return uwsgi_calloc(sizeof(struct uwsgi_subscription_slot *) * UMAX16);
-}
-
 void uwsgi_subscribe(char *subscription, uint8_t cmd) {
 
 	size_t subfile_size;
@@ -1018,8 +924,27 @@ void uwsgi_subscribe2(char *arg, uint8_t cmd) {
 	char *s2_sni_key = NULL;
 	char *s2_sni_crt = NULL;
 	char *s2_sni_ca = NULL;
-
-	if (uwsgi_kvlist_parse(arg, strlen(arg), ',', '=', "server", &s2_server, "key", &s2_key, "socket", &s2_socket, "addr", &s2_addr, "weight", &s2_weight, "modifier1", &s2_modifier1, "modifier2", &s2_modifier2, "sign", &s2_sign, "check", &s2_check, "sni_key", &s2_sni_key, "sni_crt", &s2_sni_crt, "sni_ca", &s2_sni_ca, NULL)) {
+	char *s2_proto = NULL;
+	char *s2_algo = NULL;
+	char *s2_backup = NULL;
+
+	if (uwsgi_kvlist_parse(arg, strlen(arg), ',', '=',
+		"server", &s2_server,
+		"key", &s2_key,
+		"socket", &s2_socket,
+		"addr", &s2_addr,
+		"weight", &s2_weight,
+		"modifier1", &s2_modifier1,
+		"modifier2", &s2_modifier2,
+		"sign", &s2_sign,
+		"check", &s2_check,
+		"sni_key", &s2_sni_key,
+		"sni_crt", &s2_sni_crt,
+		"sni_ca", &s2_sni_ca,
+		"proto", &s2_proto,
+		"algo", &s2_algo,
+		"backup", &s2_backup,
+		NULL)) {
 		return;
 	}
 
@@ -1031,8 +956,15 @@ void uwsgi_subscribe2(char *arg, uint8_t cmd) {
 			goto end;
 	}
 
+	int weight = 1;
+	int backup = 0;
+	if (uwsgi.auto_weight) weight = uwsgi.numproc * uwsgi.cores;
 	if (s2_weight) {
-		uwsgi.weight = atoi(s2_weight);
+		weight = atoi(s2_weight);
+	}
+
+	if (s2_backup) {
+		backup = atoi(s2_backup);
 	}
 
 	if (s2_socket) {
@@ -1056,7 +988,74 @@ void uwsgi_subscribe2(char *arg, uint8_t cmd) {
 		modifier2 = atoi(s2_modifier2);
 	}
 
-	uwsgi_send_subscription(s2_server, s2_key, strlen(s2_key), modifier1, modifier2, cmd, s2_addr, s2_sign, s2_sni_key, s2_sni_crt, s2_sni_ca);
+	if (s2_addr == NULL) {
+		// no socket... no subscription
+		if (!uwsgi.sockets) goto end;
+		s2_addr = uwsgi_str(uwsgi.sockets->name);
+	}
+
+        struct uwsgi_buffer *ub = uwsgi_buffer_new(uwsgi.page_size);
+        if (!ub) goto end;
+	// leave space for the header
+	ub->pos = 4;
+
+	if (uwsgi_buffer_append_keyval(ub, "key", 3, s2_key, strlen(s2_key)))
+                goto end;
+        if (uwsgi_buffer_append_keyval(ub, "address", 7, s2_addr, strlen(s2_addr)))
+                goto end;
+        if (uwsgi_buffer_append_keynum(ub, "modifier1", 9, modifier1))
+                goto end;
+        if (uwsgi_buffer_append_keynum(ub, "modifier2", 9, modifier2))
+                goto end;
+        if (uwsgi_buffer_append_keynum(ub, "cores", 5, uwsgi.numproc * uwsgi.cores))
+                goto end;
+        if (uwsgi_buffer_append_keynum(ub, "load", 4, uwsgi.shared->load))
+                goto end;
+        if (uwsgi_buffer_append_keynum(ub, "weight", 6, weight))
+        	goto end;
+        if (uwsgi_buffer_append_keynum(ub, "backup", 6, backup))
+        	goto end;
+
+        if (s2_sni_key) {
+                if (uwsgi_buffer_append_keyval(ub, "sni_key", 7, s2_sni_key, strlen(s2_sni_key)))
+                        goto end;
+        }
+
+        if (s2_sni_crt) {
+                if (uwsgi_buffer_append_keyval(ub, "sni_crt", 7, s2_sni_crt, strlen(s2_sni_crt)))
+                        goto end;
+        }
+
+        if (s2_sni_ca) {
+                if (uwsgi_buffer_append_keyval(ub, "sni_ca", 6, s2_sni_ca, strlen(s2_sni_ca)))
+                        goto end;
+        }
+
+	if (s2_proto) {
+                if (uwsgi_buffer_append_keyval(ub, "proto", 5, s2_proto, strlen(s2_proto)))
+                        goto end;
+	}
+
+	if (s2_algo) {
+                if (uwsgi_buffer_append_keyval(ub, "algo", 4, s2_algo, strlen(s2_algo)))
+                        goto end;
+	}
+
+        if (uwsgi.subscription_notify_socket) {
+                if (uwsgi_buffer_append_keyval(ub, "notify", 6, uwsgi.subscription_notify_socket, strlen(uwsgi.subscription_notify_socket)))
+                        goto end;
+        }
+        else if (uwsgi.notify_socket_fd > -1 && uwsgi.notify_socket) {
+                if (uwsgi_buffer_append_keyval(ub, "notify", 6, uwsgi.notify_socket, strlen(uwsgi.notify_socket)))
+                        goto end;
+        }
+
+        if (uwsgi_subscription_ub_fix(ub, modifier1, modifier2, cmd, s2_sign)) goto end;
+
+        send_subscription(-1, s2_server, ub->buf, ub->pos);
+
+        uwsgi_buffer_destroy(ub);
+
 end:
 	if (s2_server)
 		free(s2_server);
@@ -1082,6 +1081,12 @@ end:
 		free(s2_sni_key);
 	if (s2_sni_ca)
 		free(s2_sni_ca);
+	if (s2_proto)
+		free(s2_proto);
+	if (s2_algo)
+		free(s2_algo);
+	if (s2_backup)
+		free(s2_backup);
 }
 
 void uwsgi_subscribe_all(uint8_t cmd, int verbose) {
@@ -1109,3 +1114,241 @@ void uwsgi_subscribe_all(uint8_t cmd, int verbose) {
 	}
 
 }
+
+// iphash
+static struct uwsgi_subscribe_node *uwsgi_subscription_algo_iphash(struct uwsgi_subscribe_slot *current_slot, struct uwsgi_subscribe_node *node, struct uwsgi_subscription_client *client) {
+        // if node is NULL we are in the second step (in lrc mode we do not use the first step)
+        if (node)
+                return NULL;
+
+	// iphash does not support requests without client data
+	if (!client) return NULL;
+	if (!client->sockaddr) return NULL;
+	uint64_t count = 0;
+	// first step is counting the number of nodes
+	node = current_slot->nodes;
+	while(node) {
+		if (!node->death_mark) count++;
+		node = node->next;
+	}
+	if (count == 0) return NULL;
+
+	uint64_t hash = 0;
+
+	//hash the ip
+	if (client->sockaddr->sa.sa_family == AF_INET) {
+		hash = client->sockaddr->sa_in.sin_addr.s_addr % count;
+	}
+#ifdef AF_INET6
+	else if (client->sockaddr->sa.sa_family == AF_INET6) {
+		hash = djb33x_hash((char *)client->sockaddr->sa_in6.sin6_addr.s6_addr, 16) % count;
+	}
+#endif
+		
+	// now re-iterate until count matches;
+	count = 0;
+        struct uwsgi_subscribe_node *choosen_node = NULL;
+        node = current_slot->nodes;
+        while (node) {
+                if (!node->death_mark) {
+			if (count == hash) {
+				choosen_node = node;
+				break;
+			}
+			count++;
+                }
+                node = node->next;
+        }
+
+        if (choosen_node) {
+                choosen_node->reference++;
+        }
+
+        return choosen_node;
+}
+
+// least reference count
+static struct uwsgi_subscribe_node *uwsgi_subscription_algo_lrc(struct uwsgi_subscribe_slot *current_slot, struct uwsgi_subscribe_node *node, struct uwsgi_subscription_client *client) {
+	uint64_t backup_level = 0;
+        uint64_t has_backup = 0;
+
+        // if node is NULL we are in the second step (in lrc mode we do not use the first step)
+        if (node)
+                return NULL;
+
+        struct uwsgi_subscribe_node *choosen_node = NULL;
+retry:
+        node = current_slot->nodes;
+        uint64_t min_rc = 0;
+        while (node) {
+                if (!node->death_mark) {
+			if (node->backup_level == backup_level) {
+                        	if (min_rc == 0 || node->reference < min_rc) {
+                                	min_rc = node->reference;
+                                	choosen_node = node;
+                                	if (min_rc == 0 && !(node->next && node->next->reference <= node->reference && node->next->last_requests <= node->last_requests))
+                                        	break;
+                        	}
+			}
+			else if (node->backup_level > backup_level && (!has_backup || has_backup > node->backup_level)) {
+                                has_backup = node->backup_level;
+                        }
+                }
+                node = node->next;
+        }
+
+        if (choosen_node) {
+                choosen_node->reference++;
+        }
+	else if (has_backup) {
+                backup_level = has_backup;
+                goto retry;
+        }
+
+        return choosen_node;
+}
+
+// weighted least reference count
+static struct uwsgi_subscribe_node *uwsgi_subscription_algo_wlrc(struct uwsgi_subscribe_slot *current_slot, struct uwsgi_subscribe_node *node, struct uwsgi_subscription_client *client) {
+	uint64_t backup_level = 0;
+        uint64_t has_backup = 0;
+
+        // if node is NULL we are in the second step (in wlrc mode we do not use the first step)
+        if (node)
+                return NULL;
+
+        struct uwsgi_subscribe_node *choosen_node = NULL;
+retry:
+        node = current_slot->nodes;
+	has_backup = 0;
+        double min_rc = 0;
+        while (node) {
+                if (!node->death_mark) {
+			if (node->backup_level == backup_level) {
+                        	// node->weight is always >= 1, we can safely use it as divider
+                        	double ref = (double) node->reference / (double) node->weight;
+                        	double next_node_ref = 0;
+                        	if (node->next)
+                                	next_node_ref = (double) node->next->reference / (double) node->next->weight;
+
+                        	if (min_rc == 0 || ref < min_rc) {
+                                	min_rc = ref;
+                                	choosen_node = node;
+                                	if (min_rc == 0 && !(node->next && next_node_ref <= ref && node->next->last_requests <= node->last_requests))
+                                	        break;
+                        	}
+			}
+			else if (node->backup_level > backup_level && (!has_backup || has_backup > node->backup_level)) {
+                                has_backup = node->backup_level;
+                        }
+                }
+                node = node->next;
+        }
+
+        if (choosen_node) {
+                choosen_node->reference++;
+        }
+	else if (has_backup) {
+                backup_level = has_backup;
+                goto retry;
+        }
+
+        return choosen_node;
+}
+
+// weighted round robin algo (with backup support)
+static struct uwsgi_subscribe_node *uwsgi_subscription_algo_wrr(struct uwsgi_subscribe_slot *current_slot, struct uwsgi_subscribe_node *node, struct uwsgi_subscription_client *client) {
+	uint64_t backup_level = 0;
+	uint64_t has_backup = 0;
+        // if node is NULL we are in the second step
+        if (node) {
+                if (node->death_mark == 0 && node->wrr > 0) {
+                        node->wrr--;
+                        node->reference++;
+                        return node;
+                }
+                return NULL;
+        }
+
+        // no wrr > 0 node found, reset them
+        node = current_slot->nodes;
+        uint64_t min_weight = 0;
+        while (node) {
+                if (!node->death_mark) {
+                        if (min_weight == 0 || node->weight < min_weight)
+                                min_weight = node->weight;
+                }
+                node = node->next;
+        }
+
+        // now set wrr
+retry:
+        node = current_slot->nodes;
+	has_backup = 0;
+        struct uwsgi_subscribe_node *choosen_node = NULL;
+        while (node) {
+                if (!node->death_mark) {
+			if (node->backup_level == backup_level) {
+                        	node->wrr = node->weight / min_weight;
+                        	choosen_node = node;
+                	}
+			else if (node->backup_level > backup_level && (!has_backup || has_backup > node->backup_level)) {
+				has_backup = node->backup_level;
+			}
+		}
+                node = node->next;
+        }
+        if (choosen_node) {
+                choosen_node->wrr--;
+                choosen_node->reference++;
+        }
+	else if (has_backup) {
+		backup_level = has_backup;
+		goto retry;
+	}
+        return choosen_node;
+}
+
+void uwsgi_subscription_init_algos() {
+
+	uwsgi_register_subscription_algo("wrr", uwsgi_subscription_algo_wrr);
+	uwsgi_register_subscription_algo("lrc", uwsgi_subscription_algo_lrc);
+	uwsgi_register_subscription_algo("wlrc", uwsgi_subscription_algo_wlrc);
+	uwsgi_register_subscription_algo("iphash", uwsgi_subscription_algo_iphash);
+}
+
+void uwsgi_subscription_set_algo(char *algo) {
+	if (!uwsgi.subscription_algos) {
+		uwsgi_subscription_init_algos();
+	}
+	if (!algo)
+                goto wrr;
+	uwsgi.subscription_algo = uwsgi_subscription_algo_get(algo, strlen(algo));
+	if (uwsgi.subscription_algo) return ;
+
+wrr:
+        uwsgi.subscription_algo = uwsgi_subscription_algo_wrr;
+}
+
+// we are lazy for subscription algos, we initialize them only if needed
+struct uwsgi_subscribe_slot **uwsgi_subscription_init_ht() {
+        if (!uwsgi.subscription_algo) {
+                uwsgi_subscription_set_algo(NULL);
+        }
+        return uwsgi_calloc(sizeof(struct uwsgi_subscription_slot *) * UMAX16);
+}
+
+struct uwsgi_subscribe_node *(*uwsgi_subscription_algo_get(char *name , size_t len))(struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *) {
+	struct uwsgi_string_list *usl = NULL;
+	uwsgi_foreach(usl, uwsgi.subscription_algos) {
+		if (!uwsgi_strncmp(usl->value, usl->len, name, len)) {
+			return (struct uwsgi_subscribe_node *(*)(struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *)) usl->custom_ptr;
+		}
+	}
+	return NULL;
+}
+
+void uwsgi_register_subscription_algo(char *name, struct uwsgi_subscribe_node *(*func)(struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *)) {
+	struct uwsgi_string_list *usl = uwsgi_string_new_list(&uwsgi.subscription_algos, name);	
+	usl->custom_ptr = func;
+}
diff --git a/core/utils.c b/core/utils.c
index 416370a..c19b7c5 100644
--- a/core/utils.c
+++ b/core/utils.c
@@ -42,9 +42,9 @@ int check_hex(char *str, int len) {
 }
 
 // increase worker harakiri
-void inc_harakiri(int sec) {
+void inc_harakiri(struct wsgi_request *wsgi_req, int sec) {
 	if (uwsgi.master_process) {
-		uwsgi.workers[uwsgi.mywid].harakiri += sec;
+		uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri += sec;
 	}
 	else {
 		alarm(uwsgi.harakiri_options.workers + sec);
@@ -52,12 +52,13 @@ void inc_harakiri(int sec) {
 }
 
 // set worker harakiri
-void set_harakiri(int sec) {
+void set_harakiri(struct wsgi_request *wsgi_req, int sec) {
+	if (!wsgi_req) return;
 	if (sec == 0) {
-		uwsgi.workers[uwsgi.mywid].harakiri = 0;
+		uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri = 0;
 	}
 	else {
-		uwsgi.workers[uwsgi.mywid].harakiri = uwsgi_now() + sec;
+		uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri = uwsgi_now() + sec;
 	}
 	if (!uwsgi.master_process) {
 		alarm(sec);
@@ -65,7 +66,7 @@ void set_harakiri(int sec) {
 }
 
 // set user harakiri
-void set_user_harakiri(int sec) {
+void set_user_harakiri(struct wsgi_request *wsgi_req, int sec) {
 	if (!uwsgi.master_process) {
 		uwsgi_log("!!! unable to set user harakiri without the master process !!!\n");
 		return;
@@ -79,8 +80,8 @@ void set_user_harakiri(int sec) {
 			struct uwsgi_spooler *uspool = uwsgi.i_am_a_spooler;
 			uspool->user_harakiri = 0;
 		}
-		else {
-			uwsgi.workers[uwsgi.mywid].user_harakiri = 0;
+		else if (wsgi_req) {
+			uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].user_harakiri = 0;
 		}
 	}
 	else {
@@ -91,8 +92,8 @@ void set_user_harakiri(int sec) {
 			struct uwsgi_spooler *uspool = uwsgi.i_am_a_spooler;
 			uspool->user_harakiri = uwsgi_now() + sec;
 		}
-		else {
-			uwsgi.workers[uwsgi.mywid].user_harakiri = uwsgi_now() + sec;
+		else if (wsgi_req) {
+			uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].user_harakiri = uwsgi_now() + sec;
 		}
 	}
 }
@@ -700,20 +701,20 @@ void uwsgi_as_root() {
 	}
 
 	uwsgi_foreach(usl, uwsgi.wait_for_fs) {
-                if (uwsgi_wait_for_fs(usl->value, 0)) exit(1);
-        }
+		if (uwsgi_wait_for_fs(usl->value, 0)) exit(1);
+	}
 
-        uwsgi_foreach(usl, uwsgi.wait_for_file) {
-                if (uwsgi_wait_for_fs(usl->value, 1)) exit(1);
-        }
+	uwsgi_foreach(usl, uwsgi.wait_for_file) {
+		if (uwsgi_wait_for_fs(usl->value, 1)) exit(1);
+	}
 
-        uwsgi_foreach(usl, uwsgi.wait_for_dir) {
-                if (uwsgi_wait_for_fs(usl->value, 2)) exit(1);
-        }
+	uwsgi_foreach(usl, uwsgi.wait_for_dir) {
+		if (uwsgi_wait_for_fs(usl->value, 2)) exit(1);
+	}
 
-        uwsgi_foreach(usl, uwsgi.wait_for_mountpoint) {
-                if (uwsgi_wait_for_mountpoint(usl->value)) exit(1);
-        }
+	uwsgi_foreach(usl, uwsgi.wait_for_mountpoint) {
+		if (uwsgi_wait_for_mountpoint(usl->value)) exit(1);
+	}
 
 	uwsgi_hooks_run(uwsgi.hook_as_root, "as root", 1);
 
@@ -1037,7 +1038,7 @@ void uwsgi_destroy_request(struct wsgi_request *wsgi_req) {
 
 	// reset for avoiding following requests to fail on non-uwsgi protocols
 	// thanks Marko Tiikkaja for catching it
-	wsgi_req->uh->pktsize = 0;
+	wsgi_req->uh->_pktsize = 0;
 
 	// some plugins expected async_id to be defined before setup
         int tmp_id = wsgi_req->async_id;
@@ -1121,13 +1122,13 @@ void uwsgi_close_request(struct wsgi_request *wsgi_req) {
 	}
 
 	// leave harakiri mode
-	if (uwsgi.workers[uwsgi.mywid].harakiri > 0) {
-		set_harakiri(0);
+	if (uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri > 0) {
+		set_harakiri(wsgi_req, 0);
 	}
 
 	// leave user harakiri mode
-	if (uwsgi.workers[uwsgi.mywid].user_harakiri > 0) {
-		set_user_harakiri(0);
+	if (uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].user_harakiri > 0) {
+		set_user_harakiri(wsgi_req, 0);
 	}
 
 	if (!wsgi_req->do_not_account) {
@@ -1185,7 +1186,7 @@ void uwsgi_close_request(struct wsgi_request *wsgi_req) {
 
 
 	// reset request
-	wsgi_req->uh->pktsize = 0;
+	wsgi_req->uh->_pktsize = 0;
 	tmp_id = wsgi_req->async_id;
 	memset(wsgi_req, 0, sizeof(struct wsgi_request));
 	// some plugins expected async_id to be defined before setup
@@ -1193,7 +1194,7 @@ void uwsgi_close_request(struct wsgi_request *wsgi_req) {
 	// yes, this is pretty useless but we cannot ensure all of the plugin have the same behaviour
 	uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 0;
 
-	if (uwsgi.max_requests > 0 && uwsgi.workers[uwsgi.mywid].delta_requests >= uwsgi.max_requests
+	if (uwsgi.max_requests > 0 && uwsgi.workers[uwsgi.mywid].delta_requests >= (uwsgi.max_requests + ((uwsgi.mywid-1) * uwsgi.max_requests_delta))
 	    && (end_of_request - (uwsgi.workers[uwsgi.mywid].last_spawn * 1000000) >= uwsgi.min_worker_lifetime * 1000000)) {
 		goodbye_cruel_world();
 	}
@@ -1384,7 +1385,7 @@ int wsgi_req_async_recv(struct wsgi_request *wsgi_req) {
 
 	// enter harakiri mode
 	if (uwsgi.harakiri_options.workers > 0) {
-		set_harakiri(uwsgi.harakiri_options.workers);
+		set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
 	}
 
 	return 0;
@@ -1416,7 +1417,7 @@ int wsgi_req_recv(int queue, struct wsgi_request *wsgi_req) {
 
 	// enter harakiri mode
 	if (uwsgi.harakiri_options.workers > 0) {
-		set_harakiri(uwsgi.harakiri_options.workers);
+		set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
 	}
 
 #ifdef UWSGI_ROUTING
@@ -1537,7 +1538,7 @@ int wsgi_req_accept(int queue, struct wsgi_request *wsgi_req) {
 
 		thunder_unlock;
 
-		uwsgi_receive_signal(interesting_fd, "worker", uwsgi.mywid);
+		uwsgi_receive_signal(wsgi_req, interesting_fd, "worker", uwsgi.mywid);
 
 		if (uwsgi.threads > 1)
 			pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, &ret);
@@ -1788,9 +1789,15 @@ void *uwsgi_malloc(size_t size) {
 }
 
 void *uwsgi_calloc(size_t size) {
-
-	char *ptr = uwsgi_malloc(size);
-	memset(ptr, 0, size);
+	// thanks Mathieu Dupuy for pointing out that calloc is faster
+	// than malloc + memset
+	char *ptr = calloc(1, size);
+	if (ptr == NULL) {
+		uwsgi_error("calloc()");
+		uwsgi_log("!!! tried memory allocation of %llu bytes !!!\n", (unsigned long long) size);
+		uwsgi_backtrace(uwsgi.backtrace_depth);
+		exit(1);
+	}
 	return ptr;
 }
 
@@ -1832,7 +1839,7 @@ char *magic_sub(char *buffer, size_t len, size_t * size, char *magic_table[]) {
 	for (i = 0; i < len; i++) {
 		if (buffer[i] == '%' && (i + 1) < len && magic_table[(unsigned char) buffer[i + 1]]) {
 			old_magic_buf = magic_buf;
-			magic_buf = uwsgi_concat3n(old_magic_buf, magic_len, magic_table[(unsigned char) buffer[i + 1]], strlen(magic_table[(unsigned char) buffer[i + 1]]), buffer + i + 2, len - i);
+			magic_buf = uwsgi_concat3n(old_magic_buf, magic_len, magic_table[(unsigned char) buffer[i + 1]], strlen(magic_table[(unsigned char) buffer[i + 1]]), buffer + i + 2, len - i - 2);
 			free(old_magic_buf);
 			magic_len += strlen(magic_table[(unsigned char) buffer[i + 1]]);
 			magic_ptr = magic_buf + magic_len;
@@ -1862,24 +1869,6 @@ void init_magic_table(char *magic_table[]) {
 	magic_table['('] = "%(";
 }
 
-char *uwsgi_get_last_char(char *what, char c) {
-	size_t len = strlen(what);
-	while (len--) {
-		if (what[len] == c)
-			return what + len;
-	}
-	return NULL;
-}
-
-char *uwsgi_get_last_charn(char *what, size_t len, char c) {
-	while (len--) {
-		if (what[len] == c)
-			return what + len;
-	}
-	return NULL;
-}
-
-
 char *uwsgi_num2str(int num) {
 
 	char *str = uwsgi_malloc(11);
@@ -1911,13 +1900,7 @@ int uwsgi_long2str2n(unsigned long long num, char *ptr, int size) {
 }
 
 int is_unix(char *socket_name, int len) {
-	int i;
-	for (i = 0; i < len; i++) {
-		if (socket_name[i] == ':')
-			return 0;
-	}
-
-	return 1;
+	return !memchr(socket_name, ':', len);
 }
 
 int is_a_number(char *what) {
@@ -2231,6 +2214,12 @@ void *uwsgi_malloc_shared(size_t size) {
 
 void *uwsgi_calloc_shared(size_t size) {
 	void *ptr = uwsgi_malloc_shared(size);
+	// NOTE by Mathieu Dupuy:
+	// OSes guarantee mmap MAP_ANON memory area to be zero-filled (see man pages)
+
+	// we should trust it, but history has taught us it is better to be paranoid.
+	// Lucky enough this function is called ony in startup phases, so performance
+	// tips/tricks are irrelevant (So, le'ts call memset...)
 	memset(ptr, 0, size);
 	return ptr;
 }
@@ -3124,6 +3113,8 @@ pid_t uwsgi_fork(char *name) {
 #if defined(__linux__) || defined(__sun__)
 		int i;
 		for (i = 0; i < uwsgi.argc; i++) {
+			// stop fixing original argv if the new one is bigger
+			if (!uwsgi.orig_argv[i]) break;
 			strcpy(uwsgi.orig_argv[i], uwsgi.argv[i]);
 		}
 #endif
@@ -3415,7 +3406,7 @@ struct uwsgi_app *uwsgi_add_app(int id, uint8_t modifier1, char *mountpoint, int
 	}
 
 	if (!uwsgi.no_default_app) {
-		if ((mountpoint_len == 0 || (mountpoint_len == 1 && mountpoint[0] == '/')) && uwsgi.default_app == -1) {
+		if ((mountpoint_len == 0 || (mountpoint_len = -1 && mountpoint[0] == '/')) && uwsgi.default_app == -1) {
 			uwsgi.default_app = id;
 		}
 	}
@@ -4479,7 +4470,6 @@ mode_t uwsgi_mode_t(char *value, int *error) {
 	return mode;
 }
 
-
 int uwsgi_wait_for_mountpoint(char *mountpoint) {
         if (!uwsgi.wait_for_fs_timeout) {
                 uwsgi.wait_for_fs_timeout = 60;
@@ -4491,19 +4481,19 @@ int uwsgi_wait_for_mountpoint(char *mountpoint) {
                         uwsgi_log("%s unavailable after %d seconds\n", mountpoint, counter);
                         return -1;
                 }
-                struct stat st0;
-                struct stat st1;
-                if (stat(mountpoint, &st0)) goto retry;
-                if (!S_ISDIR(st0.st_mode)) goto retry;
-                char *relative = uwsgi_concat2(mountpoint, "/../");
-                if (stat(relative, &st1)) {
-                        free(relative);
-                        goto retry;
-                }
-                free(relative);
-                // useless :P
+		struct stat st0;
+		struct stat st1;
+		if (stat(mountpoint, &st0)) goto retry;
+		if (!S_ISDIR(st0.st_mode)) goto retry;
+		char *relative = uwsgi_concat2(mountpoint, "/../");
+		if (stat(relative, &st1)) {
+			free(relative);
+			goto retry;
+		}
+		free(relative);
+		// useless :P
                 if (!S_ISDIR(st1.st_mode)) goto retry;
-                if (st0.st_dev == st1.st_dev) goto retry;
+		if (st0.st_dev == st1.st_dev) goto retry;
                 uwsgi_log_verbose("%s mounted\n", mountpoint);
                 return 0;
 retry:
@@ -4514,24 +4504,56 @@ retry:
 
 // type -> 1 file, 2 dir, 0 both
 int uwsgi_wait_for_fs(char *filename, int type) {
-        if (!uwsgi.wait_for_fs_timeout) {
-                uwsgi.wait_for_fs_timeout = 60;
+	if (!uwsgi.wait_for_fs_timeout) {
+        	uwsgi.wait_for_fs_timeout = 60;
         }
         uwsgi_log("waiting for %s (max %d seconds) ...\n", filename, uwsgi.wait_for_fs_timeout);
         int counter = 0;
         for (;;) {
-                if (counter > uwsgi.wait_for_fs_timeout) {
-                        uwsgi_log("%s unavailable after %d seconds\n", filename, counter);
-                        return -1;
+        	if (counter > uwsgi.wait_for_fs_timeout) {
+                	uwsgi_log("%s unavailable after %d seconds\n", filename, counter);
+			return -1;
                 }
-                struct stat st;
-                if (stat(filename, &st)) goto retry;
-                if (type == 1 && !S_ISREG(st.st_mode)) goto retry;
-                if (type == 2 && !S_ISDIR(st.st_mode)) goto retry;
+		struct stat st;
+		if (stat(filename, &st)) goto retry;
+		if (type == 1 && !S_ISREG(st.st_mode)) goto retry;
+		if (type == 2 && !S_ISDIR(st.st_mode)) goto retry;
                 uwsgi_log_verbose("%s found\n", filename);
-                return 0;
+		return 0;
 retry:
                 sleep(1);
                 counter++;
+	}
+}
+
+#ifndef _GNU_SOURCE
+int uwsgi_versionsort(const struct dirent **da, const struct dirent **db) {
+
+        const char *a = (*da)->d_name;
+        const char *b = (*db)->d_name;
+
+        long la, lb;
+        char *endptr;
+
+        // Check if a and b are valid numbers.
+        la = strtol(a, &endptr, 10);
+        if (strcmp(endptr, "\0") || endptr == a) {
+            a = NULL;
+        }
+
+        lb = strtol(b, &endptr, 10);
+        if (strcmp(endptr, "\0") || endptr == b) {
+            b = NULL;
+        }
+
+        if (a && b) {
+            return (la < lb ? -1 : la > lb);
+        } else if (a) {
+            return -1;
+        } else if (b) {
+            return 1;
+        } else {
+            return strcmp((*da)->d_name, (*db)->d_name);
         }
 }
+#endif
diff --git a/core/uwsgi.c b/core/uwsgi.c
index 79a7533..56ce724 100644
--- a/core/uwsgi.c
+++ b/core/uwsgi.c
@@ -47,6 +47,8 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"http-socket-modifier1", required_argument, 0, "force the specified modifier1 when using HTTP protocol", uwsgi_opt_set_64bit, &uwsgi.http_modifier1, 0},
 	{"http-socket-modifier2", required_argument, 0, "force the specified modifier2 when using HTTP protocol", uwsgi_opt_set_64bit, &uwsgi.http_modifier2, 0},
 
+	{"http11-socket", required_argument, 0, "bind to the specified UNIX/TCP socket using HTTP 1.1 (Keep-Alive) protocol", uwsgi_opt_add_socket, "http11", 0},
+
 #ifdef UWSGI_SSL
 	{"https-socket", required_argument, 0, "bind to the specified UNIX/TCP socket using HTTPS protocol", uwsgi_opt_add_ssl_socket, "https", 0},
 	{"https-socket-modifier1", required_argument, 0, "force the specified modifier1 when using HTTPS protocol", uwsgi_opt_set_64bit, &uwsgi.https_modifier1, 0},
@@ -172,7 +174,7 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"listen", required_argument, 'l', "set the socket listen queue size", uwsgi_opt_set_int, &uwsgi.listen_queue, 0},
 	{"max-vars", required_argument, 'v', "set the amount of internal iovec/vars structures", uwsgi_opt_max_vars, NULL, 0},
 	{"max-apps", required_argument, 0, "set the maximum number of per-worker applications", uwsgi_opt_set_int, &uwsgi.max_apps, 0},
-	{"buffer-size", required_argument, 'b', "set internal buffer size", uwsgi_opt_set_16bit, &uwsgi.buffer_size, 0},
+	{"buffer-size", required_argument, 'b', "set internal buffer size", uwsgi_opt_set_64bit, &uwsgi.buffer_size, 0},
 	{"memory-report", no_argument, 'm', "enable memory report", uwsgi_opt_true, &uwsgi.logging_options.memory_report, 0},
 	{"profiler", required_argument, 0, "enable the specified profiler", uwsgi_opt_set_str, &uwsgi.profiler, 0},
 	{"cgi-mode", no_argument, 'c', "force CGI-mode for plugins supporting it", uwsgi_opt_true, &uwsgi.cgi_mode, 0},
@@ -228,11 +230,19 @@ static struct uwsgi_option uwsgi_base_options[] = {
 #if defined(__linux__) && !defined(OBSOLETE_LINUX_KERNEL)
 	{"emperor-use-clone", required_argument, 0, "use clone() instead of fork() passing the specified unshare() flags", uwsgi_opt_set_unshare, &uwsgi.emperor_clone, 0},
 #endif
+	{"emperor-use-fork-server", required_argument, 0, "connect to the specified fork server instead of using plain fork() for new vassals", uwsgi_opt_set_str, &uwsgi.emperor_use_fork_server, 0},
+	{"vassal-fork-base", required_argument, 0, "use plain fork() for the specified vassal (instead of a fork-server)", uwsgi_opt_add_string_list, &uwsgi.vassal_fork_base, 0},
+	{"emperor-subreaper", no_argument, 0, "force the Emperor to be a sub-reaper (if supported)", uwsgi_opt_true, &uwsgi.emperor_subreaper, 0},
 #ifdef UWSGI_CAP
 	{"emperor-cap", required_argument, 0, "set vassals capability", uwsgi_opt_set_emperor_cap, NULL, 0},
 	{"vassals-cap", required_argument, 0, "set vassals capability", uwsgi_opt_set_emperor_cap, NULL, 0},
 	{"vassal-cap", required_argument, 0, "set vassals capability", uwsgi_opt_set_emperor_cap, NULL, 0},
 #endif
+	{"emperor-collect-attribute", required_argument, 0, "collect the specified vassal attribute from imperial monitors", uwsgi_opt_add_string_list, &uwsgi.emperor_collect_attributes, 0},
+	{"emperor-collect-attr", required_argument, 0, "collect the specified vassal attribute from imperial monitors", uwsgi_opt_add_string_list, &uwsgi.emperor_collect_attributes, 0},
+	{"emperor-fork-server-attr", required_argument, 0, "set teh vassal's attribute to get when checking for fork-server", uwsgi_opt_set_str, &uwsgi.emperor_fork_server_attr, 0},
+	{"emperor-wrapper-attr", required_argument, 0, "set the vassal's attribute to get when checking for fork-wrapper", uwsgi_opt_set_str, &uwsgi.emperor_wrapper_attr, 0},
+	{"emperor-chdir-attr", required_argument, 0, "set the vassal's attribute to get when checking for chdir", uwsgi_opt_set_str, &uwsgi.emperor_chdir_attr, 0},
 	{"imperial-monitor-list", no_argument, 0, "list enabled imperial monitors", uwsgi_opt_true, &uwsgi.imperial_monitor_list, 0},
 	{"imperial-monitors-list", no_argument, 0, "list enabled imperial monitors", uwsgi_opt_true, &uwsgi.imperial_monitor_list, 0},
 	{"vassals-inherit", required_argument, 0, "add config templates to vassals config (uses --inherit)", uwsgi_opt_add_string_list, &uwsgi.vassals_templates, 0},
@@ -248,6 +258,8 @@ static struct uwsgi_option uwsgi_base_options[] = {
 
 	{"heartbeat", required_argument, 0, "announce healthiness to the emperor", uwsgi_opt_set_int, &uwsgi.heartbeat, 0},
 
+	{"zeus", required_argument, 0, "enable Zeus mode", uwsgi_opt_set_str, &uwsgi.zeus, 0},
+
 	{"reload-mercy", required_argument, 0, "set the maximum time (in seconds) we wait for workers and other processes to die during reload/shutdown", uwsgi_opt_set_int, &uwsgi.reload_mercy, 0},
 	{"worker-reload-mercy", required_argument, 0, "set the maximum time (in seconds) a worker can take to reload/shutdown (default is 60)", uwsgi_opt_set_int, &uwsgi.worker_reload_mercy, 0},
 	{"mule-reload-mercy", required_argument, 0, "set the maximum time (in seconds) a mule can take to reload/shutdown (default is 60)", uwsgi_opt_set_int, &uwsgi.mule_reload_mercy, 0},
@@ -262,6 +274,7 @@ static struct uwsgi_option uwsgi_base_options[] = {
 
 	{"reaper", no_argument, 'r', "call waitpid(-1,...) after each request to get rid of zombies", uwsgi_opt_true, &uwsgi.reaper, 0},
 	{"max-requests", required_argument, 'R', "reload workers after the specified amount of managed requests", uwsgi_opt_set_64bit, &uwsgi.max_requests, 0},
+	{"max-requests-delta", required_argument, 0, "add (worker_id * delta) to the max_requests value of each worker", uwsgi_opt_set_64bit, &uwsgi.max_requests_delta, 0},
 	{"min-worker-lifetime", required_argument, 0, "number of seconds worker must run before being reloaded (default is 60)", uwsgi_opt_set_64bit, &uwsgi.min_worker_lifetime, 0},
 	{"max-worker-lifetime", required_argument, 0, "reload workers after the specified amount of seconds (default is disabled)", uwsgi_opt_set_64bit, &uwsgi.max_worker_lifetime, 0},
 
@@ -363,6 +376,8 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"setns-skip", required_argument, 0, "skip the specified entry when sending setns file descriptors", uwsgi_opt_add_string_list, &uwsgi.setns_socket_skip, 0},
 	{"setns", required_argument, 0, "join a namespace created by an external uWSGI instance", uwsgi_opt_set_str, &uwsgi.setns, 0},
 	{"setns-preopen", no_argument, 0, "open /proc/self/ns as soon as possible and cache fds", uwsgi_opt_true, &uwsgi.setns_preopen, 0},
+	{"fork-socket", required_argument, 0, "suspend the execution after early initialization and fork() at every unix socket connection", uwsgi_opt_set_str, &uwsgi.fork_socket, 0},
+	{"fork-server", required_argument, 0, "suspend the execution after early initialization and fork() at every unix socket connection", uwsgi_opt_set_str, &uwsgi.fork_socket, 0},
 #endif
 	{"jailed", no_argument, 0, "mark the instance as jailed (force the execution of post_jail hooks)", uwsgi_opt_true, &uwsgi.jailed, 0},
 #if defined(__FreeBSD__) || defined(__GNU_kFreeBSD__)
@@ -393,7 +408,6 @@ static struct uwsgi_option uwsgi_base_options[] = {
         {"hook-as-user-atexit", required_argument, 0, "run the specified hook before app exit and reload", uwsgi_opt_add_string_list, &uwsgi.hook_as_user_atexit, 0},
         {"hook-pre-app", required_argument, 0, "run the specified hook before app loading", uwsgi_opt_add_string_list, &uwsgi.hook_pre_app, 0},
         {"hook-post-app", required_argument, 0, "run the specified hook after app loading", uwsgi_opt_add_string_list, &uwsgi.hook_post_app, 0},
-	{"hook-post-fork", required_argument, 0, "run the specified hook after each fork", uwsgi_opt_add_string_list, &uwsgi.hook_post_fork, 0},
         {"hook-accepting", required_argument, 0, "run the specified hook after each worker enter the accepting phase", uwsgi_opt_add_string_list, &uwsgi.hook_accepting, 0},
         {"hook-accepting1", required_argument, 0, "run the specified hook after the first worker enters the accepting phase", uwsgi_opt_add_string_list, &uwsgi.hook_accepting1, 0},
         {"hook-accepting-once", required_argument, 0, "run the specified hook after each worker enter the accepting phase (once per-instance)", uwsgi_opt_add_string_list, &uwsgi.hook_accepting_once, 0},
@@ -411,6 +425,14 @@ static struct uwsgi_option uwsgi_base_options[] = {
         {"hook-as-vassal", required_argument, 0, "run the specified hook before exec()ing the vassal", uwsgi_opt_add_string_list, &uwsgi.hook_as_vassal, 0},
         {"hook-as-emperor", required_argument, 0, "run the specified hook in the emperor after the vassal has been started", uwsgi_opt_add_string_list, &uwsgi.hook_as_emperor, 0},
 
+        {"hook-as-on-demand-vassal", required_argument, 0, "run the specified hook whenever a vassal enters on-demand mode", uwsgi_opt_add_string_list, &uwsgi.hook_as_on_demand_vassal, 0},
+	{"hook-as-on-config-vassal", required_argument, 0, "run the specified hook whenever the emperor detects a config change for an on-demand vassal", uwsgi_opt_add_string_list, &uwsgi.hook_as_on_config_vassal, 0},
+
+        {"hook-as-emperor-before-vassal", required_argument, 0, "run the specified hook before the new vassal is spawned", uwsgi_opt_add_string_list, &uwsgi.hook_as_emperor_before_vassal, 0},
+        {"hook-as-vassal-before-drop", required_argument, 0, "run the specified hook into vassal, before dropping its privileges", uwsgi_opt_add_string_list, &uwsgi.hook_as_vassal_before_drop, 0},
+
+        {"hook-as-emperor-setns", required_argument, 0, "run the specified hook in the emperor entering vassal namespace", uwsgi_opt_add_string_list, &uwsgi.hook_as_emperor_setns, 0},
+
         {"hook-as-mule", required_argument, 0, "run the specified hook in each mule", uwsgi_opt_add_string_list, &uwsgi.hook_as_mule, 0},
 
         {"hook-as-gateway", required_argument, 0, "run the specified hook in each gateway", uwsgi_opt_add_string_list, &uwsgi.hook_as_gateway, 0},
@@ -596,6 +618,8 @@ static struct uwsgi_option uwsgi_base_options[] = {
 
 	{"notify-socket", required_argument, 0, "enable the notification socket", uwsgi_opt_set_str, &uwsgi.notify_socket, UWSGI_OPT_MASTER},
 	{"subscription-notify-socket", required_argument, 0, "set the notification socket for subscriptions", uwsgi_opt_set_str, &uwsgi.subscription_notify_socket, UWSGI_OPT_MASTER},
+	{"subscription-mountpoints", no_argument, 0, "enable mountpoints support for subscription system", uwsgi_opt_true, &uwsgi.subscription_mountpoints, UWSGI_OPT_MASTER},
+	{"subscription-mountpoint", no_argument, 0, "enable mountpoints support for subscription system", uwsgi_opt_true, &uwsgi.subscription_mountpoints, UWSGI_OPT_MASTER},
 
 #ifdef UWSGI_SSL
 	{"legion", required_argument, 0, "became a member of a legion", uwsgi_opt_legion, NULL, UWSGI_OPT_MASTER},
@@ -632,9 +656,6 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"subscription-tolerance", required_argument, 0, "set tolerance for subscription servers", uwsgi_opt_set_int, &uwsgi.subscription_tolerance, 0},
 	{"unsubscribe-on-graceful-reload", no_argument, 0, "force unsubscribe request even during graceful reload", uwsgi_opt_true, &uwsgi.unsubscribe_on_graceful_reload, 0},
 	{"start-unsubscribed", no_argument, 0, "configure subscriptions but do not send them (useful with master fifo)", uwsgi_opt_true, &uwsgi.subscriptions_blocked, 0},
-
-	{"subscribe-with-modifier1", required_argument, 0, "force the specififed modifier1 when subscribing", uwsgi_opt_set_str, &uwsgi.subscribe_with_modifier1, UWSGI_OPT_MASTER},
-
 	{"snmp", optional_argument, 0, "enable the embedded snmp server", uwsgi_opt_snmp, NULL, 0},
 	{"snmp-community", required_argument, 0, "set the snmp community string", uwsgi_opt_snmp_community, NULL, 0},
 #ifdef UWSGI_SSL
@@ -647,8 +668,6 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"sni", required_argument, 0, "add an SNI-governed SSL context", uwsgi_opt_sni, NULL, 0},
 	{"sni-dir", required_argument, 0, "check for cert/key/client_ca file in the specified directory and create a sni/ssl context on demand", uwsgi_opt_set_str, &uwsgi.sni_dir, 0},
 	{"sni-dir-ciphers", required_argument, 0, "set ssl ciphers for sni-dir option", uwsgi_opt_set_str, &uwsgi.sni_dir_ciphers, 0},
-	{"ssl-enable3", no_argument, 0, "enable SSLv3 (insecure)", uwsgi_opt_true, &uwsgi.sslv3, 0},
-	{"ssl-option", no_argument, 0, "set a raw ssl option (numeric value)", uwsgi_opt_add_string_list, &uwsgi.ssl_options, 0},
 #ifdef UWSGI_PCRE
 	{"sni-regexp", required_argument, 0, "add an SNI-governed SSL context (the key is a regexp)", uwsgi_opt_sni, NULL, 0},
 #endif
@@ -662,6 +681,7 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"privileged-binary-patch-arg", required_argument, 0, "patch the uwsgi binary with a new command and arguments (before privileges drop)", uwsgi_opt_set_str, &uwsgi.privileged_binary_patch_arg, 0},
 	{"unprivileged-binary-patch-arg", required_argument, 0, "patch the uwsgi binary with a new command and arguments (after privileges drop)", uwsgi_opt_set_str, &uwsgi.unprivileged_binary_patch_arg, 0},
 	{"async", required_argument, 0, "enable async mode with specified cores", uwsgi_opt_set_int, &uwsgi.async, 0},
+	{"disable-async-warn-on-queue-full", no_argument, 0, "Disable printing 'async queue is full' warning messages.", uwsgi_opt_false, &uwsgi.async_warn_if_queue_full, 0},
 	{"max-fd", required_argument, 0, "set maximum number of file descriptors (requires root privileges)", uwsgi_opt_set_int, &uwsgi.requested_max_fd, 0},
 	{"logto", required_argument, 0, "set logfile/udp address", uwsgi_opt_set_str, &uwsgi.logfile, 0},
 	{"logto2", required_argument, 0, "log to specified file or udp address after privileges drop", uwsgi_opt_set_str, &uwsgi.logto2, 0},
@@ -862,8 +882,6 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"collect-header", required_argument, 0, "store the specified response header in a request var (syntax: header var)", uwsgi_opt_add_string_list, &uwsgi.collect_headers, 0},
 	{"response-header-collect", required_argument, 0, "store the specified response header in a request var (syntax: header var)", uwsgi_opt_add_string_list, &uwsgi.collect_headers, 0},
 
-	{"pull-header", required_argument, 0, "store the specified response header in a request var and remove it from the response (syntax: header var)", uwsgi_opt_add_string_list, &uwsgi.pull_headers, 0},
-
 	{"check-static", required_argument, 0, "check for static files in the specified directory", uwsgi_opt_check_static, NULL, UWSGI_OPT_MIME},
 	{"check-static-docroot", no_argument, 0, "check for static files in the requested DOCUMENT_ROOT", uwsgi_opt_true, &uwsgi.check_static_docroot, UWSGI_OPT_MIME},
 	{"static-check", required_argument, 0, "check for static files in the specified directory", uwsgi_opt_check_static, NULL, UWSGI_OPT_MIME},
@@ -917,6 +935,7 @@ static struct uwsgi_option uwsgi_base_options[] = {
 	{"close-on-exec2", no_argument, 0, "set close-on-exec on server sockets (could be required for spawning processes in requests)", uwsgi_opt_true, &uwsgi.close_on_exec2, 0},
 	{"mode", required_argument, 0, "set uWSGI custom mode", uwsgi_opt_set_str, &uwsgi.mode, 0},
 	{"env", required_argument, 0, "set environment variable", uwsgi_opt_set_env, NULL, 0},
+	{"ienv", required_argument, 0, "set environment variable (IMMEDIATE version)", uwsgi_opt_set_env, NULL, UWSGI_OPT_IMMEDIATE},
 	{"envdir", required_argument, 0, "load a daemontools compatible envdir", uwsgi_opt_add_string_list, &uwsgi.envdirs, 0},
 	{"early-envdir", required_argument, 0, "load a daemontools compatible envdir ASAP", uwsgi_opt_envdir, NULL, UWSGI_OPT_IMMEDIATE},
 	{"unenv", required_argument, 0, "unset environment variable", uwsgi_opt_unset_env, NULL, 0},
@@ -1217,7 +1236,7 @@ void gracefully_kill(int signum) {
 	}
 
 	// still not found a way to gracefully reload in async mode
-	if (uwsgi.async > 1) {
+	if (uwsgi.async > 0) {
 		exit(UWSGI_RELOAD_CODE);
 	}
 
@@ -1463,7 +1482,7 @@ void what_i_am_doing() {
 #else
 				ctime_r((const time_t *) &wsgi_req->start_of_request_in_sec, ctime_storage);
 #endif
-				if (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].harakiri < uwsgi_now()) {
+				if (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri < uwsgi_now()) {
 					uwsgi_log("HARAKIRI: --- uWSGI worker %d core %d (pid: %d) WAS managing request %.*s since %.*s ---\n", (int) uwsgi.mywid, i, (int) uwsgi.mypid, wsgi_req->uri_len, wsgi_req->uri, 24, ctime_storage);
 				}
 				else {
@@ -1480,14 +1499,14 @@ void what_i_am_doing() {
 #else
 			ctime_r((const time_t *) &wsgi_req->start_of_request_in_sec, ctime_storage);
 #endif
-			if (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].harakiri < uwsgi_now()) {
+			if (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri < uwsgi_now()) {
 				uwsgi_log("HARAKIRI: --- uWSGI worker %d (pid: %d) WAS managing request %.*s since %.*s ---\n", (int) uwsgi.mywid, (int) uwsgi.mypid, wsgi_req->uri_len, wsgi_req->uri, 24, ctime_storage);
 			}
 			else {
 				uwsgi_log("SIGUSR2: --- uWSGI worker %d (pid: %d) is managing request %.*s since %.*s ---\n", (int) uwsgi.mywid, (int) uwsgi.mypid, wsgi_req->uri_len, wsgi_req->uri, 24, ctime_storage);
 			}
 		}
-		else if (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].harakiri < uwsgi_now() && uwsgi.workers[uwsgi.mywid].sig) {
+		else if (uwsgi.harakiri_options.workers > 0 && uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri < uwsgi_now() && uwsgi.workers[uwsgi.mywid].sig) {
 			uwsgi_log("HARAKIRI: --- uWSGI worker %d (pid: %d) WAS handling signal %d ---\n", (int) uwsgi.mywid, (int) uwsgi.mypid, uwsgi.workers[uwsgi.mywid].signum);
 		}
 	}
@@ -1992,6 +2011,7 @@ static char *uwsgi_at_file_read(char *filename) {
 }
 
 void uwsgi_setup(int argc, char *argv[], char *envp[]) {
+
 #ifdef UWSGI_AS_SHARED_LIBRARY
 #ifdef __APPLE__
 	char ***envPtr = _NSGetEnviron();
@@ -2172,6 +2192,8 @@ void uwsgi_setup(int argc, char *argv[], char *envp[]) {
 	struct group *gr = getgrgid(getgid());
 	uwsgi.magic_table['G'] = gr ? gr->gr_name : uwsgi.magic_table['g'];
 
+configure:
+
 	// you can embed a ini file in the uWSGi binary with default options
 #ifdef UWSGI_EMBED_CONFIG
 	uwsgi_ini_config("", uwsgi.magic_table);
@@ -2196,6 +2218,14 @@ void uwsgi_setup(int argc, char *argv[], char *envp[]) {
 	// ok, the options dictionary is available, lets manage it
 	uwsgi_configure();
 
+	// stop the execution until a connection arrives on the fork socket
+	if (uwsgi.fork_socket) {
+		uwsgi_log_verbose("waiting for fork-socket connections...\n");
+		uwsgi_fork_server(uwsgi.fork_socket);
+		// if we are here a new process has been spawned
+		goto configure;
+	}
+
 	// fixup cwd
 	if (uwsgi.force_cwd) uwsgi.cwd = uwsgi.force_cwd;
 
@@ -2661,7 +2691,7 @@ int uwsgi_start(void *v_argv) {
 		}
 	}
 
-	if (uwsgi.async > 1) {
+	if (uwsgi.async > 0) {
 		if ((unsigned long) uwsgi.max_fd < (unsigned long) uwsgi.async) {
 			uwsgi_log_initial("- your current max open files limit is %lu, this is lower than requested async cores !!! -\n", (unsigned long) uwsgi.max_fd);
 			uwsgi.rl.rlim_cur = uwsgi.async;
@@ -2915,8 +2945,23 @@ unsafe:
 		uwsgi_log("your server socket listen backlog is limited to %d connections\n", uwsgi.listen_queue);
 #endif
 
+
 	uwsgi_log("your mercy for graceful operations on workers is %d seconds\n", uwsgi.worker_reload_mercy);
 
+	uwsgi_log("your request buffer size is %llu bytes\n", (unsigned long long) uwsgi.buffer_size);
+	if (!uwsgi.__buffer_size) {
+		if (uwsgi.buffer_size > 0xffff) {
+			uwsgi_log("your request buffer size for old plugins has been limited to 64k\n");
+			uwsgi.__buffer_size = 0xffff;
+		}
+		else {
+			uwsgi.__buffer_size = uwsgi.buffer_size;
+		}
+	}
+	else {
+		uwsgi_log("your request buffer size for old plugins is %u bytes\n", uwsgi.__buffer_size);
+	}
+
 	if (uwsgi.crons) {
 		struct uwsgi_cron *ucron = uwsgi.crons;
 		while (ucron) {
@@ -2969,7 +3014,7 @@ unsafe:
 			uwsgi_log("*** Operational MODE: threaded ***\n");
 		}
 	}
-	else if (uwsgi.async > 1) {
+	else if (uwsgi.async > 0) {
 		if (uwsgi.numproc > 1) {
 			uwsgi_log("*** Operational MODE: preforking+async ***\n");
 		}
@@ -3298,8 +3343,6 @@ int uwsgi_run() {
                 }
         }
 
-	uwsgi_hooks_run(uwsgi.hook_post_fork, "post-fork", 1);
-
 	if (uwsgi.worker_exec2) {
                 char *w_argv[2];
                 w_argv[0] = uwsgi.worker_exec2;
@@ -3339,7 +3382,7 @@ void uwsgi_worker_run() {
 	// some apps could be mounted only on specific workers
 	uwsgi_init_worker_mount_apps();
 
-	if (uwsgi.async > 1) {
+	if (uwsgi.async > 0) {
 		// a stack of unused cores
         	uwsgi.async_queue_unused = uwsgi_malloc(sizeof(struct wsgi_request *) * uwsgi.async);
 
@@ -3483,7 +3526,7 @@ void uwsgi_ignition() {
 		uwsgi_log("your loop engine died. R.I.P.\n");
 	}
 	else {
-		if (uwsgi.async < 2) {
+		if (uwsgi.async < 1) {
 			simple_loop();
 		}
 		else {
diff --git a/core/webdav.c b/core/webdav.c
new file mode 100644
index 0000000..9f78cda
--- /dev/null
+++ b/core/webdav.c
@@ -0,0 +1,110 @@
+#include <uwsgi.h>
+
+extern struct uwsgi_server uwsgi;
+
+/*
+
+The following functions are useful to implement simil-webdav support in plugins.
+
+Most of them are not fully webdav compliant, but will work on the vast majority of clients.
+
+*/
+
+// a multi-status response (207) will return an xml with a list
+// of <D:response> stanzas
+
+struct uwsgi_buffer *uwsgi_webdav_multistatus_new() {
+	struct uwsgi_buffer *ub = uwsgi_buffer_new(uwsgi.page_size);
+	if (uwsgi_buffer_append(ub, "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n", 40)) goto error;
+	if (uwsgi_buffer_append(ub, "<D:multistatus xmlns:D=\"DAV:\">\n", 31)) goto error;
+	return ub;
+error:
+	uwsgi_buffer_destroy(ub);
+	return NULL;
+}
+
+int uwsgi_webdav_multistatus_close(struct uwsgi_buffer *ub) {
+	if (uwsgi_buffer_append(ub, "</D:multistatus>\n", 17)) return -1;
+	return 0;
+}
+
+int uwsgi_webdav_multistatus_response_new(struct uwsgi_buffer *ub) {
+	if (uwsgi_buffer_append(ub, "<D:response>\n", 13)) return -1;
+        return 0;
+}
+
+int uwsgi_webdav_multistatus_response_close(struct uwsgi_buffer *ub) {
+	if (uwsgi_buffer_append(ub, "</D:response>\n", 14)) return -1;
+        return 0;
+}
+
+int uwsgi_webdav_multistatus_propstat_new(struct uwsgi_buffer *ub) {
+	if (uwsgi_buffer_append(ub, "<D:propstat>\n", 13)) return -1;
+        return 0;
+}
+
+int uwsgi_webdav_multistatus_propstat_close(struct uwsgi_buffer *ub) {
+	if (uwsgi_buffer_append(ub, "</D:propstat>\n", 14)) return -1;
+        return 0;
+}
+
+int uwsgi_webdav_multistatus_prop_new(struct uwsgi_buffer *ub) {
+	if (uwsgi_buffer_append(ub, "<D:prop>\n", 9)) return -1;
+        return 0;
+}
+
+int uwsgi_webdav_multistatus_prop_close(struct uwsgi_buffer *ub) {
+	if (uwsgi_buffer_append(ub, "</D:prop>\n", 10)) return -1;
+        return 0;
+}
+
+// shortcut for adding a propfind-response item
+int uwsgi_webdav_propfind_item_add(struct uwsgi_buffer *ub, char *href, uint16_t href_len, uint64_t cl, time_t mtime, char *ctype, uint16_t ctype_len, char *displayname, uint16_t displayname_len, char *etag, uint16_t etag_len) {
+	if (uwsgi_webdav_multistatus_response_new(ub)) return -1;
+	if (uwsgi_buffer_append(ub, "<D:href>", 8)) return -1;
+	if (uwsgi_buffer_append(ub, href, href_len)) return -1;
+	if (uwsgi_buffer_append(ub, "</D:href>\n", 10)) return -1;
+	if (uwsgi_webdav_multistatus_propstat_new(ub)) return -1;
+	if (uwsgi_webdav_multistatus_prop_new(ub)) return -1;
+
+	if (href[href_len-1] == '/') {
+		if (uwsgi_buffer_append(ub, "<D:resourcetype><D:collection/></D:resourcetype>\n", 49)) return -1;
+	}
+	else {
+		// getcontentlength
+		if (uwsgi_buffer_append(ub, "<D:getcontentlength>", 20)) return -1;
+		if (uwsgi_buffer_num64(ub, cl)) return -1;
+		if (uwsgi_buffer_append(ub, "</D:getcontentlength>\n", 22)) return -1;
+	}
+
+	// getlastmodified
+	if (mtime > 0) {
+		if (uwsgi_buffer_append(ub, "<D:getlastmodified>", 19)) return -1;	
+		if (uwsgi_buffer_httpdate(ub, mtime)) return -1;
+		if (uwsgi_buffer_append(ub, "</D:getlastmodified>\n", 21)) return -1;	
+	}
+
+	// displayname
+	if (displayname_len > 0) {
+		if (uwsgi_buffer_append(ub, "<D:displayname>\n", 16)) return -1;
+		if (uwsgi_buffer_append_xml(ub, displayname, displayname_len)) return -1;
+		if (uwsgi_buffer_append(ub, "</D:displayname>\n", 17)) return -1;
+	}
+
+	if (ctype_len > 0) {
+		if (uwsgi_buffer_append(ub, "<D:getcontenttype>", 18)) return -1;
+		if (uwsgi_buffer_append(ub, ctype, ctype_len)) return -1;
+		if (uwsgi_buffer_append(ub, "</D:getcontenttype>\n", 20)) return -1;
+	}
+
+	if (etag_len > 0) {
+		if (uwsgi_buffer_append(ub, "<D:getetag>\n", 12)) return -1;
+		if (uwsgi_buffer_append_xml(ub, displayname, displayname_len)) return -1;
+		if (uwsgi_buffer_append(ub, "</D:getetag>\n", 13)) return -1;
+	}
+
+	if (uwsgi_webdav_multistatus_prop_close(ub)) return -1;
+	if (uwsgi_webdav_multistatus_propstat_close(ub)) return -1;
+	if (uwsgi_webdav_multistatus_response_close(ub)) return -1;
+	return 0;
+}
diff --git a/core/websockets.c b/core/websockets.c
index 12ad54a..1998e35 100644
--- a/core/websockets.c
+++ b/core/websockets.c
@@ -273,7 +273,6 @@ static struct uwsgi_buffer *uwsgi_websocket_recv_do(struct wsgi_request *wsgi_re
 					}
 					else {
 						wsgi_req->websocket_need += wsgi_req->websocket_size;
-						wsgi_req->websocket_pktsize += wsgi_req->websocket_size;
 						wsgi_req->websocket_phase = 4;
 					}
 					break;
diff --git a/core/writer.c b/core/writer.c
index d9cac74..f397834 100644
--- a/core/writer.c
+++ b/core/writer.c
@@ -124,18 +124,9 @@ error:
 static int uwsgi_response_add_header_do(struct wsgi_request *wsgi_req, char *key, uint16_t key_len, char *value, uint16_t value_len) {
 
 
-	// pull/collect the header ?
+	// collect the header ?
 	struct uwsgi_string_list *usl = NULL;
 
-	uwsgi_foreach(usl, uwsgi.pull_headers) {
-                if (!uwsgi_strnicmp(key, key_len, usl->value, usl->custom)) {
-                        if (!uwsgi_req_append(wsgi_req, usl->custom_ptr, usl->custom2, value, value_len)) {
-                                wsgi_req->write_errors++ ; return -1;
-                        }
-			return 0;
-                }
-        }
-
 	uwsgi_foreach(usl, uwsgi.collect_headers) {
 		if (!uwsgi_strnicmp(key, key_len, usl->value, usl->custom)) {
 			if (!uwsgi_req_append(wsgi_req, usl->custom_ptr, usl->custom2, value, value_len)) {
diff --git a/core/zeus.c b/core/zeus.c
index 3f738ab..f17dcb0 100644
--- a/core/zeus.c
+++ b/core/zeus.c
@@ -1,3 +1,5 @@
+#include <uwsgi.h>
+
 /*
 
 	*** WORK IN PROGRESS ***
@@ -16,11 +18,11 @@
 
 
 	# unencrypted mode
-	uwsgi --zeus "192.168.173.17:4040 /etc/uwsgi/vassals"
+	uwsgi --zeus 192.168.173.17:4040 --emperor /etc/uwsgi/vassals
 	# crypted mode
-	uwsgi --zeus "192.168.173.17:4040,foobar.crt,foobar.key /etc/uwsgi/vassals"
+	uwsgi --zeus 192.168.173.17:4040,foobar.crt,foobar.key --emperor /etc/uwsgi/vassals
 	# crypted + authentication mode
-	uwsgi --zeus "192.168.173.17:4040,foobar.crt,foobar.key,clients.pem /etc/uwsgi/vassals"
+	uwsgi --zeus 192.168.173.17:4040,foobar.crt,foobar.key,clients.pem --emperor /etc/uwsgi/vassals
 
 
 	to connect an Emperor to Zeus
@@ -64,3 +66,23 @@
 	11 -> VASSAL_DESTROYED {name: 'foobar.ini'} [the choosen emperor -> zeus]
 
 */
+
+/*
+	check how many nodes the instace needs (default 1)
+*/
+
+int uwsgi_zeus_spawn_instance(struct uwsgi_instance *ui) {
+	int i, nodes = 1;
+	char *how_many_nodes = vassal_attr_get(ui, "zeus-nodes");
+	if (how_many_nodes) {	
+		nodes = atoi(how_many_nodes);
+	}
+	for(i=0;i<nodes;i++) {
+		// now start analyzing nodes, the one with most
+		// free slots will be used
+
+		// send NEW_VASSAL request to the node,
+		// if it answers with ACCEPTED_VASSAL 
+	}
+	return 0;
+}
diff --git a/plugins/asyncio/asyncio.c b/plugins/asyncio/asyncio.c
index 13ca074..3d857bb 100644
--- a/plugins/asyncio/asyncio.c
+++ b/plugins/asyncio/asyncio.c
@@ -205,7 +205,7 @@ static PyObject *py_uwsgi_asyncio_accept(PyObject *self, PyObject *args) {
 
         // enter harakiri mode
         if (uwsgi.harakiri_options.workers > 0) {
-                set_harakiri(uwsgi.harakiri_options.workers);
+                set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
         }
 
 	uwsgi.async_proto_fd_table[wsgi_req->fd] = wsgi_req;
@@ -312,7 +312,7 @@ static void asyncio_loop() {
 	uwsgi.wait_write_hook = uwsgi_asyncio_wait_write_hook;
 	uwsgi.wait_read_hook = uwsgi_asyncio_wait_read_hook;
 
-	if (uwsgi.async < 2) {
+	if (uwsgi.async < 1) {
 		uwsgi_log("the asyncio loop engine requires async mode (--async <n>)\n");
 		exit(1);
 	}
@@ -328,13 +328,9 @@ static void asyncio_loop() {
 		uwsgi.schedule_fix = uwsgi_asyncio_schedule_fix;
 	}
 
-#ifndef PYTHREE
-	PyObject *asyncio = PyImport_ImportModule("trollius");
-#else
 	PyObject *asyncio = PyImport_ImportModule("asyncio");
-#endif
 	if (!asyncio) uwsgi_pyexit;
-
+	
 	uasyncio.mod = asyncio;
 
 	uasyncio.loop = PyObject_CallMethod(asyncio, "get_event_loop", NULL);
diff --git a/plugins/cache/cache.c b/plugins/cache/cache.c
index c0da1fc..2e9100b 100644
--- a/plugins/cache/cache.c
+++ b/plugins/cache/cache.c
@@ -208,10 +208,10 @@ static int uwsgi_cache_request(struct wsgi_request *wsgi_req) {
         switch(wsgi_req->uh->modifier2) {
                 case 0:
                         // get
-                        if (wsgi_req->uh->pktsize > 0) {
-                                value = uwsgi_cache_magic_get(wsgi_req->buffer, wsgi_req->uh->pktsize, &vallen, NULL, NULL);
+                        if (wsgi_req->uh->_pktsize > 0) {
+                                value = uwsgi_cache_magic_get(wsgi_req->buffer, wsgi_req->uh->_pktsize, &vallen, NULL, NULL);
                                 if (value) {
-                                        wsgi_req->uh->pktsize = vallen;
+                                        wsgi_req->uh->_pktsize = vallen;
 					if (uwsgi_response_write_body_do(wsgi_req, (char *)&wsgi_req->uh, 4)) { free(value) ; return -1;}
 					uwsgi_response_write_body_do(wsgi_req, value, vallen);
 					free(value);
@@ -220,10 +220,10 @@ static int uwsgi_cache_request(struct wsgi_request *wsgi_req) {
                         break;
                 case 1:
                         // set
-                        if (wsgi_req->uh->pktsize > 0) {
+                        if (wsgi_req->uh->_pktsize > 0) {
 				// max 3 items
                                 argc = 3;
-                                if (!uwsgi_parse_array(wsgi_req->buffer, wsgi_req->uh->pktsize, argv, argvs, &argc)) {
+                                if (!uwsgi_parse_array(wsgi_req->buffer, wsgi_req->uh->_pktsize, argv, argvs, &argc)) {
                                         if (argc > 1) {
 						uwsgi_cache_magic_set(argv[0], argvs[0], argv[1], argvs[1], 0, 0, NULL);
                                         }
@@ -232,30 +232,30 @@ static int uwsgi_cache_request(struct wsgi_request *wsgi_req) {
                         break;
                 case 2:
                         // del
-                        if (wsgi_req->uh->pktsize > 0) {
-                                uwsgi_cache_magic_del(wsgi_req->buffer, wsgi_req->uh->pktsize, NULL);
+                        if (wsgi_req->uh->_pktsize > 0) {
+                                uwsgi_cache_magic_del(wsgi_req->buffer, wsgi_req->uh->_pktsize, NULL);
                         }
                         break;
                 case 3:
                 case 4:
                         // dict
-                        if (wsgi_req->uh->pktsize > 0) {
-                                uwsgi_hooked_parse(wsgi_req->buffer, wsgi_req->uh->pktsize, cache_simple_command, (void *) wsgi_req);
+                        if (wsgi_req->uh->_pktsize > 0) {
+                                uwsgi_hooked_parse(wsgi_req->buffer, wsgi_req->uh->_pktsize, cache_simple_command, (void *) wsgi_req);
                         }
                         break;
                 case 5:
                         // get (uwsgi + stream)
-                        if (wsgi_req->uh->pktsize > 0) {
-                                value = uwsgi_cache_magic_get(wsgi_req->buffer, wsgi_req->uh->pktsize, &vallen, NULL, NULL);
+                        if (wsgi_req->uh->_pktsize > 0) {
+                                value = uwsgi_cache_magic_get(wsgi_req->buffer, wsgi_req->uh->_pktsize, &vallen, NULL, NULL);
                                 if (value) {
-                                        wsgi_req->uh->pktsize = 0;
+                                        wsgi_req->uh->_pktsize = 0;
                                         wsgi_req->uh->modifier2 = 1;
 					if (uwsgi_response_write_body_do(wsgi_req, (char *)&wsgi_req->uh, 4)) { free(value) ;return -1;}
 					uwsgi_response_write_body_do(wsgi_req, value, vallen);
 					free(value);
                                 }
                                 else {
-                                        wsgi_req->uh->pktsize = 0;
+                                        wsgi_req->uh->_pktsize = 0;
                                         wsgi_req->uh->modifier2 = 0;
 					uwsgi_response_write_body_do(wsgi_req, (char *)&wsgi_req->uh, 4);
 					free(value);
@@ -265,8 +265,8 @@ static int uwsgi_cache_request(struct wsgi_request *wsgi_req) {
 		case 6:
 			// dump
 			uc = uwsgi.caches;
-			if (wsgi_req->uh->pktsize > 0) {
-				uc = uwsgi_cache_by_namelen(wsgi_req->buffer, wsgi_req->uh->pktsize);
+			if (wsgi_req->uh->_pktsize > 0) {
+				uc = uwsgi_cache_by_namelen(wsgi_req->buffer, wsgi_req->uh->_pktsize);
 			}
 
 			if (!uc) break;
@@ -299,9 +299,9 @@ static int uwsgi_cache_request(struct wsgi_request *wsgi_req) {
 			uwsgi_buffer_destroy(cache_dump);
 			break;
 		case 17:
-			if (wsgi_req->uh->pktsize == 0) break;
+			if (wsgi_req->uh->_pktsize == 0) break;
 			memset(&ucmc, 0, sizeof(struct uwsgi_cache_magic_context));
-			if (uwsgi_hooked_parse(wsgi_req->buffer, wsgi_req->uh->pktsize, uwsgi_cache_magic_context_hook, &ucmc)) {
+			if (uwsgi_hooked_parse(wsgi_req->buffer, wsgi_req->uh->_pktsize, uwsgi_cache_magic_context_hook, &ucmc)) {
 				break;
 			}
 			manage_magic_context(wsgi_req, &ucmc);
diff --git a/plugins/carbon/carbon.c b/plugins/carbon/carbon.c
index 835ef72..017551a 100644
--- a/plugins/carbon/carbon.c
+++ b/plugins/carbon/carbon.c
@@ -71,9 +71,7 @@ static void carbon_post_init() {
 		u_server->errors = 0;
 
 		char *p, *ctx = NULL;
-		// make a copy to not clobber argv
-		char *tmp = uwsgi_str(usl->value);
-		uwsgi_foreach_token(tmp, ":", p, ctx) {
+		uwsgi_foreach_token(usl->value, ":", p, ctx) {
 			if (!u_server->hostname) {
 				u_server->hostname = uwsgi_str(p);
 			}
@@ -83,7 +81,6 @@ static void carbon_post_init() {
 			else
 				break;
 		}
-		free(tmp);
 		if (!u_server->hostname || !u_server->port) {
 			uwsgi_log("[carbon] invalid carbon server address (%s)\n", usl->value);
 			usl = usl->next;
@@ -199,7 +196,7 @@ static int carbon_push_stats(int retry_cycle, time_t now) {
 	for (i = 0; i < uwsgi.numproc; i++) {
 		u_carbon.current_busyness_values[i] = uwsgi.workers[i+1].running_time - u_carbon.last_busyness_values[i];
 		u_carbon.last_busyness_values[i] = uwsgi.workers[i+1].running_time;
-		u_carbon.was_busy[i] += uwsgi_worker_is_busy(i+1);
+		u_carbon.was_busy[i-1] += uwsgi_worker_is_busy(i+1);
 	}
 
 	needs_retry = 0;
diff --git a/plugins/cgi/cgi_plugin.c b/plugins/cgi/cgi_plugin.c
index 2dcaa90..0c7d3eb 100644
--- a/plugins/cgi/cgi_plugin.c
+++ b/plugins/cgi/cgi_plugin.c
@@ -480,7 +480,7 @@ static int uwsgi_cgi_request(struct wsgi_request *wsgi_req) {
 	char *script_name = NULL;
 
 	/* Standard CGI request */
-	if (!wsgi_req->uh->pktsize) {
+	if (!wsgi_req->len) {
 		uwsgi_log("Empty CGI request. skip.\n");
 		return -1;
 	}
@@ -731,7 +731,7 @@ clear2:
 
 		// now wait for process exit/death
 		// in async mode we need a trick...
-		if (uwsgi.async > 1) {
+		if (uwsgi.async > 0) {
 			pid_t diedpid = waitpid(cgi_pid, &waitpid_status, WNOHANG);
 			if (diedpid < 0) {
                                	uwsgi_error("waitpid()");
diff --git a/plugins/corerouter/corerouter.c b/plugins/corerouter/corerouter.c
index df20c18..de254c9 100644
--- a/plugins/corerouter/corerouter.c
+++ b/plugins/corerouter/corerouter.c
@@ -75,12 +75,6 @@ void uwsgi_cr_peer_reset(struct corerouter_peer *peer) {
 		peer->hook_write = NULL;
 	}
 
-	if (peer->is_buffering) {
-		if (peer->buffering_fd != -1) {
-			close(peer->buffering_fd);
-		}
-	}
-
 	peer->failed = 0;
 	peer->soopt = 0;
 	peer->timed_out = 0;
@@ -90,13 +84,7 @@ void uwsgi_cr_peer_reset(struct corerouter_peer *peer) {
 }
 
 // destroy a peer
-int uwsgi_cr_peer_del(struct corerouter_peer *peer) {
-	// first of all check if we need to run a flush procedure
-	if (peer->flush && !peer->is_flushing) {
-		peer->is_flushing = 1;
-		// on success, suspend the execution
-		if (peer->flush(peer) >= 0) return -1;
-	}
+void uwsgi_cr_peer_del(struct corerouter_peer *peer) {
 	struct corerouter_peer *prev = peer->prev;
 	struct corerouter_peer *next = peer->next;
 
@@ -122,8 +110,11 @@ int uwsgi_cr_peer_del(struct corerouter_peer *peer) {
 	if (peer->out && peer->out_need_free) {
 		uwsgi_buffer_destroy(peer->out);
 	}
+
+	if (peer->free_key) {
+		free(peer->key);
+	}
 	free(peer);
-	return 0;
 }
 
 void uwsgi_opt_corerouter(char *opt, char *value, void *cr) {
@@ -304,6 +295,16 @@ void corerouter_manage_subscription(char *key, uint16_t keylen, char *val, uint1
 		usr->notify = val;
                 usr->notify_len = vallen;
 	}
+	else if (!uwsgi_strncmp("algo", 4, key, keylen)) {
+                usr->algo = uwsgi_subscription_algo_get(val, vallen);
+        }
+	else if (!uwsgi_strncmp("backup", 6, key, keylen)) {
+		usr->backup_level = uwsgi_str_num(val, vallen);
+        }
+	else if (!uwsgi_strncmp("proto", 5, key, keylen)) {
+                usr->proto = val;
+                usr->proto_len = vallen;
+        }
 }
 
 void corerouter_close_peer(struct uwsgi_corerouter *ucr, struct corerouter_peer *peer) {
@@ -396,7 +397,7 @@ void corerouter_close_peer(struct uwsgi_corerouter *ucr, struct corerouter_peer
 	}
 
 end:
-	if (uwsgi_cr_peer_del(peer) < 0) return;
+	uwsgi_cr_peer_del(peer);
 
 	if (peer == cs->main_peer) {
 		cs->main_peer = NULL;
@@ -414,7 +415,7 @@ void corerouter_close_session(struct uwsgi_corerouter *ucr, struct corerouter_se
 
 	struct corerouter_peer *main_peer = cr_session->main_peer;
 	if (main_peer) {
-		if (uwsgi_cr_peer_del(main_peer) < 0) return;
+		uwsgi_cr_peer_del(main_peer);
 	}
 
 	// free peers
@@ -426,7 +427,7 @@ void corerouter_close_session(struct uwsgi_corerouter *ucr, struct corerouter_se
 		if (ucr->subscriptions && tmp_peer->un && tmp_peer->un->len) {
 			tmp_peer->un->reference--;
 		}
-		if (uwsgi_cr_peer_del(tmp_peer) < 0) return;
+		uwsgi_cr_peer_del(tmp_peer);
 	}
 
 	// could be used to free additional resources
@@ -1064,6 +1065,7 @@ void corerouter_send_stats(struct uwsgi_corerouter *ucr) {
 #ifdef UWSGI_SSL
 				if (uwsgi_stats_keylong_comma(us, "sni_enabled", (unsigned long long) s_slot->sni_enabled)) goto end0;
 #endif
+				if (uwsgi_stats_keyval_comma(us, "algo", uwsgi_subscription_algo_name(s_slot->algo))) goto end0;
 
 				if (uwsgi_stats_key(us , "nodes")) goto end0;
 				if (uwsgi_stats_list_open(us)) goto end0;
@@ -1087,6 +1089,8 @@ void corerouter_send_stats(struct uwsgi_corerouter *ucr) {
 					if (uwsgi_stats_keylong_comma(us, "cores", (unsigned long long) s_node->cores)) goto end0;
 					if (uwsgi_stats_keylong_comma(us, "load", (unsigned long long) s_node->load)) goto end0;
 					if (uwsgi_stats_keylong_comma(us, "weight", (unsigned long long) s_node->weight)) goto end0;
+					if (uwsgi_stats_keylong_comma(us, "backup", (unsigned long long) s_node->backup_level)) goto end0;
+					if (uwsgi_stats_keyvaln_comma(us, "proto", &s_node->proto, 1)) goto end0;
 					if (uwsgi_stats_keylong_comma(us, "wrr", (unsigned long long) s_node->wrr)) goto end0;
 					if (uwsgi_stats_keylong_comma(us, "ref", (unsigned long long) s_node->reference)) goto end0;
 					if (uwsgi_stats_keylong_comma(us, "failcnt", (unsigned long long) s_node->failcnt)) goto end0;
diff --git a/plugins/corerouter/cr.h b/plugins/corerouter/cr.h
index 383f9b8..901c5b4 100644
--- a/plugins/corerouter/cr.h
+++ b/plugins/corerouter/cr.h
@@ -180,8 +180,8 @@ struct corerouter_peer {
 	uint16_t retries;
 
 	// parsed key
-        char key[0xff];
-        uint8_t key_len;
+        char *key;
+        uint16_t key_len;
 
 	uint8_t modifier1;
 	uint8_t modifier2;
@@ -191,11 +191,10 @@ struct corerouter_peer {
 
 	int current_timeout;
 
-	ssize_t (*flush)(struct corerouter_peer *);
+	// maps 1:1 with subscription proto
+	char proto;
 
-	int is_flushing;
-	int is_buffering;
-        int buffering_fd;
+	int free_key;
 };
 
 struct uwsgi_corerouter {
diff --git a/plugins/corerouter/cr_map.c b/plugins/corerouter/cr_map.c
index 082e1db..9d9908f 100644
--- a/plugins/corerouter/cr_map.c
+++ b/plugins/corerouter/cr_map.c
@@ -48,12 +48,18 @@ int uwsgi_cr_map_use_pattern(struct uwsgi_corerouter *ucr, struct corerouter_pee
 
 int uwsgi_cr_map_use_subscription(struct uwsgi_corerouter *ucr, struct corerouter_peer *peer) {
 
-	peer->un = uwsgi_get_subscribe_node(ucr->subscriptions, peer->key, peer->key_len);
+	struct uwsgi_subscription_client usc;
+	usc.fd = peer->session->main_peer->fd;
+	usc.sockaddr = &peer->session->client_sockaddr;
+	usc.cookie = NULL;
+
+	peer->un = uwsgi_get_subscribe_node(ucr->subscriptions, peer->key, peer->key_len, &usc);
 	if (peer->un && peer->un->len) {
 		peer->instance_address = peer->un->name;
 		peer->instance_address_len = peer->un->len;
 		peer->modifier1 = peer->un->modifier1;
 		peer->modifier2 = peer->un->modifier2;
+		peer->proto = peer->un->proto;
 	}
 	else if (ucr->cheap && !ucr->i_am_cheap && uwsgi_no_subscriptions(ucr->subscriptions)) {
 		uwsgi_gateway_go_cheap(ucr->name, ucr->queue, &ucr->i_am_cheap);
@@ -69,12 +75,17 @@ int uwsgi_cr_map_use_subscription_dotsplit(struct uwsgi_corerouter *ucr, struct
 	// max 5 split, reduce DOS attempts
 	int count = 5;
 
+	struct uwsgi_subscription_client usc;
+	usc.fd = peer->session->main_peer->fd;
+	usc.sockaddr = &peer->session->client_sockaddr;
+	usc.cookie = NULL;
+
 split:
 	if (!count) return 0;
 #ifdef UWSGI_DEBUG
 	uwsgi_log("trying with %.*s\n", name_len, name);
 #endif
-        peer->un = uwsgi_get_subscribe_node(ucr->subscriptions, name, name_len);
+        peer->un = uwsgi_get_subscribe_node(ucr->subscriptions, name, name_len, &usc);
 	if (!peer->un) {
 		char *next = memchr(name+1, '.', name_len-1);
 		if (next) {
@@ -89,7 +100,8 @@ split:
                 peer->instance_address = peer->un->name;
                 peer->instance_address_len = peer->un->len;
                 peer->modifier1 = peer->un->modifier1;
-                peer->modifier2 = peer->un->modifier2;
+		peer->modifier2 = peer->un->modifier2;
+		peer->proto = peer->un->proto;
         }
         else if (ucr->cheap && !ucr->i_am_cheap && uwsgi_no_subscriptions(ucr->subscriptions)) {
                 uwsgi_gateway_go_cheap(ucr->name, ucr->queue, &ucr->i_am_cheap);
diff --git a/plugins/coroae/coroae.c b/plugins/coroae/coroae.c
index fc6ca7e..837f054 100644
--- a/plugins/coroae/coroae.c
+++ b/plugins/coroae/coroae.c
@@ -187,7 +187,7 @@ end:
 
 XS(XS_coroae_sighandler) {
 	int sigfd = (long) XSANY.any_ptr;
-	uwsgi_receive_signal(sigfd, "worker", uwsgi.mywid);
+	uwsgi_receive_signal(NULL, sigfd, "worker", uwsgi.mywid);
 }
 
 XS(XS_coroae_acceptor) {
@@ -227,7 +227,7 @@ edge:
 
         // enter harakiri mode
         if (uwsgi.harakiri_options.workers > 0) {
-                set_harakiri(uwsgi.harakiri_options.workers);
+                set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
         }
 
 
@@ -356,7 +356,7 @@ static void coroae_wait_condvar(SV *cv) {
 
 static void coroae_loop() {
 
-	if (uwsgi.async < 2) {
+	if (uwsgi.async < 1) {
 		if (uwsgi.mywid == 1) {
 			uwsgi_log("the Coro::AnyEvent loop engine requires async mode (--async <n>)\n");
 		}
diff --git a/plugins/cplusplus/base.cc b/plugins/cplusplus/base.cc
index a04e602..f698024 100644
--- a/plugins/cplusplus/base.cc
+++ b/plugins/cplusplus/base.cc
@@ -28,7 +28,7 @@ extern "C" int uwsgi_cplusplus_request(struct wsgi_request *wsgi_req) {
 	FakeClass *fc;
 
 	// empty request ?
-	if (!wsgi_req->uh->pktsize) {
+	if (!wsgi_req->len) {
                 uwsgi_log( "Invalid request. skip.\n");
 		goto clear;
         }
diff --git a/plugins/echo/echo_plugin.c b/plugins/echo/echo_plugin.c
index a7e7248..961d813 100644
--- a/plugins/echo/echo_plugin.c
+++ b/plugins/echo/echo_plugin.c
@@ -4,7 +4,7 @@ extern struct uwsgi_server uwsgi;
 
 static int uwsgi_echo_request(struct wsgi_request *wsgi_req) {
 
-	return uwsgi_response_write_body_do(wsgi_req, wsgi_req->buffer, wsgi_req->uh->pktsize);
+	return uwsgi_response_write_body_do(wsgi_req, wsgi_req->buffer, wsgi_req->len);
 }
 
 struct uwsgi_plugin echo_plugin = {
diff --git a/plugins/emperor_amqp/amqp.c b/plugins/emperor_amqp/amqp.c
index 3f7ff7b..7b34c66 100644
--- a/plugins/emperor_amqp/amqp.c
+++ b/plugins/emperor_amqp/amqp.c
@@ -2,6 +2,13 @@
 
 #define AMQP_CONNECTION_HEADER "AMQP\0\0\x09\x01"
 
+#ifdef __BIG_ENDIAN__
+#define ntohll(x) x
+#else
+#define ntohll(x) ( ( (uint64_t)(ntohl( (uint32_t)((x << 32) >> 32) )) << 32) | ntohl( ((uint32_t)(x >> 32)) ) )     
+#endif
+#define htonll(x) ntohll(x)
+
 #define amqp_send(a, b, c) if (send(a, b, c, 0) < 0) { uwsgi_error("send()"); return -1; }
 
 struct amqp_frame_header {
@@ -62,8 +69,13 @@ static char *amqp_get_long(char *ptr, char *watermark, uint32_t *lv) {
 
 static char *amqp_get_longlong(char *ptr, char *watermark, uint64_t *llv) {
 
+        uint64_t tmp_longlong;
+
 	if (ptr+8 > watermark) return NULL;
-        *llv = uwsgi_be64(ptr);
+
+        memcpy(&tmp_longlong, ptr, 8);
+
+        *llv = ntohll(tmp_longlong);
         return ptr+8;
 }
 
@@ -73,29 +85,26 @@ static int amqp_send_ack(int fd, uint64_t delivery_tag) {
 
 	uint32_t size = 4 + 8 + 1;
 
-	struct uwsgi_buffer *ub = uwsgi_buffer_new(64);
+        size = htonl(size);
         // send type and channel
-	if (uwsgi_buffer_append(ub, "\1\0\1", 3)) goto end;
+        amqp_send(fd, "\1\0\1", 3);
         // send size
-	if (uwsgi_buffer_u32be(ub, size)) goto end;
-	// send class 60 method 80
-	if (uwsgi_buffer_append(ub, "\x00\x3C\x00\x50", 4)) goto end;
+        amqp_send(fd, &size, 4);
+
+        // send class 60 method 80
+        amqp_send(fd, "\x00\x3C\x00\x50", 4);
+
 	// set delivery_tag
-	if (uwsgi_buffer_u64be(ub, delivery_tag)) goto end;
-	if (uwsgi_buffer_append(ub, "\0\xCE", 2)) goto end;
+	delivery_tag = htonll(delivery_tag);
+	amqp_send(fd, &delivery_tag, 8);
 
-        // send buffer to socket
-        if (write(fd, ub->buf, ub->pos) < 0) {
-		uwsgi_error("amqp_send_ack()/write()");
-		goto end;
-	}
+        // empty bits
+        amqp_send(fd, "\0", 1);
 
+        // send frame-end
+        amqp_send(fd, "\xCE", 1);
 
-	uwsgi_buffer_destroy(ub);	
 	return 0;
-end:
-	uwsgi_buffer_destroy(ub);
-	return -1;
 }
 
 char *uwsgi_amqp_consume(int fd, uint64_t *msgsize, char **routing_key) {
diff --git a/plugins/emperor_mongodb/emperor_mongodb.cc b/plugins/emperor_mongodb/emperor_mongodb.cc
index 449f5d3..bb41fc3 100644
--- a/plugins/emperor_mongodb/emperor_mongodb.cc
+++ b/plugins/emperor_mongodb/emperor_mongodb.cc
@@ -24,7 +24,14 @@ extern "C" void uwsgi_imperial_monitor_mongodb(struct uwsgi_emperor_scanner *ues
 	try {
 
 		// requested fields
-        	mongo::BSONObj p = BSON( "name" << 1 << "config" << 1 << "ts" << 1 << "uid" << 1 << "gid" << 1 << "socket" << 1 );
+		mongo::BSONObjBuilder builder;
+        	builder.appendElements(BSON("name" << 1 << "config" << 1 << "ts" << 1 << "uid" << 1 << "gid" << 1 << "socket" << 1 ));
+		struct uwsgi_string_list *e_attrs = uwsgi.emperor_collect_attributes;
+		while(e_attrs) {
+			builder.appendElements(BSON(e_attrs->value << 1));
+			e_attrs = e_attrs->next;
+		}
+		mongo::BSONObj p = builder.obj();
 		mongo::BSONObj q = mongo::fromjson(uems->json);
 		// the connection object (will be automatically destroyed at each cycle)
 		mongo::DBClientConnection c;
@@ -76,7 +83,26 @@ extern "C" void uwsgi_imperial_monitor_mongodb(struct uwsgi_emperor_scanner *ues
 			const char *socket_name = p.getStringField("socket");
 			if (strlen(socket_name) == 0) socket_name = NULL;
 
-			uwsgi_emperor_simple_do(ues, (char *) name, (char *) config, vassal_ts/1000, vassal_uid, vassal_gid, (char *) socket_name);
+			struct uwsgi_dyn_dict *attrs = NULL;
+			struct uwsgi_string_list *e_attrs = uwsgi.emperor_collect_attributes;
+			while(e_attrs) {
+				const char *attr_value = p.getStringField(e_attrs->value);
+				if (strlen(attr_value) == 0) attr_value = NULL;
+				if (attr_value) {
+					// the value memory is always reallocated
+					char *value = uwsgi_str((char *)attr_value);
+					uwsgi_dyn_dict_new(&attrs, e_attrs->value, e_attrs->len, value, strlen(value));
+				}	
+				e_attrs = e_attrs->next;
+			}
+
+			if (attrs) {
+				// attrs will be freed in case of error
+				uwsgi_emperor_simple_do_with_attrs(ues, (char *) name, (char *) config, vassal_ts/1000, vassal_uid, vassal_gid, (char *) socket_name, attrs);
+			}
+			else {
+				uwsgi_emperor_simple_do(ues, (char *) name, (char *) config, vassal_ts/1000, vassal_uid, vassal_gid, (char *) socket_name);
+			}
 		}
 
 
diff --git a/plugins/emperor_mongodb/uwsgiplugin.py b/plugins/emperor_mongodb/uwsgiplugin.py
index 5d7810d..58b5675 100644
--- a/plugins/emperor_mongodb/uwsgiplugin.py
+++ b/plugins/emperor_mongodb/uwsgiplugin.py
@@ -5,7 +5,7 @@ NAME='emperor_mongodb'
 CFLAGS = ['-I/usr/include/mongo','-I/usr/local/include/mongo']
 LDFLAGS = []
 
-LIBS = []
+LIBS = ['-lstdc++']
 if not 'UWSGI_MONGODB_NOLIB' in os.environ:
     LIBS.append('-lmongoclient')
     LIBS.append('-lboost_thread')
diff --git a/plugins/fastrouter/fastrouter.c b/plugins/fastrouter/fastrouter.c
index b3037e3..ba2a217 100644
--- a/plugins/fastrouter/fastrouter.c
+++ b/plugins/fastrouter/fastrouter.c
@@ -9,6 +9,7 @@
 
 static struct uwsgi_fastrouter {
 	struct uwsgi_corerouter cr;
+	char *force_key;
 } ufr;
 
 extern struct uwsgi_server uwsgi;
@@ -16,8 +17,6 @@ extern struct uwsgi_server uwsgi;
 struct fastrouter_session {
 	struct corerouter_session session;
 	int has_key;
-	uint64_t content_length;
-	uint64_t buffered;
 };
 
 static struct uwsgi_option fastrouter_options[] = {
@@ -44,7 +43,7 @@ static struct uwsgi_option fastrouter_options[] = {
 
 	{"fastrouter-timeout", required_argument, 0, "set fastrouter timeout", uwsgi_opt_set_int, &ufr.cr.socket_timeout, 0},
 	{"fastrouter-post-buffering", required_argument, 0, "enable fastrouter post buffering", uwsgi_opt_set_64bit, &ufr.cr.post_buffering, 0},
-	{"fastrouter-post-buffering-dir", required_argument, 0, "put fastrouter buffered files to the specified directory (noop, use TMPDIR env)", uwsgi_opt_set_str, &ufr.cr.pb_base_dir, 0},
+	{"fastrouter-post-buffering-dir", required_argument, 0, "put fastrouter buffered files to the specified directory", uwsgi_opt_set_str, &ufr.cr.pb_base_dir, 0},
 
 	{"fastrouter-stats", required_argument, 0, "run the fastrouter stats server", uwsgi_opt_set_str, &ufr.cr.stats_server, 0},
 	{"fastrouter-stats-server", required_argument, 0, "run the fastrouter stats server", uwsgi_opt_set_str, &ufr.cr.stats_server, 0},
@@ -58,7 +57,9 @@ static struct uwsgi_option fastrouter_options[] = {
 
 	{"fastrouter-buffer-size", required_argument, 0, "set internal buffer size (default: page size)", uwsgi_opt_set_64bit, &ufr.cr.buffer_size, 0},
 	{"fastrouter-fallback-on-no-key", no_argument, 0, "move to fallback node even if a subscription key is not found", uwsgi_opt_true, &ufr.cr.fallback_on_no_key, 0},
-	{0, 0, 0, 0, 0, 0, 0},
+
+	{"fastrouter-force-key", required_argument, 0, "skip uwsgi parsing and directly set a key", uwsgi_opt_set_str, &ufr.force_key, 0},
+	UWSGI_END_OF_OPTIONS
 };
 
 static void fr_get_hostname(char *key, uint16_t keylen, char *val, uint16_t vallen, void *data) {
@@ -68,27 +69,21 @@ static void fr_get_hostname(char *key, uint16_t keylen, char *val, uint16_t vall
 
 	//uwsgi_log("%.*s = %.*s\n", keylen, key, vallen, val);
 	if (!uwsgi_strncmp("SERVER_NAME", 11, key, keylen) && !peer->key_len) {
-		if (vallen <= 0xff) {
-			memcpy(peer->key, val, vallen);
-			peer->key_len = vallen;
-		}
+		peer->key = val;
+		peer->key_len = vallen;
 		return;
 	}
 
 	if (!uwsgi_strncmp("HTTP_HOST", 9, key, keylen) && !fr->has_key) {
-		if (vallen <= 0xff) {
-                        memcpy(peer->key, val, vallen);
-                        peer->key_len = vallen;
-                }
+		peer->key = val;
+		peer->key_len = vallen;
 		return;
 	}
 
 	if (!uwsgi_strncmp("UWSGI_FASTROUTER_KEY", 20, key, keylen)) {
-		if (vallen <= 0xff) {
-			fr->has_key = 1;
-                        memcpy(peer->key, val, vallen);
-                        peer->key_len = vallen;
-		}
+		fr->has_key = 1;
+		peer->key = val;
+		peer->key_len = vallen;
 		return;
 	}
 
@@ -105,12 +100,6 @@ static void fr_get_hostname(char *key, uint16_t keylen, char *val, uint16_t vall
 		}
                 return;
         }
-
-	if (ufr.cr.post_buffering > 0) {
-		if (!uwsgi_strncmp("CONTENT_LENGTH", 14, key, keylen)) {
-			fr->content_length = uwsgi_str_num(val, vallen);
-		}
-	}
 }
 
 // writing client body to the instance
@@ -171,23 +160,6 @@ static ssize_t fr_instance_read(struct corerouter_peer *peer) {
         return len;
 }
 
-static ssize_t fr_instance_sendfile(struct corerouter_peer *peer) {
-	struct fastrouter_session *fr = (struct fastrouter_session *) peer->session;
-	ssize_t len = uwsgi_sendfile_do(peer->fd, peer->session->main_peer->buffering_fd, fr->buffered, fr->content_length - fr->buffered);
-	if (len < 0) {
-		cr_try_again;
-		uwsgi_cr_error(peer, "fr_instance_sendfile()/sendfile()");
-		return -1;
-	}
-	if (len == 0) return 0;
-	fr->buffered += len;
-	if (peer != peer->session->main_peer && peer->un) peer->un->rx+=len;
-	if (fr->buffered >= fr->content_length) {
-		cr_reset_hooks(peer);	
-	}
-	return len;
-}
-
 // send the uwsgi request header and vars
 static ssize_t fr_instance_send_request(struct corerouter_peer *peer) {
 	ssize_t len = cr_write(peer, "fr_instance_send_request()");
@@ -198,16 +170,9 @@ static ssize_t fr_instance_send_request(struct corerouter_peer *peer) {
         if (cr_write_complete(peer)) {
                 // reset the original read buffer
                 peer->out->pos = 0;
-		if (!peer->session->main_peer->is_buffering) {
-			// start waiting for body
-			peer->session->main_peer->last_hook_read = fr_read_body;
-                	cr_reset_hooks(peer);
-		}
-		else {
-			peer->hook_write = fr_instance_sendfile;
-			// stop reading from the client
-			peer->session->main_peer->last_hook_read = NULL;
-		}
+		// start waiting for body
+		peer->session->main_peer->last_hook_read = fr_read_body;
+                cr_reset_hooks(peer);
         }
 
 	return len;
@@ -222,8 +187,8 @@ static ssize_t fr_instance_connected(struct corerouter_peer *peer) {
 	peer->can_retry = 0;
 
 	// fix modifiers
-	peer->in->buf[0] = peer->modifier1;
-	peer->in->buf[3] = peer->modifier2;
+	peer->in->buf[0] = peer->session->main_peer->modifier1;
+	peer->in->buf[3] = peer->session->main_peer->modifier2;
 
 	// prepare to write the uwsgi packet
 	peer->out = peer->session->main_peer->in;
@@ -235,78 +200,31 @@ static ssize_t fr_instance_connected(struct corerouter_peer *peer) {
 
 // called after receaving the uwsgi header (read vars)
 static ssize_t fr_recv_uwsgi_vars(struct corerouter_peer *main_peer) {
-	struct fastrouter_session *fr = (struct fastrouter_session *) main_peer->session;
-
-	struct corerouter_peer *new_peer = NULL;
-	ssize_t len = 0;
-
 	struct uwsgi_header *uh = (struct uwsgi_header *) main_peer->in->buf;
 	// better to store it as the original buf address could change
-	uint16_t pktsize = uh->pktsize;
-
-	// are we buffering ?
-	if (main_peer->is_buffering) {
-		// memory or disk ?
-		if (fr->content_length <= ufr.cr.post_buffering) {
-			// increase buffer if needed
-        		if (uwsgi_buffer_fix(main_peer->in, pktsize+4+fr->content_length))
-                		return -1;
-        		len = cr_read_exact(main_peer, pktsize+4+fr->content_length, "fr_recv_uwsgi_vars()");
-        		if (!len) return 0;
-			// whole body read ?
-			if (main_peer->in->pos == (size_t)(pktsize+4+fr->content_length)) {
-				main_peer->is_buffering = 0;
-				goto done;
-			}
-			return len;
-		}
-		// first round ?
-		if (main_peer->buffering_fd == -1) {
-			main_peer->buffering_fd = uwsgi_tmpfd();
-			if (main_peer->buffering_fd < 0) return -1;
-		}
-		char buf[32768];
-		size_t remains = fr->content_length - fr->buffered;
-		ssize_t rlen = read(main_peer->fd, buf, UMIN(32768, remains));
-		if (rlen < 0) {
-			cr_try_again;
-			uwsgi_cr_error(main_peer, "fr_recv_uwsgi_vars()/read()");
-			return -1;
-		}
-		if (rlen == 0) return 0;
-		fr->buffered += rlen;
-		if (write(main_peer->buffering_fd, buf, rlen) != rlen) {
-			uwsgi_cr_error(main_peer, "fr_recv_uwsgi_vars()/write()");
-                        return -1;
-		}
-
-		// have we done ?
-		if (fr->buffered >= fr->content_length) {
-			fr->buffered = 0;
-			len = rlen;
-			goto done;
-		}
-
-		return rlen;
-	}
-
+	uint16_t pktsize = uh->_pktsize;
 	// increase buffer if needed
 	if (uwsgi_buffer_fix(main_peer->in, pktsize+4))
 		return -1;
-	len = cr_read_exact(main_peer, pktsize+4, "fr_recv_uwsgi_vars()");
+	ssize_t len = cr_read_exact(main_peer, pktsize+4, "fr_recv_uwsgi_vars()");
 	if (!len) return 0;
 
 	// headers received, ready to choose the instance
 	if (main_peer->in->pos == (size_t)(pktsize+4)) {
-
 		struct uwsgi_corerouter *ucr = main_peer->session->corerouter;
 
-		new_peer = uwsgi_cr_peer_add(main_peer->session);
+		struct corerouter_peer *new_peer = uwsgi_cr_peer_add(main_peer->session);
 		new_peer->last_hook_read = fr_instance_read;
 
-		// find the hostname
-		if (uwsgi_hooked_parse(main_peer->in->buf+4, pktsize, fr_get_hostname, (void *) new_peer)) {
-			return -1;
+		if (!ufr.force_key) {
+			// find the hostname
+			if (uwsgi_hooked_parse(main_peer->in->buf+4, pktsize, fr_get_hostname, (void *) new_peer)) {
+				return -1;
+			}
+		}
+		else {
+			new_peer->key = ufr.force_key;
+			new_peer->key_len = strlen(ufr.force_key);
 		}
 
 		// check the hostname;
@@ -328,18 +246,6 @@ static ssize_t fr_recv_uwsgi_vars(struct corerouter_peer *main_peer) {
 			return -1;
 		}
 
-		// buffering ?
-		if (ufr.cr.post_buffering > 0 && fr->content_length > 0) {
-			main_peer->is_buffering = 1;
-			main_peer->buffering_fd = -1;
-			return len;
-		}
-
-done:
-		if (!new_peer) {
-			new_peer = main_peer->session->peers;
-		}
-
 		new_peer->can_retry = 1;
 
 		cr_connect(new_peer, fr_instance_connected);
diff --git a/plugins/fiber/fiber.c b/plugins/fiber/fiber.c
index ca9191e..30603ae 100644
--- a/plugins/fiber/fiber.c
+++ b/plugins/fiber/fiber.c
@@ -83,7 +83,7 @@ static int fiber_init() {
 static void fiber_init_apps(void) {
 
         if (!ufiber.enabled) return;
-	if (uwsgi.async <= 1) {
+	if (uwsgi.async < 1) {
 		uwsgi_log("the fiber loop engine requires async mode\n");
 		exit(1);
 	}
diff --git a/plugins/forkptyrouter/forkptyrouter.c b/plugins/forkptyrouter/forkptyrouter.c
index db448ec..88ca3d9 100644
--- a/plugins/forkptyrouter/forkptyrouter.c
+++ b/plugins/forkptyrouter/forkptyrouter.c
@@ -16,14 +16,14 @@
 
 extern struct uwsgi_server uwsgi;
 
-#if defined(__linux__) || defined(__GNU_kFreeBSD__)
+#if defined(__linux__) || defined(__GNU_kFreeBSD__) || defined(__HURD__)
 #include <pty.h>
 #elif defined(__APPLE__) || defined(__OpenBSD__) || defined(__NetBSD__)
 #include <util.h>
-#elif defined(__FreeBSD__)
+#elif defined(__FreeBSD__) || defined(__DragonFly__)
 #include <libutil.h>
 #endif
-#ifndef __FreeBSD__
+#if !defined(__FreeBSD__) || !defined(__DragonFly__)
 #include <utmp.h>
 #endif
 
@@ -134,7 +134,7 @@ static ssize_t fpty_parse_uwsgi(struct corerouter_peer *peer) {
 	for(;;) {
 	if (peer->in->pos < 4) return 0;
 	struct uwsgi_header *uh = (struct uwsgi_header *) peer->in->buf;
-	uint16_t pktsize = uh->pktsize;
+	uint16_t pktsize = uh->_pktsize;
 	switch(uh->modifier2) {
 		case 0:
 			// stdin
diff --git a/plugins/forkptyrouter/uwsgiplugin.py b/plugins/forkptyrouter/uwsgiplugin.py
index 8872472..0bc8af4 100644
--- a/plugins/forkptyrouter/uwsgiplugin.py
+++ b/plugins/forkptyrouter/uwsgiplugin.py
@@ -1,7 +1,13 @@
+import os
+uwsgi_os = os.uname()[0]
+
 NAME='forkptyrouter'
 CFLAGS = []
 LDFLAGS = []
-LIBS = []
+if uwsgi_os in ('Linux', 'FreeBSD', 'GNU', 'NetBSD', 'DragonFly'):
+    LIBS = ['-lutil']
+else:
+    LIBS = []
 
 REQUIRES = ['corerouter']
 
diff --git a/plugins/gccgo/gccgo_plugin.c b/plugins/gccgo/gccgo_plugin.c
index d2aa4ee..09cfd69 100644
--- a/plugins/gccgo/gccgo_plugin.c
+++ b/plugins/gccgo/gccgo_plugin.c
@@ -222,7 +222,7 @@ static int uwsgi_gccgo_request(struct wsgi_request *wsgi_req) {
 		goto end;
 	}
 	/* Standard GO request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log("Empty GO request. skip.\n");
                 return -1;
         }
@@ -342,7 +342,7 @@ static void uwsgi_gccgo_signal_goroutine(void *arg) {
 	for(;;) {
 		runtime_pollWait(pdesc, 'r');
 retry:
-		uwsgi_receive_signal(*fd, "worker", uwsgi.mywid);
+		uwsgi_receive_signal(NULL, *fd, "worker", uwsgi.mywid);
 		if (uwsgi_is_again()) continue;
 		goto retry;
 	}
@@ -389,7 +389,7 @@ retry:
 
 		// enter harakiri mode
 		if (uwsgi.harakiri_options.workers > 0) {
-                	set_harakiri(uwsgi.harakiri_options.workers);
+                	set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
         	}
 
 		// spawn the new goroutine
diff --git a/plugins/gevent/gevent.c b/plugins/gevent/gevent.c
index 9838ef5..7fd455f 100644
--- a/plugins/gevent/gevent.c
+++ b/plugins/gevent/gevent.c
@@ -19,6 +19,7 @@ static void uwsgi_opt_setup_gevent(char *opt, char *value, void *null) {
 static struct uwsgi_option gevent_options[] = {
         {"gevent", required_argument, 0, "a shortcut enabling gevent loop engine with the specified number of async cores and optimal parameters", uwsgi_opt_setup_gevent, NULL, UWSGI_OPT_THREADS},
         {"gevent-monkey-patch", no_argument, 0, "call gevent.monkey.patch_all() automatically on startup", uwsgi_opt_true, &ugevent.monkey, 0},
+        {"gevent-early-monkey-patch", no_argument, 0, "call gevent.monkey.patch_all() automatically before app loading", uwsgi_opt_true, &ugevent.early_monkey, 0},
         {"gevent-wait-for-hub", no_argument, 0, "wait for gevent hub's death instead of the control greenlet", uwsgi_opt_true, &ugevent.wait_for_hub, 0},
         {0, 0, 0, 0, 0, 0, 0},
 
@@ -100,31 +101,6 @@ retry:
 	return Py_None;
 }
 
-PyObject *py_uwsgi_gevent_int(PyObject *self, PyObject *args) {
-
-        uwsgi_log("Brutally killing worker %d (pid: %d)...\n", uwsgi.mywid, uwsgi.mypid);
-        uwsgi.workers[uwsgi.mywid].manage_next_request = 0;
-
-        uwsgi_log_verbose("stopping gevent signals watchers for worker %d (pid: %d)...\n", uwsgi.mywid, uwsgi.mypid);
-        PyObject_CallMethod(ugevent.my_signal_watcher, "stop", NULL);
-        PyObject_CallMethod(ugevent.signal_watcher, "stop", NULL);
-
-        uwsgi_log_verbose("stopping gevent sockets watchers for worker %d (pid: %d)...\n", uwsgi.mywid, uwsgi.mypid);
-        int i,count = uwsgi_count_sockets(uwsgi.sockets);
-        for(i=0;i<count;i++) {
-                PyObject_CallMethod(ugevent.watchers[i], "stop", NULL);
-        }
-        uwsgi_log_verbose("main gevent watchers stopped for worker %d (pid: %d)...\n", uwsgi.mywid, uwsgi.mypid);
-
-        if (!ugevent.wait_for_hub) {
-                PyObject_CallMethod(ugevent.ctrl_gl, "kill", NULL);
-        }
-
-        Py_INCREF(Py_None);
-        return Py_None;
-}
-
-
 static void uwsgi_gevent_gbcw() {
 
 	// already running
@@ -165,7 +141,7 @@ PyObject *py_uwsgi_gevent_signal_handler(PyObject * self, PyObject * args) {
         	return NULL;
 	}
 
-	uwsgi_receive_signal(signal_socket, "worker", uwsgi.mywid);
+	uwsgi_receive_signal(NULL, signal_socket, "worker", uwsgi.mywid);
 
 	Py_INCREF(Py_None);
 	return Py_None;
@@ -205,12 +181,14 @@ PyObject *py_uwsgi_gevent_main(PyObject * self, PyObject * args) {
 	// hack to retrieve the socket address
 	PyObject *py_uwsgi_sock = PyTuple_GetItem(args, 0);
         struct uwsgi_socket *uwsgi_sock = (struct uwsgi_socket *) PyLong_AsLong(py_uwsgi_sock);
+        long watcher_index = PyInt_AsLong(PyTuple_GetItem(args, 1));
 	struct wsgi_request *wsgi_req = NULL;
 edge:
 	wsgi_req = find_first_available_wsgi_req();
 
 	if (wsgi_req == NULL) {
 		uwsgi_async_queue_is_full(uwsgi_now());
+                PyObject_CallMethod(ugevent.watchers[watcher_index], "stop", NULL);
 		goto clear;
 	}
 
@@ -236,7 +214,7 @@ edge:
 
 	// enter harakiri mode
         if (uwsgi.harakiri_options.workers > 0) {
-                set_harakiri(uwsgi.harakiri_options.workers);
+                set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
         }
 
 	// hack to easily pass wsgi_req pointer to the greenlet
@@ -258,6 +236,10 @@ clear:
 	return Py_None;
 }
 
+PyObject *uwsgi_gevent_main;
+void start_watcher(int i, struct uwsgi_socket* uwsgi_sock) {
+        PyObject_CallMethod(ugevent.watchers[i], "start", "Oli", uwsgi_gevent_main,(long)uwsgi_sock, i);
+}
 
 PyObject *py_uwsgi_gevent_request(PyObject * self, PyObject * args) {
 
@@ -274,7 +256,7 @@ PyObject *py_uwsgi_gevent_request(PyObject * self, PyObject * args) {
 	if (wsgi_req->socket->edge_trigger) {
 		int status = wsgi_req->socket->proto(wsgi_req);
 		if (status < 0) {
-			goto end2;
+			goto end;
 		}
 		goto request;
 	}
@@ -319,7 +301,7 @@ end:
 	if (greenlet_switch) {
 		Py_DECREF(greenlet_switch);
 	}
-end2:
+
 	Py_DECREF(current_greenlet);
 
 	uwsgi_close_request(wsgi_req);
@@ -329,22 +311,34 @@ end2:
 	if (uwsgi.workers[uwsgi.mywid].manage_next_request == 0) {
 		int running_cores = 0;
 		int i;
-          for(i=0;i<uwsgi.async;i++) {
-            if (uwsgi.workers[uwsgi.mywid].cores[i].in_request) {
-              running_cores++;
-            }
-          }
-
-          if (running_cores == 0) {
-            // no need to worry about freeing memory
-            PyObject *uwsgi_dict = get_uwsgi_pydict("uwsgi");
-            if (uwsgi_dict) {
-              PyObject *ae = PyDict_GetItemString(uwsgi_dict, "atexit");
-              if (ae) {
-                python_call(ae, PyTuple_New(0), 0, NULL);
-              }
-            }
-          }
+                for(i=0;i<uwsgi.async;i++) {
+                        if (uwsgi.workers[uwsgi.mywid].cores[i].in_request) {
+                                running_cores++;
+                        }
+                }
+
+                if (running_cores == 0) {
+                        // no need to worry about freeing memory
+                        PyObject *uwsgi_dict = get_uwsgi_pydict("uwsgi");
+                        if (uwsgi_dict) {
+                                PyObject *ae = PyDict_GetItemString(uwsgi_dict, "atexit");
+                                if (ae) {
+                                        python_call(ae, PyTuple_New(0), 0, NULL);
+                                }
+                        }
+                }
+        } else {
+                // If we stopped any watcher due to being out of async workers, restart it.
+                int i = 0;
+                struct uwsgi_socket *uwsgi_sock = uwsgi.sockets;
+                for (; uwsgi_sock; uwsgi_sock = uwsgi_sock->next, ++i) {
+                        PyObject *py_watcher_active = PyObject_GetAttrString(ugevent.watchers[i], "active");
+                        if (py_watcher_active && PyBool_Check(py_watcher_active) &&
+                            !PyInt_AsLong(py_watcher_active)) {
+                            start_watcher(i, uwsgi_sock);
+                        }
+                        Py_DECREF(py_watcher_active);
+                }
         }
 
 	Py_INCREF(Py_None);
@@ -358,7 +352,6 @@ PyMethodDef uwsgi_gevent_signal_def[] = { {"uwsgi_gevent_signal", py_uwsgi_geven
 PyMethodDef uwsgi_gevent_my_signal_def[] = { {"uwsgi_gevent_my_signal", py_uwsgi_gevent_my_signal, METH_VARARGS, ""} };
 PyMethodDef uwsgi_gevent_signal_handler_def[] = { {"uwsgi_gevent_signal_handler", py_uwsgi_gevent_signal_handler, METH_VARARGS, ""} };
 PyMethodDef uwsgi_gevent_unix_signal_handler_def[] = { {"uwsgi_gevent_unix_signal_handler", py_uwsgi_gevent_graceful, METH_VARARGS, ""} };
-PyMethodDef uwsgi_gevent_unix_signal_int_handler_def[] = { {"uwsgi_gevent_unix_signal_int_handler", py_uwsgi_gevent_int, METH_VARARGS, ""} };
 PyMethodDef uwsgi_gevent_ctrl_gl_def[] = { {"uwsgi_gevent_ctrl_gl_handler", py_uwsgi_gevent_ctrl_gl, METH_VARARGS, ""} };
 
 static void gil_gevent_get() {
@@ -369,6 +362,14 @@ static void gil_gevent_release() {
 	PyGILState_Release((PyGILState_STATE) pthread_getspecific(up.upt_gil_key));
 }
 
+static void monkey_patch() {
+	PyObject *gevent_monkey_dict = get_uwsgi_pydict("gevent.monkey");
+        if (!gevent_monkey_dict) uwsgi_pyexit;
+        PyObject *gevent_monkey_patch_all = PyDict_GetItemString(gevent_monkey_dict, "patch_all");
+        if (!gevent_monkey_patch_all) uwsgi_pyexit;
+        PyObject *ret = python_call(gevent_monkey_patch_all, PyTuple_New(0), 0, NULL);
+        if (!ret) uwsgi_pyexit;
+}
 static void gevent_loop() {
 
 	// ensure SIGPIPE is ignored
@@ -394,7 +395,7 @@ static void gevent_loop() {
 
 	struct uwsgi_socket *uwsgi_sock = uwsgi.sockets;
 
-	if (uwsgi.async < 2) {
+	if (uwsgi.async < 1) {
 		uwsgi_log("the gevent loop engine requires async mode (--async <n>)\n");
 		exit(1);
 	}
@@ -414,12 +415,7 @@ static void gevent_loop() {
 
 	// call gevent.monkey.patch_all() if requested
 	if (ugevent.monkey) {
-		PyObject *gevent_monkey_dict = get_uwsgi_pydict("gevent.monkey");
-		if (!gevent_monkey_dict) uwsgi_pyexit;
-		PyObject *gevent_monkey_patch_all = PyDict_GetItemString(gevent_monkey_dict, "patch_all");
-        	if (!gevent_monkey_patch_all) uwsgi_pyexit;
-		PyObject *ret = python_call(gevent_monkey_patch_all, PyTuple_New(0), 0, NULL);
-		if (!ret) uwsgi_pyexit;
+		monkey_patch();
 	}
 
 	ugevent.spawn = PyDict_GetItemString(gevent_dict, "spawn");
@@ -450,7 +446,7 @@ static void gevent_loop() {
 	if (!ugevent.hub_loop) uwsgi_pyexit;
 
 	// main greenlet waiting for connection (one greenlet per-socket)
-	PyObject *uwsgi_gevent_main = PyCFunction_New(uwsgi_gevent_main_def, NULL);
+	uwsgi_gevent_main = PyCFunction_New(uwsgi_gevent_main_def, NULL);
 	Py_INCREF(uwsgi_gevent_main);
 
 	// greenlet to run at each request
@@ -497,7 +493,7 @@ static void gevent_loop() {
 		if (!ugevent.watchers[i]) uwsgi_pyexit;
 	
 		// start the main greenlet
-		PyObject_CallMethod(ugevent.watchers[i], "start", "Ol", uwsgi_gevent_main,(long)uwsgi_sock);
+		start_watcher(i, uwsgi_sock);
 		uwsgi_sock = uwsgi_sock->next;
 		i++;
 	}
@@ -514,22 +510,6 @@ static void gevent_loop() {
 
 	python_call(ugevent.signal, ge_signal_tuple, 0, NULL);
 
-	// map SIGINT/SIGTERM with gevent.signal
-	ge_signal_tuple = PyTuple_New(2);
-	PyTuple_SetItem(ge_signal_tuple, 0, PyInt_FromLong(SIGINT));
-	PyObject *uwsgi_gevent_unix_signal_int_handler = PyCFunction_New(uwsgi_gevent_unix_signal_int_handler_def, NULL);
-        Py_INCREF(uwsgi_gevent_unix_signal_int_handler);
-	PyTuple_SetItem(ge_signal_tuple, 1, uwsgi_gevent_unix_signal_int_handler);
-	python_call(ugevent.signal, ge_signal_tuple, 0, NULL);
-
-	ge_signal_tuple = PyTuple_New(2);
-	PyTuple_SetItem(ge_signal_tuple, 0, PyInt_FromLong(SIGTERM));
-	PyTuple_SetItem(ge_signal_tuple, 1, uwsgi_gevent_unix_signal_int_handler);
-	python_call(ugevent.signal, ge_signal_tuple, 0, NULL);
-
-
-
-
 	PyObject *wait_for_me = ugevent.hub;
 
 	if (!ugevent.wait_for_hub) {
@@ -573,8 +553,14 @@ static void gevent_loop() {
 
 }
 
-static void gevent_init() {
+static void gevent_preinit_apps() {
+	// call gevent.monkey.patch_all() if requested
+        if (ugevent.early_monkey) {
+                monkey_patch();
+        }
+}
 
+static void gevent_init() {
 	uwsgi_register_loop( (char *) "gevent", gevent_loop);
 }
 
@@ -583,5 +569,6 @@ struct uwsgi_plugin gevent_plugin = {
 
 	.name = "gevent",
 	.options = gevent_options,
+	.preinit_apps = gevent_preinit_apps,
 	.on_load = gevent_init,
 };
diff --git a/plugins/gevent/gevent.h b/plugins/gevent/gevent.h
index f7687d8..c39034e 100644
--- a/plugins/gevent/gevent.h
+++ b/plugins/gevent/gevent.h
@@ -56,5 +56,6 @@ struct uwsgi_gevent {
 	int destroy;
 	int monkey;
 	int wait_for_hub;
+	int early_monkey;
 };
 
diff --git a/plugins/glusterfs/glusterfs.c b/plugins/glusterfs/glusterfs.c
index 92616b6..bab76c7 100644
--- a/plugins/glusterfs/glusterfs.c
+++ b/plugins/glusterfs/glusterfs.c
@@ -213,7 +213,7 @@ static void uwsgi_glusterfs_setup() {
 static int uwsgi_glusterfs_request(struct wsgi_request *wsgi_req) {
 	char filename[PATH_MAX+1];
 	/* Standard GlusterFS request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log( "Empty GlusterFS request. skip.\n");
                 return -1;
         }
@@ -270,7 +270,7 @@ static int uwsgi_glusterfs_request(struct wsgi_request *wsgi_req) {
 	// skip body on HEAD
 	if (uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "HEAD", 4)) {
 		size_t remains = st.st_size;
-		if (uwsgi.async > 1) {
+		if (uwsgi.async > 0) {
 			if (uwsgi_glusterfs_read_async(wsgi_req, fd, remains)) goto end;
 		}
 		else {
diff --git a/plugins/greenlet/greenlet.c b/plugins/greenlet/greenlet.c
index f494a3b..7c69fa8 100644
--- a/plugins/greenlet/greenlet.c
+++ b/plugins/greenlet/greenlet.c
@@ -116,7 +116,7 @@ static void greenlet_init_apps(void) {
 
 	if (!ugl.enabled) return;
 
-	if (uwsgi.async <= 1) {
+	if (uwsgi.async < 1) {
                 uwsgi_log("the greenlet suspend engine requires async mode\n");
                 exit(1);
         }
diff --git a/plugins/gridfs/gridfs.cc b/plugins/gridfs/gridfs.cc
index d11451a..b9c0e24 100644
--- a/plugins/gridfs/gridfs.cc
+++ b/plugins/gridfs/gridfs.cc
@@ -193,7 +193,7 @@ extern "C" int uwsgi_gridfs_request(struct wsgi_request *wsgi_req) {
         char *itemname = NULL;
 
         /* Standard GridFS request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log( "Empty GridFS request. skip.\n");
                 return -1;
         }
diff --git a/plugins/http/common.h b/plugins/http/common.h
index de61b26..fb46663 100644
--- a/plugins/http/common.h
+++ b/plugins/http/common.h
@@ -46,7 +46,9 @@ struct uwsgi_http {
 	int connect_timeout;
 	int manage_source;
 	int enable_proxy_protocol;
-	int chunked_input;
+
+	int proto_http;
+
 	int manage_rtsp;
 }; 
 
@@ -136,8 +138,12 @@ struct http_session {
 
 	ssize_t (*func_write)(struct corerouter_peer *);
 
-	int is_rtsp;
+	char *proxy_src;
+        char *proxy_src_port;
+        uint16_t proxy_src_len;
+        uint16_t proxy_src_port_len;
 
+	int is_rtsp;
 };
 
 
diff --git a/plugins/http/http.c b/plugins/http/http.c
index e3a03d8..19f8262 100644
--- a/plugins/http/http.c
+++ b/plugins/http/http.c
@@ -42,8 +42,6 @@ struct uwsgi_option http_options[] = {
 	{"http-raw-body", no_argument, 0, "blindly send HTTP body to backends (required for WebSockets and Icecast support in backends)", uwsgi_opt_true, &uhttp.raw_body, 0},
 	{"http-websockets", no_argument, 0, "automatically detect websockets connections and put the session in raw mode", uwsgi_opt_true, &uhttp.websockets, 0},
 
-	{"http-chunked-input", no_argument, 0, "automatically detect chunked input requests and put the session in raw mode", uwsgi_opt_true, &uhttp.chunked_input, 0},
-
 	{"http-use-code-string", required_argument, 0, "use code string as hostname->server mapper for the http router", uwsgi_opt_corerouter_cs, &uhttp, 0},
         {"http-use-socket", optional_argument, 0, "forward request to the specified uwsgi socket", uwsgi_opt_corerouter_use_socket, &uhttp, 0},
         {"http-gracetime", required_argument, 0, "retry connections to dead static nodes after the specified amount of seconds", uwsgi_opt_set_int, &uhttp.cr.static_node_gracetime, 0},
@@ -66,17 +64,129 @@ struct uwsgi_option http_options[] = {
 	{"http-connect-timeout", required_argument, 0, "set internal http socket timeout for backend connections", uwsgi_opt_set_int, &uhttp.connect_timeout, 0},
 
 	{"http-manage-source", no_argument, 0, "manage the SOURCE HTTP method placing the session in raw mode", uwsgi_opt_true, &uhttp.manage_source, 0},
-	{"http-manage-rtsp", no_argument, 0, "manage RTSP sessions", uwsgi_opt_true, &uhttp.manage_rtsp, 0},
 	{"http-enable-proxy-protocol", optional_argument, 0, "manage PROXY protocol requests", uwsgi_opt_true, &uhttp.enable_proxy_protocol, 0},
+
+	{"http-backend-http", no_argument, 0, "use plain http protocol instead of uwsgi for backend nodes", uwsgi_opt_true, &uhttp.proto_http, 0},
+
+	{"http-manage-rtsp", no_argument, 0, "manage RTSP sessions", uwsgi_opt_true, &uhttp.manage_rtsp, 0},
 	{0, 0, 0, 0, 0, 0, 0},
 };
 
+static int rebuild_key_for_mountpoint(struct http_session *hr, struct corerouter_peer *peer) {
+	if (hr->request_uri_len == 0) return -1;
+	if (hr->request_uri[0] != '/') return -1;
+	uint16_t uri_len = hr->request_uri_len -1;
+	// find QUERY_STRING (if any)
+	char *qs = memchr(hr->request_uri+1, '?', uri_len);
+	if (qs) {
+		uri_len = (qs - hr->request_uri) - 1;
+	}
+	// is it / ?
+	if (uri_len == 0) return 0;
+	// now find the second slash occurrence (if any)
+	char *second_slash = memchr(hr->request_uri+1, '/', uri_len);
+	char *new_key = NULL;
+	uint16_t new_key_len = 0;
+	if (second_slash) {
+		new_key = uwsgi_concat2n(peer->key, peer->key_len, hr->request_uri, second_slash - hr->request_uri);	
+		new_key_len = peer->key_len + (second_slash - hr->request_uri);
+	}
+	else {
+		new_key = uwsgi_concat2n(peer->key, peer->key_len, hr->request_uri, uri_len + 1);
+		new_key_len = peer->key_len + uri_len + 1;
+	}
+	peer->key = new_key;
+	peer->key_len = new_key_len;
+	peer->free_key = 1;
+	return 0;
+}
+
 static void http_set_timeout(struct corerouter_peer *peer, int timeout) {
 	if (peer->current_timeout == timeout) return;
 	peer->current_timeout = timeout;
 	peer->timeout = corerouter_reset_timeout(peer->session->corerouter, peer);
 }
 
+static int http_header_dumb_check(struct http_session *hr, struct corerouter_peer *peer, char *hh, size_t hhlen) {
+	size_t i;
+        char *val = hh;
+        int status = 0;
+	uint16_t keylen = 0;
+	uint16_t vallen = 0;
+        for (i = 0; i < hhlen; i++) {
+                if (!status) {
+                        if (hh[i] == ':') {
+                                status = 1;
+                                keylen = i;
+                        }
+                }
+                else if (status == 1 && hh[i] != ' ') {
+                        status = 2;
+                        val += i;
+                        vallen+=1;
+                }
+                else if (status == 2) {
+                        vallen+=1;
+                }
+        }
+
+	if (!keylen) return -1;
+
+	if (hr->websockets) {
+                if (!uwsgi_strnicmp("UPGRADE", 7, hh, keylen)) {
+                        if (!uwsgi_strncmp(val, vallen, "websocket", 9)) {
+                                hr->websockets++;
+                        }
+			return 0;
+                }
+                else if (!uwsgi_strncmp("CONNECTION", 10, hh, keylen)) {
+                        if (!uwsgi_strnicmp(val, vallen, "Upgrade", 7)) {
+                                hr->websockets++;
+                        }
+			return 0;
+                }
+                else if (!uwsgi_strnicmp("SEC-WEBSOCKET-VERSION", 21, hh, keylen)) {
+                        hr->websockets++;
+			return 0;
+                }
+                else if (!uwsgi_strnicmp("SEC-WEBSOCKET-KEY", 17, hh, keylen)) {
+                        hr->websocket_key = val;
+                        hr->websocket_key_len = vallen;
+			return 0;
+                }
+        }
+
+
+        if (!uwsgi_strnicmp("CONTENT-LENGTH", 14, hh, keylen)) {
+                hr->content_length = uwsgi_str_num(val, vallen);
+        }
+
+        // in the future we could support chunked requests...
+        else if (!uwsgi_strnicmp("TRANSFER_ENCODING", 17, hh, keylen)) {
+                hr->session.can_keepalive = 0;
+        }
+
+        else if (!uwsgi_strnicmp("CONNECTION", 10, hh, keylen)) {
+                if (!uwsgi_strnicmp(val, vallen, "close", 5) || !uwsgi_strnicmp(val, vallen, "upgrade", 7)) {
+                        hr->session.can_keepalive = 0;
+                }
+        }
+        else if (peer->key == uwsgi.hostname && hr->raw_body && !uwsgi_strnicmp("ICE-URL", 7, hh, keylen)) {
+                peer->key = val;
+                peer->key_len = vallen;
+        }
+
+#ifdef UWSGI_ZLIB
+        else if (uhttp.auto_gzip && !uwsgi_strnicmp("ACCEPT-ENCODING", 15, hh, keylen)) {
+                if ( uwsgi_contains_n(val, vallen, "gzip", 4) ) {
+                        hr->can_gzip = 1;
+                }
+        }
+#endif
+
+	return 0;
+}
+
 static char * http_header_to_cgi(char *hh, size_t hhlen, size_t *keylen, size_t *vallen, int *has_prefix) {
 	size_t i;
 	char *val = hh;
@@ -141,14 +251,7 @@ static int http_add_uwsgi_header(struct corerouter_peer *peer, char *hh, size_t
 	}	
 
 	if (!uwsgi_strncmp("HOST", 4, hh, keylen)) {
-		if (vallen <= 0xff) {
-			memcpy(peer->key, val, vallen);
-			peer->key_len = vallen;
-			if (uhttp.server_name_as_http_host && uwsgi_buffer_append_keyval(out, "SERVER_NAME", 11, peer->key, peer->key_len)) return -1;
-		}
-		else {
-			return -1;
-		}
+		if (uhttp.server_name_as_http_host && uwsgi_buffer_append_keyval(out, "SERVER_NAME", 11, peer->key, peer->key_len)) return -1;
 	}
 
 	else if (!uwsgi_strncmp("CONTENT_LENGTH", 14, hh, keylen)) {
@@ -158,11 +261,6 @@ static int http_add_uwsgi_header(struct corerouter_peer *peer, char *hh, size_t
 	// in the future we could support chunked requests...
 	else if (!uwsgi_strncmp("TRANSFER_ENCODING", 17, hh, keylen)) {
 		hr->session.can_keepalive = 0;
-		if (uhttp.chunked_input) {
-			if (!uwsgi_strnicmp(val, vallen, "chunked", 7)) {
-				hr->raw_body = 1;
-			} 
-		}
 	}
 
 	else if (!uwsgi_strncmp("CONNECTION", 10, hh, keylen)) {
@@ -171,10 +269,8 @@ static int http_add_uwsgi_header(struct corerouter_peer *peer, char *hh, size_t
 		}
 	}
 	else if (peer->key == uwsgi.hostname && hr->raw_body && !uwsgi_strncmp("ICE_URL", 7, hh, keylen)) {
-		if (vallen <= 0xff) {
-                        memcpy(peer->key, val, vallen);
-                        peer->key_len = vallen;
-		}
+		peer->key = val;
+		peer->key_len = vallen;
 	}
 
 #ifdef UWSGI_ZLIB
@@ -202,23 +298,262 @@ done:
 	return 0;
 }
 
+static int http_headers_parse_first_round(struct corerouter_peer *peer) {
+        struct http_session *hr = (struct http_session *) peer->session;
+	char *ptr = peer->session->main_peer->in->buf;
+        char *watermark = ptr + hr->headers_size;
+        char *base = ptr;
+        char *proxy_dst = NULL;
+        char *proxy_dst_port = NULL;
+        uint16_t proxy_dst_len = 0;
+        uint16_t proxy_dst_port_len = 0;
+
+	int skip = 0;
+
+	//struct uwsgi_buffer *out = peer->out;
+        int found = 0;
+
+        if (uwsgi.enable_proxy_protocol || uhttp.enable_proxy_protocol) {
+                ptr = proxy1_parse(ptr, watermark, &hr->proxy_src, &hr->proxy_src_len, &proxy_dst, &proxy_dst_len, &hr->proxy_src_port, &hr->proxy_src_port_len, &proxy_dst_port, &proxy_dst_port_len);
+		// how many bytes to skip ?
+		skip = ptr - base;
+                base = ptr;
+        }
+
+	// the following code is only a check for http compliance
+
+        // METHOD
+        while (ptr < watermark) {
+                if (*ptr == ' ') {
+                        ptr++;
+                        found = 1;
+                        break;
+                }
+                else if (*ptr == '\r' || *ptr == '\n') break;
+                ptr++;
+        }
+
+        // ensure we have a method
+        if (!found) return -1;
+
+	// REQUEST_URI / PATH_INFO / QUERY_STRING
+        base = ptr;
+        found = 0;
+        while (ptr < watermark) {
+                if (*ptr == ' ') {
+			// if we want to allow sub-keys, we need to parse the first part of the REQUEST_URI
+                        hr->request_uri = base;
+                        hr->request_uri_len = ptr - base;
+                        ptr++;
+                        found = 1;
+                        break;
+                }
+                ptr++;
+        }
+
+        // ensure we have a URI
+        if (!found) return -1;
+
+        // SERVER_PROTOCOL
+        base = ptr;
+        found = 0;
+        while (ptr < watermark) {
+                if (*ptr == '\r') {
+                        if (ptr + 1 >= watermark)
+                                return 0;
+                        if (*(ptr + 1) != '\n')
+                                return 0;
+                        ptr += 2;
+                        found = 1;
+                        break;
+                }
+                ptr++;
+        }
+
+        // ensure we have a protocol
+        if (!found) return -1;
+
+        peer->key = uwsgi.hostname;
+        peer->key_len = uwsgi.hostname_len;
+
+        //HEADERS
+        base = ptr;
+        while (ptr < watermark) {
+                if (*ptr == '\r') {
+                        if (ptr + 1 >= watermark)
+                                break;
+                        if (*(ptr + 1) != '\n')
+                                break;
+                        // multiline header ?
+                        if (ptr + 2 < watermark) {
+                                if (*(ptr + 2) == ' ' || *(ptr + 2) == '\t') {
+                                        ptr += 2;
+                                        continue;
+                                }
+                        }
+
+                        if ((ptr - base) > 6 && !uwsgi_strnicmp("HOST: ", 6, base, 6)) {
+				peer->key = base + 6;
+				peer->key_len = (ptr - base) - 6;
+                        }
+
+                        // last line, do not waste time
+                        if (ptr - base == 0) break;
+                        ptr++;
+                        base = ptr + 1;
+                }
+                ptr++;
+        }
+
+	return skip;
+}
+
+static int http_headers_parse_dumb(struct corerouter_peer *peer, int skip) {
+	struct http_session *hr = (struct http_session *) peer->session;
+	char *ptr = peer->session->main_peer->in->buf;
+        char *watermark = ptr + hr->headers_size;
+        char *base = ptr + skip;
+
+	// leave space for X-Forwarded-For and X-Forwarded-Proto: https
+	peer->out = uwsgi_buffer_new(hr->headers_size + 256);
+        // force this buffer to be destroyed as soon as possibile
+        peer->out_need_free = 1;
+        peer->out->limit = UMAX16;
+        peer->out_pos = 0;
+
+        //struct uwsgi_buffer *out = peer->out;
+        int found = 0;
+
+	// the following code is only a check for http compliance
+
+	// METHOD
+	while (ptr < watermark) {
+                if (*ptr == ' ') {
+                        // on SOURCE METHOD, force raw body
+                        if (uhttp.manage_source && !uwsgi_strncmp(base, ptr - base, "SOURCE", 6)) {
+                                hr->raw_body = 1;
+                        }
+                        ptr++;
+                        found = 1;
+                        break;
+                }
+                else if (*ptr == '\r' || *ptr == '\n') break;
+                ptr++;
+        }
+
+        // ensure we have a method
+        if (!found) return -1;
 
-int http_headers_parse(struct corerouter_peer *peer) {
+	// REQUEST_URI / PATH_INFO / QUERY_STRING
+        base = ptr;
+        found = 0;
+        while (ptr < watermark) {
+                if (*ptr == ' ') {
+                        ptr++;
+                        found = 1;
+                        break;
+                }
+                ptr++;
+        }
+
+        // ensure we have a URI
+        if (!found) return -1;
+
+	// SERVER_PROTOCOL
+        base = ptr;
+        found = 0;
+        while (ptr < watermark) {
+                if (*ptr == '\r') {
+                        if (ptr + 1 >= watermark)
+                                return 0;
+                        if (*(ptr + 1) != '\n')
+                                return 0;
+                        if (uhttp.keepalive && !uwsgi_strncmp("HTTP/1.1", 8, base, ptr-base)) {
+                                hr->session.can_keepalive = 1;
+                        }
+			if (uhttp.manage_rtsp && !uwsgi_strncmp("RTSP/1.0", 8, base, ptr-base)) {
+                                hr->session.can_keepalive = 1;
+				hr->is_rtsp = 1;
+			}
+                        ptr += 2;
+                        found = 1;
+                        break;
+                }
+                ptr++;
+        }
+
+        // ensure we have a protocol
+        if (!found) return -1;
+
+	//HEADERS
+        base = ptr;
+        while (ptr < watermark) {
+                if (*ptr == '\r') {
+                        if (ptr + 1 >= watermark)
+                                break;
+                        if (*(ptr + 1) != '\n')
+                                break;
+                        // multiline header ?
+                        if (ptr + 2 < watermark) {
+                                if (*(ptr + 2) == ' ' || *(ptr + 2) == '\t') {
+                                        ptr += 2;
+                                        continue;
+                                }
+                        }
+
+                        // this is an hack with dumb/wrong/useless error checking
+                        if (uhttp.manage_expect) {
+                                if (!uwsgi_strncmp("Expect: 100-continue", 20, base, ptr - base)) {
+                                        hr->send_expect_100 = 1;
+                                }
+                        }
+                        // last line, do not waste time
+                        if (ptr - base == 0) break;
+			if (http_header_dumb_check(hr, peer, base, ptr - base)) return -1;
+                        ptr++;
+                        base = ptr + 1;
+                }
+                ptr++;
+        }
+
+	struct uwsgi_buffer *out = peer->out;
+	if (uwsgi_buffer_append(out, peer->session->main_peer->in->buf, hr->headers_size-1)) return -1;
+
+	// X-Forwarded-For
+        if (uwsgi_buffer_append(out, "X-Forwarded-For: ", 17)) return -1;
+        if (hr->proxy_src) {
+		if (uwsgi_buffer_append(out, hr->proxy_src, hr->proxy_src_len)) return -1;
+        }
+        else {
+                if (uwsgi_buffer_append(out, peer->session->client_address, strlen(peer->session->client_address))) return -1;
+	}
+	if (uwsgi_buffer_append(out, "\r\n", 2)) return -1;
+
+#ifdef UWSGI_SSL
+	if (hr->stud_prefix_pos > 0 || hr->session.ugs->mode == UWSGI_HTTP_SSL) {
+		if (uwsgi_buffer_append(out, "X-Forwarded-Proto: https\r\n", 26)) return -1;
+	}
+#endif
+
+	if (uwsgi_buffer_append(out, "\r\n", 2)) return -1;
+
+#ifdef UWSGI_SSL
+	if (hr->session.ugs->mode == UWSGI_HTTP_FORCE_SSL) {
+                hr->force_https = 1;
+        }
+#endif
+	
+	return 0;
+}
+
+int http_headers_parse(struct corerouter_peer *peer, int skip) {
 
 	struct http_session *hr = (struct http_session *) peer->session;
 
 	char *ptr = peer->session->main_peer->in->buf;
 	char *watermark = ptr + hr->headers_size;
-	char *base = ptr;
+	char *base = ptr + skip;
 	char *query_string = NULL;
-	char *proxy_src = NULL;
-	char *proxy_dst = NULL;
-	char *proxy_src_port = NULL;
-	char *proxy_dst_port = NULL;
-	uint16_t proxy_src_len = 0;
-	uint16_t proxy_dst_len = 0;
-	uint16_t proxy_src_port_len = 0;
-	uint16_t proxy_dst_port_len = 0;
 
 	peer->out = uwsgi_buffer_new(uwsgi.page_size);
 	// force this buffer to be destroyed as soon as possibile
@@ -231,11 +566,6 @@ int http_headers_parse(struct corerouter_peer *peer) {
 	struct uwsgi_buffer *out = peer->out;
 	int found = 0;
 
-        if (uwsgi.enable_proxy_protocol || uhttp.enable_proxy_protocol) {
-		ptr = proxy1_parse(ptr, watermark, &proxy_src, &proxy_src_len, &proxy_dst, &proxy_dst_len, &proxy_src_port, &proxy_src_port_len, &proxy_dst_port, &proxy_dst_port_len);
-		base = ptr;
-        }
-
 	// REQUEST_METHOD 
 	while (ptr < watermark) {
 		if (*ptr == ' ') {
@@ -281,8 +611,6 @@ int http_headers_parse(struct corerouter_peer *peer) {
 			query_string = ptr + 1;
 		}
 		else if (*ptr == ' ') {
-			hr->request_uri = base;
-			hr->request_uri_len = ptr - base;
 			if (uwsgi_buffer_append_keyval(out, "REQUEST_URI", 11, base, ptr - base)) return -1;
 			if (!query_string) {
 				// PATH_INFO must be url-decoded !!!
@@ -332,7 +660,7 @@ int http_headers_parse(struct corerouter_peer *peer) {
 				hr->session.can_keepalive = 1;
 			}
 			if (uhttp.manage_rtsp && !uwsgi_strncmp("RTSP/1.0", 8, base, ptr-base)) {
-				hr->raw_body = 1;
+				hr->session.can_keepalive = 1;
 				hr->is_rtsp = 1;
 			}
 			ptr += 2;
@@ -352,8 +680,6 @@ int http_headers_parse(struct corerouter_peer *peer) {
 
 	// SERVER_NAME
 	if (!uhttp.server_name_as_http_host && uwsgi_buffer_append_keyval(out, "SERVER_NAME", 11, uwsgi.hostname, uwsgi.hostname_len)) return -1;
-	memcpy(peer->key, uwsgi.hostname, uwsgi.hostname_len);
-	peer->key_len = uwsgi.hostname_len;
 
 	// SERVER_PORT
 	if (uwsgi_buffer_append_keyval(out, "SERVER_PORT", 11, hr->port, hr->port_len)) return -1;
@@ -371,10 +697,10 @@ int http_headers_parse(struct corerouter_peer *peer) {
 #endif
 
 	// REMOTE_ADDR
-        if (proxy_src) {
-		if (uwsgi_buffer_append_keyval(out, "REMOTE_ADDR", 11, proxy_src, proxy_src_len)) return -1;
-		if (proxy_src_port) {
-			if (uwsgi_buffer_append_keyval(out, "REMOTE_PORT", 11, proxy_src_port, proxy_src_port_len)) return -1;
+        if (hr->proxy_src) {
+		if (uwsgi_buffer_append_keyval(out, "REMOTE_ADDR", 11, hr->proxy_src, hr->proxy_src_len)) return -1;
+		if (hr->proxy_src_port) {
+			if (uwsgi_buffer_append_keyval(out, "REMOTE_PORT", 11, hr->proxy_src_port, hr->proxy_src_port_len)) return -1;
 		}
 	}
 	else
@@ -464,19 +790,6 @@ int http_headers_parse(struct corerouter_peer *peer) {
 		hv = hv->next;
 	}
 
-	if (hr->is_rtsp) {
-		if (uwsgi_starts_with("rtsp://", 7, hr->path_info, hr->path_info_len)) {
-			char *slash = memchr(hr->path_info + 7, '/', hr->path_info_len - 7);
-			if (!slash) return -1;
-			if (slash - (hr->path_info + 7) <= 0xff) {
-				peer->key_len = slash - (hr->path_info + 7);
-				memcpy(peer->key, hr->path_info + 7, peer->key_len);
-				// override PATH_INFO
-				if (uwsgi_buffer_append_keyval(out, "PATH_INFO", 9, slash, hr->path_info_len - (7 + peer->key_len))) return -1;
-			}
-		}
-	}
-
 	return 0;
 
 clear:
@@ -820,8 +1133,8 @@ ssize_t http_parse(struct corerouter_peer *main_peer) {
 			// default hook
 			new_peer->last_hook_read = hr_instance_read;
 		
-			// parse HTTP request
-			if (http_headers_parse(new_peer)) return -1;
+			int skip = http_headers_parse_first_round(new_peer);
+			if (skip < 0) return -1;
 
 			// check for a valid hostname
 			if (new_peer->key_len == 0) return -1;
@@ -832,6 +1145,9 @@ ssize_t http_parse(struct corerouter_peer *main_peer) {
 				break;
 			}
 #endif
+			if (uwsgi.subscription_mountpoints) {
+				if (rebuild_key_for_mountpoint(hr, new_peer)) return -1;
+			}
 			// find an instance using the key
                 	if (ucr->mapper(ucr, new_peer))
                         	return -1;
@@ -840,19 +1156,20 @@ ssize_t http_parse(struct corerouter_peer *main_peer) {
                 	if (new_peer->instance_address_len == 0)
                         	return -1;
 
-			// fix modifiers
-			if (uhttp.modifier1)
-				new_peer->modifier1 = uhttp.modifier1;
-			if (uhttp.modifier2)
-				new_peer->modifier2 = uhttp.modifier2;
-
-			uint16_t pktsize = new_peer->out->pos-4;
-        		// fix modifiers
-        		new_peer->out->buf[0] = new_peer->modifier1;
-        		new_peer->out->buf[3] = new_peer->modifier2;
-        		// fix pktsize
-        		new_peer->out->buf[1] = (uint8_t) (pktsize & 0xff);
-        		new_peer->out->buf[2] = (uint8_t) ((pktsize >> 8) & 0xff);
+			// parse HTTP request
+			if (new_peer->proto != 'h' && !uhttp.proto_http) {
+				if (http_headers_parse(new_peer, skip)) return -1;
+				uint16_t pktsize = new_peer->out->pos-4;
+        			// fix modifiers
+        			new_peer->out->buf[0] = new_peer->session->main_peer->modifier1;
+        			new_peer->out->buf[3] = new_peer->session->main_peer->modifier2;
+        			// fix pktsize
+        			new_peer->out->buf[1] = (uint8_t) (pktsize & 0xff);
+        			new_peer->out->buf[2] = (uint8_t) ((pktsize >> 8) & 0xff);
+			}
+			else {
+				if (http_headers_parse_dumb(new_peer, skip)) return -1;
+			}
 
 			if (hr->remains > 0) {
 				if (hr->content_length < hr->remains) { 
@@ -867,12 +1184,6 @@ ssize_t http_parse(struct corerouter_peer *main_peer) {
 				if (uwsgi_buffer_append(new_peer->out, main_peer->in->buf + hr->headers_size + 1, hr->remains)) return -1;
 			}
 
-			if (new_peer->modifier1 == 123) {
-				// reset modifier1 to 0
-				new_peer->out->buf[0] = 0;
-				hr->raw_body = 1;
-			}
-
 			if (hr->websockets > 2 && hr->websocket_key_len > 0) {
 				hr->raw_body = 1;
 			}
@@ -997,6 +1308,9 @@ int http_alloc_session(struct uwsgi_corerouter *ucr, struct uwsgi_gateway_socket
 	// set the retry hook
         cs->retry = hr_retry;
 	struct http_session *hr = (struct http_session *) cs;
+	// set the modifier1
+	cs->main_peer->modifier1 = uhttp.modifier1;
+	cs->main_peer->modifier2 = uhttp.modifier2;
 	// default hook
 	cs->main_peer->last_hook_read = hr_read;
 
@@ -1010,6 +1324,7 @@ int http_alloc_session(struct uwsgi_corerouter *ucr, struct uwsgi_gateway_socket
 	if (uhttp.websockets) {
 		hr->websockets = 1;	
 	}
+
 	hr->func_write = hr_write;
 
 	// be sure buffer does not grow over 64k
diff --git a/plugins/http/https.c b/plugins/http/https.c
index a59cc57..4ea2968 100644
--- a/plugins/http/https.c
+++ b/plugins/http/https.c
@@ -10,14 +10,6 @@
 
 extern struct uwsgi_http uhttp;
 
-// taken from nginx
-static void hr_ssl_clear_errors() {
-	while (ERR_peek_error()) {
-		(void) ERR_get_error();
-	}
-	ERR_clear_error();
-}
-
 void uwsgi_opt_https(char *opt, char *value, void *cr) {
         struct uwsgi_corerouter *ucr = (struct uwsgi_corerouter *) cr;
         char *client_ca = NULL;
@@ -180,9 +172,9 @@ int hr_https_add_vars(struct http_session *hr, struct corerouter_peer *peer, str
                 if (uwsgi_buffer_append_keyval(out, "HTTPS", 5, "on", 2)) return -1;
 #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME
 			const char *servername = SSL_get_servername(hr->ssl, TLSEXT_NAMETYPE_host_name);
-                        if (servername && strlen(servername) <= 0xff) {
-				peer->key_len = strlen(servername);
-                        	memcpy(peer->key, servername, peer->key_len) ;
+                        if (servername) {
+                        	peer->key = (char *) servername;
+                                peer->key_len = strlen(servername);
                         }
 #endif
                 hr->ssl_client_cert = SSL_get_peer_certificate(hr->ssl);
@@ -242,7 +234,7 @@ void hr_session_ssl_close(struct corerouter_session *cs) {
 #endif
 
 	// clear the errors (otherwise they could be propagated)
-	hr_ssl_clear_errors();
+	ERR_clear_error();
         SSL_free(hr->ssl);
 }
 
@@ -278,8 +270,6 @@ ssize_t hr_ssl_write(struct corerouter_peer *main_peer) {
         struct corerouter_session *cs = main_peer->session;
         struct http_session *hr = (struct http_session *) cs;
 
-	hr_ssl_clear_errors();
-
         int ret = SSL_write(hr->ssl, main_peer->out->buf + main_peer->out_pos, main_peer->out->pos - main_peer->out_pos);
         if (ret > 0) {
                 main_peer->out_pos += ret;
@@ -304,11 +294,9 @@ ssize_t hr_ssl_write(struct corerouter_peer *main_peer) {
                 }
                 return ret;
         }
-
+        if (ret == 0) return 0;
         int err = SSL_get_error(hr->ssl, ret);
 
-	if (err == SSL_ERROR_ZERO_RETURN || err == 0) return 0;
-
         if (err == SSL_ERROR_WANT_READ) {
                 cr_reset_hooks_and_read(main_peer, hr_ssl_write);
                 return 1;
@@ -334,8 +322,6 @@ ssize_t hr_ssl_read(struct corerouter_peer *main_peer) {
         struct corerouter_session *cs = main_peer->session;
         struct http_session *hr = (struct http_session *) cs;
 
-	hr_ssl_clear_errors();
-
         // try to always leave 4k available
         if (uwsgi_buffer_ensure(main_peer->in, uwsgi.page_size)) return -1;
         int ret = SSL_read(hr->ssl, main_peer->in->buf + main_peer->in->pos, main_peer->in->len - main_peer->in->pos);
@@ -364,11 +350,9 @@ ssize_t hr_ssl_read(struct corerouter_peer *main_peer) {
 #endif
                 return http_parse(main_peer);
         }
-
+        if (ret == 0) return 0;
         int err = SSL_get_error(hr->ssl, ret);
 
-	if (err == SSL_ERROR_ZERO_RETURN || err == 0) return 0;
-
         if (err == SSL_ERROR_WANT_READ) {
                 cr_reset_hooks_and_read(main_peer, hr_ssl_read);
                 return 1;
@@ -390,46 +374,6 @@ ssize_t hr_ssl_read(struct corerouter_peer *main_peer) {
         return -1;
 }
 
-ssize_t hr_ssl_shutdown(struct corerouter_peer *peer) {
-	// ensure no hooks are set
-	if (uwsgi_cr_set_hooks(peer, NULL, NULL)) return -1;
-
-	struct corerouter_session *cs = peer->session;
-        struct http_session *hr = (struct http_session *) cs;	
-
-	hr_ssl_clear_errors();
-
-	int ret = SSL_shutdown(hr->ssl);
-	int err = 0;
-
-	if (ret != 1 && ERR_peek_error()) {
-		err = SSL_get_error(hr->ssl, ret);
-	}
-
-	// no error, close the connection
-	if (ret == 1 || err == 0 || err == SSL_ERROR_ZERO_RETURN) return 0;
-
-	if (err == SSL_ERROR_WANT_READ) {
-		if (uwsgi_cr_set_hooks(peer, hr_ssl_shutdown, NULL)) return -1;
-                return 1;
-        }
-
-        else if (err == SSL_ERROR_WANT_WRITE) {
-		if (uwsgi_cr_set_hooks(peer, NULL, hr_ssl_shutdown)) return -1;
-                return 1;
-        }
-
-        else if (err == SSL_ERROR_SYSCALL) {
-                uwsgi_cr_error(peer, "hr_ssl_shutdown()");
-        }
-
-        else if (err == SSL_ERROR_SSL && uwsgi.ssl_verbose) {
-                ERR_print_errors_fp(stderr);
-        }
-
-        return -1;
-}
-
 void hr_setup_ssl(struct http_session *hr, struct uwsgi_gateway_socket *ugs) {
  	hr->ssl = SSL_new(ugs->ctx);
         SSL_set_fd(hr->ssl, hr->session.main_peer->fd);
@@ -438,7 +382,6 @@ void hr_setup_ssl(struct http_session *hr, struct uwsgi_gateway_socket *ugs) {
         SSL_set_ex_data(hr->ssl, uhttp.spdy_index, hr);
 #endif
         uwsgi_cr_set_hooks(hr->session.main_peer, hr_ssl_read, NULL);
-	hr->session.main_peer->flush = hr_ssl_shutdown;
         hr->session.close = hr_session_ssl_close;
 	hr->func_write = hr_ssl_write;
 }
diff --git a/plugins/http/keepalive.c b/plugins/http/keepalive.c
index 7315a63..8bdff6c 100644
--- a/plugins/http/keepalive.c
+++ b/plugins/http/keepalive.c
@@ -17,7 +17,7 @@ int http_response_parse(struct http_session *hr, struct uwsgi_buffer *ub, size_t
         // protocol
         for(i=0;i<len;i++) {
                 if (buf[i] == ' ') {
-			if (hr->session.can_keepalive && uwsgi_strncmp("HTTP/1.1", 8, buf, i)) {
+			if (!hr->is_rtsp && hr->session.can_keepalive && uwsgi_strncmp("HTTP/1.1", 8, buf, i)) {
 				goto end;
 			}
                         if (i+1 >= len) return -1;;
@@ -34,6 +34,15 @@ int http_response_parse(struct http_session *hr, struct uwsgi_buffer *ub, size_t
         for(i=next;i<len;i++) {
                 if (buf[i] == '\r' || buf[i] == '\n') {
 			// status ready
+			// if we are in RTSP mode we need to ensure a 200 is returned
+			if (hr->is_rtsp) {
+				if (next + 3 >= len) return -1;
+				char *code = buf + next;
+				if (code[0] != '2' || code[1] != '0' || code[2] != '0') {
+					hr->is_rtsp = 0;
+					hr->session.can_keepalive = 0;
+				}
+			}
                         if (i+1 >= len) return -1;
                         next = i + 1;
                         found = 1;
@@ -116,7 +125,7 @@ int http_response_parse(struct http_session *hr, struct uwsgi_buffer *ub, size_t
                 }
         }
 
-	if (!has_size) {
+	if (!has_size && !hr->is_rtsp) {
 #ifdef UWSGI_ZLIB
 		if (hr->has_gzip) {
 			hr->force_gzip = 1;
diff --git a/plugins/http/spdy3.c b/plugins/http/spdy3.c
index 858a2fc..b55df4e 100644
--- a/plugins/http/spdy3.c
+++ b/plugins/http/spdy3.c
@@ -556,10 +556,8 @@ static ssize_t spdy_inflate_http_headers(struct http_session *hr) {
 		}
 
 		if (!uwsgi_strncmp(cgi_name, nk_len, "HTTP_HOST", 9)) {
-			if (v_len <= 0xff) {
-				memcpy(new_peer->key, new_peer->out->buf + (new_peer->out->pos - v_len), v_len);
-				new_peer->key_len = v_len;
-			}
+			new_peer->key = new_peer->out->buf + (new_peer->out->pos - v_len);
+			new_peer->key_len = v_len;
 		}
 		else if (!uwsgi_strncmp(cgi_name, nk_len, "REQUEST_URI", 11)) {
 			char *path_info = new_peer->out->buf + (new_peer->out->pos - v_len);
diff --git a/plugins/jvm/jvm_plugin.c b/plugins/jvm/jvm_plugin.c
index f709ed1..511f893 100644
--- a/plugins/jvm/jvm_plugin.c
+++ b/plugins/jvm/jvm_plugin.c
@@ -1257,7 +1257,7 @@ static int uwsgi_jvm_request(struct wsgi_request *wsgi_req) {
 	}
 
 	/* Standard JVM request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log("Empty JVM request. skip.\n");
                 return -1;
         }
diff --git a/plugins/lua/lua_plugin.c b/plugins/lua/lua_plugin.c
index fe81045..89c50cf 100644
--- a/plugins/lua/lua_plugin.c
+++ b/plugins/lua/lua_plugin.c
@@ -746,7 +746,7 @@ static int uwsgi_lua_request(struct wsgi_request *wsgi_req) {
 	}
 
 	/* Standard WSAPI request */
-	if (!wsgi_req->uh->pktsize) {
+	if (!wsgi_req->len) {
 		uwsgi_log( "Empty lua request. skip.\n");
 		return -1;
 	}
@@ -843,7 +843,7 @@ static int uwsgi_lua_request(struct wsgi_request *wsgi_req) {
 		}
 		lua_pop(L, 1);
 		lua_pushvalue(L, -1);
-		if (uwsgi.async > 1) {
+		if (uwsgi.async > 0) {
 			return UWSGI_AGAIN;
 		}
 	}
diff --git a/plugins/matheval/math.c b/plugins/matheval/math.c
index 7d41575..01fb948 100644
--- a/plugins/matheval/math.c
+++ b/plugins/matheval/math.c
@@ -6,7 +6,7 @@ static char *uwsgi_route_var_math(struct wsgi_request *wsgi_req, char *key, uint
         // avoid crash
         if (!wsgi_req->var_cnt) return NULL;
         // we make a bit of fun here, we do a copy of the vars buffer (+1 byte for final zero) and zeor-pad all of the strings
-        char *vars_buf = uwsgi_malloc(wsgi_req->uh->pktsize + keylen + 1);
+        char *vars_buf = uwsgi_malloc(wsgi_req->len + keylen + 1);
         char **names = uwsgi_malloc(sizeof(char *) * (wsgi_req->var_cnt/2));
         double *values = uwsgi_calloc(sizeof(double) * (wsgi_req->var_cnt/2));
         int i,j = 0;
diff --git a/plugins/mongrel2/mongrel2.c b/plugins/mongrel2/mongrel2.c
index 1dbf6f9..4eaef1a 100644
--- a/plugins/mongrel2/mongrel2.c
+++ b/plugins/mongrel2/mongrel2.c
@@ -64,7 +64,7 @@ static int uwsgi_mongrel2_json_parse(json_t * root, struct wsgi_request *wsgi_re
 		if (!strcmp(json_val, "JSON")) {
 			return -1;
 		}
-		wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_METHOD", 14, json_val, strlen(json_val));
+		wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_METHOD", 14, json_val, strlen(json_val));
 	}
 
 	// pretty easy, we get the file and we map it to wsgi_req->post_file, uWSGI read api will automatically use this
@@ -80,49 +80,49 @@ static int uwsgi_mongrel2_json_parse(json_t * root, struct wsgi_request *wsgi_re
 	}
 
 
-	wsgi_req->uh->pktsize += uwsgi_mongrel2_json_add(wsgi_req, root, "VERSION", "SERVER_PROTOCOL", 15, NULL, NULL);
-	wsgi_req->uh->pktsize += uwsgi_mongrel2_json_add(wsgi_req, root, "QUERY", "QUERY_STRING", 12, &query_string, &query_string_len);
+	wsgi_req->len += uwsgi_mongrel2_json_add(wsgi_req, root, "VERSION", "SERVER_PROTOCOL", 15, NULL, NULL);
+	wsgi_req->len += uwsgi_mongrel2_json_add(wsgi_req, root, "QUERY", "QUERY_STRING", 12, &query_string, &query_string_len);
 	if (query_string == NULL) {
 		// always set QUERY_STRING
-		wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, "", 0);
+		wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, "", 0);
 	}
 
 	// set SCRIPT_NAME to an empty value
-	wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SCRIPT_NAME", 11, "", 0);
+	wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SCRIPT_NAME", 11, "", 0);
 
 	if ((json_val = uwsgi_mongrel2_json_get_string(root, "PATH"))) {
-		wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "PATH_INFO", 9, json_val + script_name_len, strlen(json_val + script_name_len));
+		wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "PATH_INFO", 9, json_val + script_name_len, strlen(json_val + script_name_len));
 		if (query_string_len) {
 			char *request_uri = uwsgi_concat3n(json_val, strlen(json_val), "?", 1, query_string, query_string_len);
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, request_uri, strlen(json_val) + 1 + query_string_len);
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, request_uri, strlen(json_val) + 1 + query_string_len);
 			free(request_uri);
 		}
 		else {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, json_val, strlen(json_val));
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, json_val, strlen(json_val));
 		}
 	}
 
 	if ((json_val = uwsgi_mongrel2_json_get_string(root, "URL_SCHEME"))) {
-                wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "UWSGI_SCHEME", 12, json_val, strlen(json_val));
+                wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "UWSGI_SCHEME", 12, json_val, strlen(json_val));
         }
 
 	if ((json_val = uwsgi_mongrel2_json_get_string(root, "host"))) {
 		char *colon = strchr(json_val, ':');
 		if (colon) {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, colon + 1, strlen(colon + 1));
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, colon + 1, strlen(colon + 1));
 		}
 		else {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, "80", 2);
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, "80", 2);
 		}
 	}
 
 	if ((json_val = uwsgi_mongrel2_json_get_string(root, "x-forwarded-for"))) {
 		char *colon = strchr(json_val, ',');
 		if (colon) {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, colon + 1, (colon + 1) - json_val);
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, colon + 1, (colon + 1) - json_val);
 		}
 		else {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, json_val, strlen(json_val));
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, json_val, strlen(json_val));
 		}
 	}
 
@@ -131,7 +131,7 @@ static int uwsgi_mongrel2_json_parse(json_t * root, struct wsgi_request *wsgi_re
 		wsgi_req->post_cl = atoi(json_val);
 	}
 
-	wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_NAME", 11, uwsgi.hostname, uwsgi.hostname_len);
+	wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_NAME", 11, uwsgi.hostname, uwsgi.hostname_len);
 
 	json_iter = json_object_iter(root);
 
@@ -142,7 +142,7 @@ static int uwsgi_mongrel2_json_parse(json_t * root, struct wsgi_request *wsgi_re
 			json_value = json_object_iter_value(json_iter);
 			if (json_is_string(json_value)) {
 				json_val = (char *) json_string_value(json_value);
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_header(wsgi_req, json_key, strlen(json_key), json_val, strlen(json_val));
+				wsgi_req->len += proto_base_add_uwsgi_header(wsgi_req, json_key, strlen(json_key), json_val, strlen(json_val));
 			}
 		}
 		json_iter = json_object_iter_next(root, json_iter);
@@ -169,7 +169,7 @@ static int uwsgi_mongrel2_tnetstring_parse(struct wsgi_request *wsgi_req, char *
 	int async_upload = 0;
 
 	// set an empty SCRIPT_NAME
-	wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SCRIPT_NAME", 11, "", 0);
+	wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SCRIPT_NAME", 11, "", 0);
 
 	while (ptr < watermark) {
 
@@ -193,29 +193,29 @@ static int uwsgi_mongrel2_tnetstring_parse(struct wsgi_request *wsgi_req, char *
 				if (!uwsgi_strncmp("JSON", 4, val, vallen)) {
 					return -1;
 				}
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_METHOD", 14, val, vallen);
+				wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_METHOD", 14, val, vallen);
 			}
 			else if (!uwsgi_strncmp("VERSION", 7, key, keylen)) {
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PROTOCOL", 15, val, vallen);
+				wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PROTOCOL", 15, val, vallen);
 			}
 			else if (!uwsgi_strncmp("QUERY", 5, key, keylen)) {
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, val, vallen);
+				wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, val, vallen);
 				query_string = val;
 				query_string_len = vallen;
 			}
 			else if (!uwsgi_strncmp("PATH", 4, key, keylen)) {
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "PATH_INFO", 9, val + script_name_len, vallen - script_name_len);
+				wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "PATH_INFO", 9, val + script_name_len, vallen - script_name_len);
 				if (query_string_len) {
 					char *request_uri = uwsgi_concat3n(val, vallen, "?", 1, query_string, query_string_len);
-					wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, request_uri, vallen + 1 + query_string_len);
+					wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, request_uri, vallen + 1 + query_string_len);
 					free(request_uri);
 				}
 				else {
-					wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, val, vallen);
+					wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, val, vallen);
 				}
 			}
 			else if (!uwsgi_strncmp("URL_SCHEME", 10, key, keylen)) {	
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "UWSGI_SCHEME", 12, val, vallen);
+				wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "UWSGI_SCHEME", 12, val, vallen);
 			}
 		}
 		else {
@@ -223,10 +223,10 @@ static int uwsgi_mongrel2_tnetstring_parse(struct wsgi_request *wsgi_req, char *
 			if (!uwsgi_strncmp("host", 4, key, keylen)) {
 				char *colon = memchr(val, ':', vallen);
 				if (colon) {
-					wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, colon + 1, vallen - ((colon + 1) - val));
+					wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, colon + 1, vallen - ((colon + 1) - val));
 				}
 				else {
-					wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, "80", 2);
+					wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, "80", 2);
 				}
 			}
 			else if (!uwsgi_strncmp("content-length", 14, key, keylen)) {
@@ -245,24 +245,24 @@ static int uwsgi_mongrel2_tnetstring_parse(struct wsgi_request *wsgi_req, char *
 			else if (!uwsgi_strncmp("x-forwarded-for", 15, key, keylen)) {
 				char *colon = memchr(val, ',', vallen);
 				if (colon) {
-					wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, colon + 1, (colon + 1) - val);
+					wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, colon + 1, (colon + 1) - val);
 				}
 				else {
-					wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, val, vallen);
+					wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, val, vallen);
 				}
 			}
 			else if (!uwsgi_strncmp("x-mongrel2-upload-start", 23, key, keylen)) {
 				async_upload += 1;
 			}
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_header(wsgi_req, key, keylen, val, vallen);
+			wsgi_req->len += proto_base_add_uwsgi_header(wsgi_req, key, keylen, val, vallen);
 		}
 	}
 
-	wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_NAME", 11, uwsgi.hostname, uwsgi.hostname_len);
+	wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_NAME", 11, uwsgi.hostname, uwsgi.hostname_len);
 
 	if (query_string == NULL) {
 		// always set QUERY_STRING
-		wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, "", 0);
+		wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, "", 0);
 	}
 
 	// reject uncomplete upload
diff --git a/plugins/mono/mono_plugin.c b/plugins/mono/mono_plugin.c
index f3b71c9..c1ae15d 100644
--- a/plugins/mono/mono_plugin.c
+++ b/plugins/mono/mono_plugin.c
@@ -516,7 +516,7 @@ static void uwsgi_mono_init_apps() {
 static int uwsgi_mono_request(struct wsgi_request *wsgi_req) {
 
 	/* Standard ASP.NET request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log("Empty Mono/ASP.NET request. skip.\n");
                 return -1;
         }
@@ -543,7 +543,7 @@ static int uwsgi_mono_request(struct wsgi_request *wsgi_req) {
 
         wsgi_req->app_id = uwsgi_get_app_id(NULL, key, key_len, mono_plugin.modifier1);
         // if it is -1, try to load a dynamic app
-        if (wsgi_req->app_id == -1 && key_len > 0) {
+        if (wsgi_req->app_id == -1) {
         	if (uwsgi.threads > 1) {
                 	pthread_mutex_lock(&umono.lock_loader);
                 }
@@ -562,15 +562,10 @@ static int uwsgi_mono_request(struct wsgi_request *wsgi_req) {
 
 
         if (wsgi_req->app_id == -1) {
-		if (!uwsgi.no_default_app && uwsgi.default_app > -1 && uwsgi_apps[uwsgi.default_app].modifier1 == mono_plugin.modifier1) {
-               		wsgi_req->app_id = uwsgi.default_app;
-                }
-		else {
-        		uwsgi_500(wsgi_req);
-                	uwsgi_log("--- unable to find Mono/ASP.NET application ---\n");
-                	// nothing to clear/free
-                	return UWSGI_OK;
-		}
+        	uwsgi_500(wsgi_req);
+                uwsgi_log("--- unable to find Mono/ASP.NET application ---\n");
+                // nothing to clear/free
+                return UWSGI_OK;
         }
 
         struct uwsgi_app *app = &uwsgi_apps[wsgi_req->app_id];
diff --git a/plugins/mono/uwsgiplugin.py b/plugins/mono/uwsgiplugin.py
index 3eac98c..4d17a48 100644
--- a/plugins/mono/uwsgiplugin.py
+++ b/plugins/mono/uwsgiplugin.py
@@ -7,7 +7,7 @@ LIBS = os.popen('pkg-config --libs mono-2').read().rstrip().split()
 GCC_LIST = ['mono_plugin']
 
 if os.uname()[0] == 'Darwin':
-	LIBS.append('-framework Foundation')
+    LIBS.append('-framework Foundation')
 
 def post_build(config):
     if os.system("sn -k plugins/mono/uwsgi.key") != 0:
diff --git a/plugins/msgpack/msgpack.c b/plugins/msgpack/msgpack.c
index 27e6b40..e0e080a 100644
--- a/plugins/msgpack/msgpack.c
+++ b/plugins/msgpack/msgpack.c
@@ -121,7 +121,7 @@ int uwsgi_buffer_msgpack_int(struct uwsgi_buffer *ub, int64_t num) {
 	if (num > 0 && num <= 127) {
 		return uwsgi_buffer_byte(ub, (uint8_t) num);
 	}
-	else if (num < 0 && num >= -31) {
+	else if (num < 0 && num >= 31) {
 		return uwsgi_buffer_byte(ub, 224 | (int8_t) num);
 	}
 	else if (num <= 127 && num >= -127) {
diff --git a/plugins/nagios/nagios.c b/plugins/nagios/nagios.c
index ee0ac86..200f783 100644
--- a/plugins/nagios/nagios.c
+++ b/plugins/nagios/nagios.c
@@ -36,7 +36,7 @@ int nagios() {
 	}
 
 	uh.modifier1 = UWSGI_MODIFIER_PING;
-	uh.pktsize = 0;
+	uh._pktsize = 0;
 	uh.modifier2 = 0;
 	if (write(fd, &uh, 4) != 4) {
 		uwsgi_error("write()");
@@ -56,8 +56,8 @@ int nagios() {
 		exit(2);
 	}
 	else {
-		if (uh.pktsize > 0 && buf) {
-			fprintf(stdout, "UWSGI WARNING: %.*s\n", uh.pktsize, buf);
+		if (uh._pktsize > 0 && buf) {
+			fprintf(stdout, "UWSGI WARNING: %.*s\n", uh._pktsize, buf);
 			exit(1);
 		}
 		else {
diff --git a/plugins/php/php_plugin.c b/plugins/php/php_plugin.c
index b1b6f7a..1dda41d 100644
--- a/plugins/php/php_plugin.c
+++ b/plugins/php/php_plugin.c
@@ -4,6 +4,8 @@ extern struct uwsgi_server uwsgi;
 
 static sapi_module_struct uwsgi_sapi_module;
 
+static int uwsgi_php_init(void);
+
 struct uwsgi_php {
 	struct uwsgi_string_list *allowed_docroot;
 	struct uwsgi_string_list *allowed_ext;
@@ -28,6 +30,8 @@ struct uwsgi_php {
 	struct uwsgi_string_list *exec_after;
 
 	char *sapi_name;
+
+	int sapi_initialized;
 } uphp;
 
 void uwsgi_opt_php_ini(char *opt, char *value, void *foobar) {
@@ -35,6 +39,10 @@ void uwsgi_opt_php_ini(char *opt, char *value, void *foobar) {
         uwsgi_sapi_module.php_ini_ignore = 1;
 }
 
+void uwsgi_opt_early_php(char *opt, char *value, void *foobar) {
+	uwsgi_php_init();
+}
+
 struct uwsgi_option uwsgi_php_options[] = {
 
         {"php-ini", required_argument, 0, "set php.ini path", uwsgi_opt_php_ini, NULL, 0},
@@ -61,6 +69,9 @@ struct uwsgi_option uwsgi_php_options[] = {
         {"php-exec-after", required_argument, 0, "run specified php code after the requested script", uwsgi_opt_add_string_list, &uphp.exec_after, 0},
         {"php-exec-end", required_argument, 0, "run specified php code after the requested script", uwsgi_opt_add_string_list, &uphp.exec_after, 0},
         {"php-sapi-name", required_argument, 0, "hack the sapi name (required for enabling zend opcode cache)", uwsgi_opt_set_str, &uphp.sapi_name, 0},
+
+        {"early-php", no_argument, 0, "initialize an early perl interpreter shared by all loaders", uwsgi_opt_early_php, NULL, UWSGI_OPT_IMMEDIATE},
+        {"early-php-sapi-name", required_argument, 0, "hack the sapi name (required for enabling zend opcode cache)", uwsgi_opt_set_str, &uphp.sapi_name, UWSGI_OPT_IMMEDIATE},
 	UWSGI_END_OF_OPTIONS
 };
 
@@ -77,7 +88,7 @@ static int sapi_uwsgi_ub_write(const char *str, uint str_length TSRMLS_DC)
 	return str_length;
 }
 
-static int sapi_uwsgi_send_headers(sapi_headers_struct *sapi_headers TSRMLS_DC)
+static int sapi_uwsgi_send_headers(sapi_headers_struct *sapi_headers)
 {
 	sapi_header_struct *h;
 	zend_llist_position pos;
@@ -135,7 +146,7 @@ static int sapi_uwsgi_read_post(char *buffer, uint count_bytes TSRMLS_DC)
 }
 
 
-static char *sapi_uwsgi_read_cookies(TSRMLS_D)
+static char *sapi_uwsgi_read_cookies(void)
 {
 	uint16_t len = 0;
 	struct wsgi_request *wsgi_req = (struct wsgi_request *) SG(server_context);
@@ -518,7 +529,7 @@ static int php_uwsgi_startup(sapi_module_struct *sapi_module)
 	}
 }
 
-static void sapi_uwsgi_log_message(char *message TSRMLS_DC) {
+static void sapi_uwsgi_log_message(char *message) {
 
 	uwsgi_log("%s\n", message);
 }
@@ -554,16 +565,15 @@ static sapi_module_struct uwsgi_sapi_module = {
 	STANDARD_SAPI_MODULE_PROPERTIES
 };
 
-int uwsgi_php_init(void) {
+static int uwsgi_php_init(void) {
 
 	struct uwsgi_string_list *pset = uphp.set;
 	struct uwsgi_string_list *append_config = uphp.append_config;
 
-#ifdef ZTS
-        tsrm_startup(1, 1, 0, NULL);
-#endif
-
-	sapi_startup(&uwsgi_sapi_module);
+	if (!uphp.sapi_initialized) {
+		sapi_startup(&uwsgi_sapi_module);
+		uphp.sapi_initialized = 1;
+	}
 
 	// applying custom options
 	while(append_config) {
@@ -594,6 +604,7 @@ int uwsgi_php_init(void) {
 	if (uphp.sapi_name) {
 		uwsgi_sapi_module.name = uphp.sapi_name;
 	}
+
 	uwsgi_sapi_module.startup(&uwsgi_sapi_module);
 	uwsgi_log("PHP %s initialized\n", PHP_VERSION);
 
@@ -663,14 +674,9 @@ int uwsgi_php_request(struct wsgi_request *wsgi_req) {
 	size_t real_filename_len = 0;
 	struct stat php_stat;
 	char *filename = NULL;
-	int force_empty_script_name = 0;
 
 	zend_file_handle file_handle;
 
-#ifdef ZTS
-	TSRMLS_FETCH();
-#endif
-
 	SG(server_context) = (void *) wsgi_req;
 
 	if (uwsgi_parse_vars(wsgi_req)) {
@@ -736,7 +742,6 @@ int uwsgi_php_request(struct wsgi_request *wsgi_req) {
 appready:
 		wsgi_req->path_info = "";
 		wsgi_req->path_info_len = 0;
-		force_empty_script_name = 1;
 		goto secure2;
 	}
 
@@ -866,19 +871,13 @@ secure2:
         }
 
 secure3:
-	if (force_empty_script_name) {
-		wsgi_req->script_name = "";
-		wsgi_req->script_name_len = 0;
+	wsgi_req->script_name = orig_path_info;
+	if (path_info) {
+		wsgi_req->script_name_len = path_info - orig_path_info;
 	}
 	else {
-		wsgi_req->script_name = orig_path_info;
-		if (path_info) {
-			wsgi_req->script_name_len = path_info - orig_path_info;
-		}
-		else {
-			wsgi_req->script_name_len = orig_path_info_len;
-		}
-	}
+		wsgi_req->script_name_len = orig_path_info_len;
+	}	
 
 #ifdef UWSGI_DEBUG
 	uwsgi_log("php filename = %s script_name = %.*s (%d) document_root = %.*s (%d)\n", real_filename, wsgi_req->script_name_len, wsgi_req->script_name, wsgi_req->script_name_len,
diff --git a/plugins/ping/ping_plugin.c b/plugins/ping/ping_plugin.c
index 384fa97..c620c72 100644
--- a/plugins/ping/ping_plugin.c
+++ b/plugins/ping/ping_plugin.c
@@ -29,7 +29,7 @@ static void ping() {
 	}
 
 	uh.modifier1 = UWSGI_MODIFIER_PING;
-	uh.pktsize = 0;
+	uh._pktsize = 0;
 	uh.modifier2 = 0;
 
 	if (write(fd, &uh, 4) != 4) {
@@ -42,8 +42,8 @@ static void ping() {
 		exit(1);
 	}
 	else {
-		if (uh.pktsize > 0) {
-			uwsgi_log("[WARNING] node %s message: %.*s\n", uping.ping, uh.pktsize, buf);
+		if (uh._pktsize > 0) {
+			uwsgi_log("[WARNING] node %s message: %.*s\n", uping.ping, uh._pktsize, buf);
 			exit(2);
 		}
 		else {
@@ -70,13 +70,13 @@ int uwsgi_request_ping(struct wsgi_request *wsgi_req) {
 
 	uwsgi_log( "PING\n");
 	wsgi_req->uh->modifier2 = 1;
-	wsgi_req->uh->pktsize = 0;
+	wsgi_req->uh->_pktsize = 0;
 	wsgi_req->do_not_account = 1;
 
 	len = strlen(uwsgi.shared->warning_message);
 	if (len > 0) {
 		// TODO: check endianess ?
-		wsgi_req->uh->pktsize = len;
+		wsgi_req->uh->_pktsize = len;
 	}
 
 	if (uwsgi_response_write_body_do(wsgi_req, (char *) wsgi_req->uh, 4)) {
diff --git a/plugins/psgi/psgi.h b/plugins/psgi/psgi.h
index 92e6b58..f204b80 100644
--- a/plugins/psgi/psgi.h
+++ b/plugins/psgi/psgi.h
@@ -67,6 +67,11 @@ struct uwsgi_perl {
 	CV *spooler;
 
 	int no_plack;
+
+	SV **early_psgi_callable;
+	char *early_psgi_app_name;
+
+	PerlInterpreter *early_interpreter;
 };
 
 void init_perl_embedded_module(void);
@@ -87,3 +92,5 @@ void uwsgi_perl_exec(char *);
 
 void uwsgi_perl_check_auto_reload(void);
 void uwsgi_psgi_preinit_apps(void);
+
+int uwsgi_perl_add_app(struct wsgi_request *, char *, PerlInterpreter **, SV **, time_t);
diff --git a/plugins/psgi/psgi_loader.c b/plugins/psgi/psgi_loader.c
index 6179c70..27b0280 100644
--- a/plugins/psgi/psgi_loader.c
+++ b/plugins/psgi/psgi_loader.c
@@ -25,12 +25,11 @@ XS(XS_error) {
         psgi_check_args(0);
 
 	if (uwsgi.threads > 1) {
-        	ST(0) = sv_bless(newRV_noinc(newSV(0)), ((HV **)wi->error)[wsgi_req->async_id]);
+        	ST(0) = sv_bless(newRV(sv_newmortal()), ((HV **)wi->error)[wsgi_req->async_id]);
 	}
 	else {
-        	ST(0) = sv_bless(newRV_noinc(newSV(0)), ((HV **)wi->error)[0]);
+        	ST(0) = sv_bless(newRV(sv_newmortal()), ((HV **)wi->error)[0]);
 	}
-        sv_2mortal(ST(0));
         XSRETURN(1);
 }
 
@@ -42,12 +41,11 @@ XS(XS_input) {
         psgi_check_args(0);
 
 	if (uwsgi.threads > 1) {
-        	ST(0) = sv_bless(newRV_noinc(newSV(0)), ((HV **)wi->input)[wsgi_req->async_id]);
+        	ST(0) = sv_bless(newRV(sv_newmortal()), ((HV **)wi->input)[wsgi_req->async_id]);
 	}
 	else {
-        	ST(0) = sv_bless(newRV_noinc(newSV(0)), ((HV **)wi->input)[0]);
+        	ST(0) = sv_bless(newRV(sv_newmortal()), ((HV **)wi->input)[0]);
 	}
-        sv_2mortal(ST(0));
         XSRETURN(1);
 }
 
@@ -82,12 +80,11 @@ XS(XS_stream)
 
 		SvREFCNT_dec(response);
 		if (uwsgi.threads > 1) {
-                	ST(0) = sv_bless(newRV_noinc(newSV(0)), ((HV **)wi->stream)[wsgi_req->async_id]);
+                	ST(0) = sv_bless(newRV(sv_newmortal()), ((HV **)wi->stream)[wsgi_req->async_id]);
 		}
 		else {
-                	ST(0) = sv_bless(newRV_noinc(newSV(0)), ((HV **)wi->stream)[0]);
+                	ST(0) = sv_bless(newRV(sv_newmortal()), ((HV **)wi->stream)[0]);
 		}
-                sv_2mortal(ST(0));
                 XSRETURN(1);
 	}
 	else {
@@ -274,51 +271,6 @@ nonworker:
 	newCONSTSUB(stash, "SPOOL_RETRY", newSViv(-1));
 	newCONSTSUB(stash, "SPOOL_IGNORE", newSViv(0));
 
-	HV *_opts = newHV();
-
-	int i;
-	for (i = 0; i < uwsgi.exported_opts_cnt; i++) {
-		if (hv_exists(_opts, uwsgi.exported_opts[i]->key, strlen(uwsgi.exported_opts[i]->key))) {
-			SV **value = hv_fetch(_opts, uwsgi.exported_opts[i]->key, strlen(uwsgi.exported_opts[i]->key), 0);
-			// last resort !!!
-			if (!value) {
-				uwsgi_log("[perl] WARNING !!! unable to build uwsgi::opt hash !!!\n");
-				goto end;
-			}
-			if (SvTYPE(SvRV(*value)) == SVt_PVAV) {
-				if (uwsgi.exported_opts[i]->value == NULL) {
-                                        av_push((AV *)SvRV(*value), newSViv(1));
-                                }
-                                else {
-                                        av_push((AV *)SvRV(*value), newSVpv(uwsgi.exported_opts[i]->value, 0));
-                                }
-			}
-			else {
-				AV *_opt_a = newAV();
-				av_push(_opt_a, SvREFCNT_inc(*value));
-				if (uwsgi.exported_opts[i]->value == NULL) {
-					av_push(_opt_a, newSViv(1));
-				}
-				else {
-					av_push(_opt_a, newSVpv(uwsgi.exported_opts[i]->value, 0));
-				}
-				hv_store(_opts, uwsgi.exported_opts[i]->key, strlen(uwsgi.exported_opts[i]->key), newRV_inc((SV *) _opt_a), 0);
-			}
-		}
-		else {
-			if (uwsgi.exported_opts[i]->value == NULL) {
-				hv_store(_opts, uwsgi.exported_opts[i]->key, strlen(uwsgi.exported_opts[i]->key), newSViv(1), 0);
-			}
-			else {
-				hv_store(_opts, uwsgi.exported_opts[i]->key, strlen(uwsgi.exported_opts[i]->key), newSVpv(uwsgi.exported_opts[i]->value, 0), 0);
-			}
-		}
-	}
-
-	newCONSTSUB(stash, "opt", newRV_inc((SV *) _opts));
-
-end:
-
         init_perl_embedded_module();
 
 }
@@ -385,11 +337,13 @@ int init_psgi_app(struct wsgi_request *wsgi_req, char *app, uint16_t app_len, Pe
 	if (!interpreters) goto clear2;
 
 	callables = uwsgi_calloc(sizeof(SV *) * uwsgi.threads);
-	uperl.tmp_streaming_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
-	uperl.tmp_input_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
-	uperl.tmp_error_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
-	uperl.tmp_stream_responder = uwsgi_calloc(sizeof(CV *) * uwsgi.threads);
-	uperl.tmp_psgix_logger = uwsgi_calloc(sizeof(CV *) * uwsgi.threads);
+	if (!uperl.early_interpreter) {
+		uperl.tmp_streaming_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
+		uperl.tmp_input_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
+		uperl.tmp_error_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
+		uperl.tmp_stream_responder = uwsgi_calloc(sizeof(CV *) * uwsgi.threads);
+		uperl.tmp_psgix_logger = uwsgi_calloc(sizeof(CV *) * uwsgi.threads);
+	}
 
 	for(i=0;i<uwsgi.threads;i++) {
 
@@ -417,7 +371,7 @@ int init_psgi_app(struct wsgi_request *wsgi_req, char *app, uint16_t app_len, Pe
 		// our xs_init hook, but we're *not* calling it with
 		// uperl.embedding as an argument so we won't execute
 		// BEGIN blocks in app_name twice.
-		{
+		if (!uperl.early_interpreter) {
 			char *perl_e_arg = uwsgi_concat2("#line 0 ", app_name);
 			char *perl_init_arg[] = { "", "-e", perl_e_arg };
 			if (perl_parse(interpreters[i], xs_init, 3, perl_init_arg, NULL)) {
@@ -501,46 +455,19 @@ int init_psgi_app(struct wsgi_request *wsgi_req, char *app, uint16_t app_len, Pe
 		PERL_SET_CONTEXT(interpreters[0]);
 	}
 
+	// is it an early loading ?
+	if (!uwsgi.workers) {
+		uperl.early_psgi_app_name = app_name;
+		uperl.early_psgi_callable = callables;
+		return 0;
+	}
+
 	if (uwsgi_apps_cnt >= uwsgi.max_apps) {
 		uwsgi_log("ERROR: you cannot load more than %d apps in a worker\n", uwsgi.max_apps);
 		goto clear;
 	}
 
-	int id = uwsgi_apps_cnt;
-	struct uwsgi_app *wi = NULL;
-
-	if (wsgi_req) {
-		// we need a copy of app_id
-		wi = uwsgi_add_app(id, psgi_plugin.modifier1, uwsgi_concat2n(wsgi_req->appid, wsgi_req->appid_len, "", 0), wsgi_req->appid_len, interpreters, callables);
-	}
-	else {
-		wi = uwsgi_add_app(id, psgi_plugin.modifier1, "", 0, interpreters, callables);
-	}
-
-	wi->started_at = now;
-	wi->startup_time = uwsgi_now() - now;
-
-        uwsgi_log("PSGI app %d (%s) loaded in %d seconds at %p (interpreter %p)\n", id, app_name, (int) wi->startup_time, callables[0], interpreters[0]);
-	free(app_name);
-
-	// copy global data to app-specific areas
-	wi->stream = uperl.tmp_streaming_stash;
-	wi->input = uperl.tmp_input_stash;
-	wi->error = uperl.tmp_error_stash;
-	wi->responder0 = uperl.tmp_stream_responder;
-	wi->responder1 = uperl.tmp_psgix_logger;
-
-	uwsgi_emulate_cow_for_apps(id);
-
-
-	// restore context if required
-	if (interpreters != uperl.main) {
-		PERL_SET_CONTEXT(uperl.main[0]);
-	}
-
-	uperl.loaded = 1;
-
-	return id;
+	return uwsgi_perl_add_app(wsgi_req, app_name, interpreters, callables, now);
 
 clear:
 	if (interpreters != uperl.main) {
@@ -557,6 +484,44 @@ clear2:
        	return -1; 
 }
 
+int uwsgi_perl_add_app(struct wsgi_request *wsgi_req, char *app_name, PerlInterpreter **interpreters, SV **callables, time_t now) {
+	int id = uwsgi_apps_cnt;
+        struct uwsgi_app *wi = NULL;
+
+        if (wsgi_req) {
+                // we need a copy of app_id
+                wi = uwsgi_add_app(id, psgi_plugin.modifier1, uwsgi_concat2n(wsgi_req->appid, wsgi_req->appid_len, "", 0), wsgi_req->appid_len, interpreters, callables);
+        }
+        else {
+                wi = uwsgi_add_app(id, psgi_plugin.modifier1, "", 0, interpreters, callables);
+        }
+
+        wi->started_at = now;
+        wi->startup_time = uwsgi_now() - now;
+
+        uwsgi_log("PSGI app %d (%s) loaded in %d seconds at %p (interpreter %p)\n", id, app_name, (int) wi->startup_time, callables[0], interpreters[0]);
+        free(app_name);
+
+        // copy global data to app-specific areas
+        wi->stream = uperl.tmp_streaming_stash;
+        wi->input = uperl.tmp_input_stash;
+        wi->error = uperl.tmp_error_stash;
+        wi->responder0 = uperl.tmp_stream_responder;
+        wi->responder1 = uperl.tmp_psgix_logger;
+
+        uwsgi_emulate_cow_for_apps(id);
+
+
+        // restore context if required
+        if (interpreters != uperl.main) {
+                PERL_SET_CONTEXT(uperl.main[0]);
+        }
+
+        uperl.loaded = 1;
+
+        return id;
+}
+
 void uwsgi_psgi_preinit_apps() {
 	if (uperl.exec) {
 		PERL_SET_CONTEXT(uperl.main[0]);
@@ -572,6 +537,10 @@ void uwsgi_psgi_preinit_apps() {
 
 void uwsgi_psgi_app() {
 
+	if (uperl.early_psgi_callable) {
+		uwsgi_perl_add_app(NULL, uperl.early_psgi_app_name, uperl.main, uperl.early_psgi_callable, uwsgi_now());	
+	}
+
         if (uperl.psgi) {
 		//load app in the main interpreter list
 		init_psgi_app(NULL, uperl.psgi, strlen(uperl.psgi), uperl.main);
diff --git a/plugins/psgi/psgi_plugin.c b/plugins/psgi/psgi_plugin.c
index e241135..02e3c12 100644
--- a/plugins/psgi/psgi_plugin.c
+++ b/plugins/psgi/psgi_plugin.c
@@ -26,6 +26,45 @@ static void uwsgi_opt_plshell(char *opt, char *value, void *foobar) {
         }
 }
 
+EXTERN_C void xs_init (pTHX);
+int uwsgi_perl_init(void);
+
+static void uwsgi_opt_early_perl(char *opt, char *value, void *foobar) {
+	// avoid duplicates
+	if (uperl.early_interpreter) return;
+	uwsgi_perl_init();
+	uperl.early_interpreter = uperl.main[0];
+
+	// HACK the following allocations ensure correct xs initialization
+	uperl.tmp_streaming_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
+        uperl.tmp_input_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
+        uperl.tmp_error_stash = uwsgi_calloc(sizeof(HV *) * uwsgi.threads);
+        uperl.tmp_stream_responder = uwsgi_calloc(sizeof(CV *) * uwsgi.threads);
+        uperl.tmp_psgix_logger = uwsgi_calloc(sizeof(CV *) * uwsgi.threads);
+
+	char *perl_e_arg = uwsgi_concat2("#line 0 ", value);
+        char *perl_init_arg[] = { "", "-e", perl_e_arg };
+        perl_parse(uperl.early_interpreter, xs_init, 3, perl_init_arg, NULL);
+	free(perl_e_arg);
+}
+
+static void uwsgi_opt_early_psgi(char *opt, char *value, void *foobar) {
+	uwsgi_perl_init();
+	init_psgi_app(NULL, value, strlen(value), uperl.main);
+	if (!uperl.early_psgi_callable) exit(1);
+}
+
+static void uwsgi_opt_early_exec(char *opt, char *value, void *foobar) {
+        uwsgi_perl_init();
+	if (!uperl.early_interpreter) {
+        	perl_parse(uperl.main[0], xs_init, 3, uperl.embedding, NULL);
+	}
+        SV *dollar_zero = get_sv("0", GV_ADD);
+        sv_setsv(dollar_zero, newSVpv(value, strlen(value)));
+        uwsgi_perl_exec(value);
+}
+
+
 struct uwsgi_option uwsgi_perl_options[] = {
 
         {"psgi", required_argument, 0, "load a psgi app", uwsgi_opt_set_str, &uperl.psgi, 0},
@@ -46,6 +85,9 @@ struct uwsgi_option uwsgi_perl_options[] = {
         {"plshell-oneshot", no_argument, 0, "run a perl interactive shell (one shot)", uwsgi_opt_plshell, NULL, 0},
 
         {"perl-no-plack", no_argument, 0, "force the use of do instead of Plack::Util::load_psgi", uwsgi_opt_true, &uperl.no_plack, 0},
+        {"early-perl", required_argument, 0, "initialize an early perl interpreter shared by all loaders", uwsgi_opt_early_perl, NULL, UWSGI_OPT_IMMEDIATE},
+        {"early-psgi", required_argument, 0, "load a psgi app soon after uWSGI initialization", uwsgi_opt_early_psgi, NULL, UWSGI_OPT_IMMEDIATE},
+        {"early-perl-exec", required_argument, 0, "load a perl script soon after uWSGI initialization", uwsgi_opt_early_exec, NULL, UWSGI_OPT_IMMEDIATE},
         {0, 0, 0, 0, 0, 0, 0},
 
 };
@@ -114,7 +156,7 @@ SV *uwsgi_perl_obj_new(char *class, size_t class_len) {
 
 	SPAGAIN;
 
-	newobj = SvREFCNT_inc(POPs);
+	newobj = POPs;	
 	PUTBACK;
 	FREETMPS;
 	LEAVE;
@@ -363,7 +405,7 @@ SV *build_psgi_env(struct wsgi_request *wsgi_req) {
 
         if (!hv_store(env, "psgi.run_once", 13, newSViv(0), 0)) goto clear;
 
-        if (uwsgi.async > 1) {
+        if (uwsgi.async > 0) {
                 if (!hv_store(env, "psgi.nonblocking", 16, newSViv(1), 0)) goto clear;
         }
         else {
@@ -437,6 +479,10 @@ int uwsgi_perl_init(){
 	int argc;
 	int i;
 
+	if (uperl.main) {
+		goto already_initialized;
+	}
+
 	uperl.embedding[0] = "";
 	uperl.embedding[1] = "-e";
 	uperl.embedding[2] = "0";
@@ -477,6 +523,7 @@ int uwsgi_perl_init(){
 
 	PERL_SET_CONTEXT(uperl.main[0]);
 
+already_initialized:
 #ifdef PERL_VERSION_STRING
 	uwsgi_log_initial("initialized Perl %s main interpreter at %p\n", PERL_VERSION_STRING, uperl.main[0]);
 #else
@@ -494,7 +541,7 @@ int uwsgi_perl_request(struct wsgi_request *wsgi_req) {
 	}
 
 	/* Standard PSGI request */
-	if (!wsgi_req->uh->pktsize) {
+	if (!wsgi_req->len) {
 		uwsgi_log("Empty PSGI request. skip.\n");
 		return -1;
 	}
@@ -584,7 +631,7 @@ int uwsgi_perl_request(struct wsgi_request *wsgi_req) {
 	}
 
 	while (psgi_response(wsgi_req, wsgi_req->async_result) != UWSGI_OK) {
-		if (uwsgi.async > 1) {
+		if (uwsgi.async > 0) {
 			FREETMPS;
 			LEAVE;
 			return UWSGI_AGAIN;
@@ -661,21 +708,15 @@ void uwsgi_perl_after_request(struct wsgi_request *wsgi_req) {
 		if (SvTRUE(*harakiri)) wsgi_req->async_plagued = 1;
 	}
 
-	// Free the $env hash
-	SvREFCNT_dec(wsgi_req->async_environ);
-
 	// async plagued could be defined in other areas...
 	if (wsgi_req->async_plagued) {
 		uwsgi_log("*** psgix.harakiri.commit requested ***\n");
-		// Before we call exit(0) we'll run the
-		// uwsgi_perl_atexit() hook which'll properly tear
-		// down the interpreter.
-
-		// mark the request as ended (otherwise the atexit hook will be skipped)
-		uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].in_request = 0;
 		goodbye_cruel_world();
 	}
 
+	// clear the env
+	SvREFCNT_dec(wsgi_req->async_environ);
+
 	// now we can check for changed files
         if (uperl.auto_reload) {
                 time_t now = uwsgi_now();
@@ -809,39 +850,24 @@ void uwsgi_perl_run_hook(SV *hook) {
 }
 
 static void uwsgi_perl_atexit() {
-	int i;
-
 	if (uwsgi.mywid == 0) goto realstuff;
 
-        // if hijacked do not run atexit hooks -- TODO: explain why
-        // not.
+        // if hijacked do not run atexit hooks
         if (uwsgi.workers[uwsgi.mywid].hijacked)
-                goto destroyperl;
+                return;
 
-	// if busy do not run atexit hooks (as this part could be called in a signal handler
-	// while a subroutine is running)
+        // if busy do not run atexit hooks
         if (uwsgi_worker_is_busy(uwsgi.mywid))
                 return;
 
+        // managing atexit in async mode is a real pain...skip it for now
+        if (uwsgi.async > 0)
+                return;
 realstuff:
 
 	if (uperl.atexit) {
 		uwsgi_perl_run_hook(uperl.atexit);
 	}
-
-destroyperl:
-
-        // We must free our perl context(s) so any DESTROY hooks
-        // etc. will run.
-        for(i=0;i<uwsgi.threads;i++) {
-            PERL_SET_CONTEXT(uperl.main[i]);
-
-            // Destroy the PerlInterpreter, see "perldoc perlembed"
-            perl_destruct(uperl.main[i]);
-            perl_free(uperl.main[i]);
-        }
-        PERL_SYS_TERM();
-        free(uperl.main);
 }
 
 static uint64_t uwsgi_perl_rpc(void *func, uint8_t argc, char **argv, uint16_t argvs[], char **buffer) {
@@ -966,7 +992,15 @@ static int uwsgi_perl_spooler(char *filename, char *buf, uint16_t len, char *bod
 	return ret;
 }
 
+static int uwsgi_perl_hook_perl(char *arg) {
+	SV *ret = perl_eval_pv(arg, 0);
+	if (!ret) return -1;
+	return 0;
+}
 
+static void uwsgi_perl_register_features() {
+	uwsgi_register_hook("perl", uwsgi_perl_hook_perl);
+}
 
 struct uwsgi_plugin psgi_plugin = {
 
@@ -997,4 +1031,5 @@ struct uwsgi_plugin psgi_plugin = {
 	.magic = uwsgi_perl_magic,
 
 	.spooler = uwsgi_perl_spooler,
+	.on_load = uwsgi_perl_register_features,
 };
diff --git a/plugins/psgi/psgi_response.c b/plugins/psgi/psgi_response.c
index 5103579..648b396 100644
--- a/plugins/psgi/psgi_response.c
+++ b/plugins/psgi/psgi_response.c
@@ -148,7 +148,7 @@ int psgi_response(struct wsgi_request *wsgi_req, AV *response) {
                         chitem = SvPV( chunk, hlen);
                         if (hlen <= 0) {
 				SvREFCNT_dec(chunk);
-				if (uwsgi.async > 1 && wsgi_req->async_force_again) {
+				if (uwsgi.async > 0 && wsgi_req->async_force_again) {
 					wsgi_req->async_placeholder = (SV *) *hitem;
 					return UWSGI_AGAIN;
 				}
@@ -161,7 +161,7 @@ int psgi_response(struct wsgi_request *wsgi_req, AV *response) {
                                 break;
 			}
 			SvREFCNT_dec(chunk);
-			if (uwsgi.async > 1) {
+			if (uwsgi.async > 0) {
 				wsgi_req->async_placeholder = (SV *) *hitem;
 				wsgi_req->async_force_again = 1;
 				return UWSGI_AGAIN;
diff --git a/plugins/psgi/uwsgi_plmodule.c b/plugins/psgi/uwsgi_plmodule.c
index 480b32b..8d02ced 100644
--- a/plugins/psgi/uwsgi_plmodule.c
+++ b/plugins/psgi/uwsgi_plmodule.c
@@ -86,9 +86,11 @@ XS(XS_signal) {
 XS(XS_set_user_harakiri) {
         dXSARGS;
 
+	struct wsgi_request *wsgi_req = current_wsgi_req();
+
         psgi_check_args(1);
 
-	set_user_harakiri( SvIV(ST(0)) );
+	set_user_harakiri(wsgi_req, SvIV(ST(0)) );
 
         XSRETURN_UNDEF;
 }
@@ -318,13 +320,6 @@ XS(XS_alarm) {
         XSRETURN_UNDEF;
 }
 
-XS(XS_worker_id) {
-	dXSARGS;
-        psgi_check_args(0);
-	ST(0) = newSViv(uwsgi.mywid);	
-	XSRETURN(1);
-}
-
 XS(XS_async_connect) {
 
 	dXSARGS;
@@ -437,10 +432,10 @@ XS(XS_signal_wait) {
         wsgi_req->signal_received = -1;
 
 	if (items > 0) {
-                received_signal = uwsgi_signal_wait(SvIV(ST(0)));
+                received_signal = uwsgi_signal_wait(wsgi_req, SvIV(ST(0)));
         }
         else {
-                received_signal = uwsgi_signal_wait(-1);
+                received_signal = uwsgi_signal_wait(wsgi_req, -1);
         }
 
         if (received_signal < 0) {
@@ -1049,6 +1044,5 @@ void init_perl_embedded_module() {
 	psgi_xs(spool);
 
 	psgi_xs(add_var);
-	psgi_xs(worker_id);
 	
 }
diff --git a/plugins/pty/pty.c b/plugins/pty/pty.c
index 87d4f6b..a90965d 100644
--- a/plugins/pty/pty.c
+++ b/plugins/pty/pty.c
@@ -331,7 +331,7 @@ static int uwsgi_pty_client() {
 			if (upty.uremote) {
 				struct uwsgi_header uh;
 				uh.modifier1 = 0;
-				uh.pktsize = rlen;
+				uh._pktsize = rlen;
 				uh.modifier2 = 0;
 				if (write(upty.server_fd, &uh, 4) != 4) break;
 			}
diff --git a/plugins/pypy/pypy_plugin.c b/plugins/pypy/pypy_plugin.c
index 98164e6..8aafd24 100644
--- a/plugins/pypy/pypy_plugin.c
+++ b/plugins/pypy/pypy_plugin.c
@@ -66,34 +66,17 @@ static int uwsgi_pypy_init() {
 	}
 	else {
 		if (upypy.home) {
-			// first try with /bin way:
 #ifdef __CYGWIN__
-                        char *libpath = uwsgi_concat2(upypy.home, "/bin/libpypy-c.dll");
+                        char *libpath = uwsgi_concat2(upypy.home, "/libpypy-c.dll");
 #elif defined(__APPLE__)
-                        char *libpath = uwsgi_concat2(upypy.home, "/bin/libpypy-c.dylib");
+                        char *libpath = uwsgi_concat2(upypy.home, "/libpypy-c.dylib");
 #else
-                        char *libpath = uwsgi_concat2(upypy.home, "/bin/libpypy-c.so");
+                        char *libpath = uwsgi_concat2(upypy.home, "/libpypy-c.so");
 #endif
 			if (uwsgi_file_exists(libpath)) {
-                                upypy.handler = dlopen(libpath, RTLD_NOW | RTLD_GLOBAL);
-                        }
-                        free(libpath);
-
-			// fallback to old-style way
-			if (!upypy.handler) {
-			
-#ifdef __CYGWIN__
-                        	char *libpath = uwsgi_concat2(upypy.home, "/libpypy-c.dll");
-#elif defined(__APPLE__)
-                        	char *libpath = uwsgi_concat2(upypy.home, "/libpypy-c.dylib");
-#else
-                        	char *libpath = uwsgi_concat2(upypy.home, "/libpypy-c.so");
-#endif
-				if (uwsgi_file_exists(libpath)) {
-					upypy.handler = dlopen(libpath, RTLD_NOW | RTLD_GLOBAL);
-				}
-				free(libpath);
+				upypy.handler = dlopen(libpath, RTLD_NOW | RTLD_GLOBAL);
 			}
+			free(libpath);
 		}
 		// fallback to standard library search path
 		if (!upypy.handler) {
@@ -224,7 +207,7 @@ static void uwsgi_pypy_preinit_apps() {
 
 static int uwsgi_pypy_request(struct wsgi_request *wsgi_req) {
 	/* Standard WSGI request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log( "Empty pypy request. skip.\n");
                 return -1;
         }
diff --git a/plugins/pypy/pypy_setup.py b/plugins/pypy/pypy_setup.py
index ac83c75..67533dd 100644
--- a/plugins/pypy/pypy_setup.py
+++ b/plugins/pypy/pypy_setup.py
@@ -237,7 +237,7 @@ void uwsgi_disconnect(struct wsgi_request *);
 
 int uwsgi_ready_fd(struct wsgi_request *);
 
-void set_user_harakiri(int);
+void set_user_harakiri(struct wsgi_request *, int);
 
 int uwsgi_metric_set(char *, char *, int64_t);
 int uwsgi_metric_inc(char *, char *, int64_t);
@@ -918,7 +918,10 @@ uwsgi.chunked_read_nb = uwsgi_pypy_chunked_read_nb
 """
 uwsgi.set_user_harakiri(sec)
 """
-uwsgi.set_user_harakiri = lambda x: lib.set_user_harakiri(x)
+def uwsgi_pypy_set_user_harakiri(x):
+    wsgi_req = uwsgi_pypy_current_wsgi_req()
+    lib.set_user_harakiri(wsgi_req, x)
+uwsgi.set_user_harakiri = uwsgi_pypy_set_user_harakiri
 
 
 print "Initialized PyPy with Python", sys.version
@@ -977,7 +980,7 @@ def uwsgi_pypy_continulet_switch(wsgi_req):
     lib.uwsgi.wsgi_req = wsgi_req
     
 def uwsgi_pypy_setup_continulets():
-    if lib.uwsgi.async <= 1:
+    if lib.uwsgi.async < 1:
         raise Exception("pypy continulets require async mode !!!")
     lib.uwsgi.schedule_to_main = uwsgi_pypy_continulet_switch
     lib.uwsgi.schedule_to_req = uwsgi_pypy_continulet_schedule
diff --git a/plugins/python/pump_subhandler.c b/plugins/python/pump_subhandler.c
index 0e4f026..42a84ae 100644
--- a/plugins/python/pump_subhandler.c
+++ b/plugins/python/pump_subhandler.c
@@ -255,7 +255,7 @@ int uwsgi_response_subhandler_pump(struct wsgi_request *wsgi_req) {
 				goto clear;
 			}
 
-			if (uwsgi.async > 1) {
+			if (uwsgi.async > 0) {
 				return UWSGI_AGAIN;
 			}
 
diff --git a/plugins/python/python_plugin.c b/plugins/python/python_plugin.c
index 02c92ed..e30352f 100644
--- a/plugins/python/python_plugin.c
+++ b/plugins/python/python_plugin.c
@@ -63,6 +63,29 @@ void uwsgi_opt_pyver(char *opt, char *foo, void *bar) {
 	exit(0);
 }
 
+int uwsgi_python_init(void);
+void uwsgi_python_preinit_apps(void);
+static void uwsgi_early_python(char *opt, char *foo, void *bar) {
+	static int early_initialized = 0;
+	if (early_initialized) return;
+	early_initialized = 1;
+	uwsgi_python_init();
+	uwsgi_python_preinit_apps();
+}
+
+
+static void uwsgi_early_python_import(char *opt, char *module, void *bar) {
+	uwsgi_early_python(opt, NULL, NULL);
+	if (strchr(module, '/') || uwsgi_endswith(module, ".py")) {
+        	uwsgi_pyimport_by_filename(uwsgi_pythonize(module), module);
+        }
+        else {
+        	if (PyImport_ImportModule(module) == NULL) {
+                	PyErr_Print();
+                }
+	}
+}
+
 
 void uwsgi_opt_ini_paste(char *opt, char *value, void *foobar) {
 
@@ -170,6 +193,12 @@ struct uwsgi_option uwsgi_python_options[] = {
 
 	{"py-call-osafterfork", no_argument, 0, "enable child processes running cpython to trap OS signals", uwsgi_opt_true, &up.call_osafterfork, 0},
 
+	{"early-python", no_argument, 0, "load the python VM as soon as possible (useful for the fork server)", uwsgi_early_python, NULL, UWSGI_OPT_IMMEDIATE},
+	{"early-pyimport", required_argument, 0, "import a python module in the early phase", uwsgi_early_python_import, NULL, UWSGI_OPT_IMMEDIATE},
+	{"early-python-import", required_argument, 0, "import a python module in the early phase", uwsgi_early_python_import, NULL, UWSGI_OPT_IMMEDIATE},
+	{"early-pythonpath", required_argument, 0, "add directory (or glob) to pythonpath (immediate version)", uwsgi_opt_pythonpath, NULL,  UWSGI_OPT_IMMEDIATE},
+	{"early-python-path", required_argument, 0, "add directory (or glob) to pythonpath (immediate version)", uwsgi_opt_pythonpath, NULL,  UWSGI_OPT_IMMEDIATE},
+
 	{0, 0, 0, 0, 0, 0, 0},
 };
 
@@ -332,7 +361,7 @@ void uwsgi_python_atexit() {
 		return;
 
 	// managing atexit in async mode is a real pain...skip it for now
-	if (uwsgi.async > 1)
+	if (uwsgi.async > 0)
 		return;
 realstuff:
 
@@ -1042,6 +1071,10 @@ void uwsgi_python_destroy_env_holy(struct wsgi_request *wsgi_req) {
 
 // this hook will be executed by master (or worker1 when master is not requested, so COW is in place)
 void uwsgi_python_preinit_apps() {
+	struct uwsgi_string_list *upli = up.shared_import_list;
+
+	if (up.pre_initialized) goto ready;
+	up.pre_initialized = 1;
 
 	init_pyargv();
 
@@ -1073,8 +1106,9 @@ void uwsgi_python_preinit_apps() {
 
         init_uwsgi_vars();
 
+ready:
+
 	// load shared imports
-	struct uwsgi_string_list *upli = up.shared_import_list;
 	while(upli) {
 		if (strchr(upli->value, '/') || uwsgi_endswith(upli->value, ".py")) {
 			uwsgi_pyimport_by_filename(uwsgi_pythonize(upli->value), upli->value);
@@ -1097,7 +1131,7 @@ void uwsgi_python_init_apps() {
 	}
 
 	// prepare for stack suspend/resume
-	if (uwsgi.async > 1) {
+	if (uwsgi.async > 0) {
 		up.current_recursion_depth = uwsgi_malloc(sizeof(int)*uwsgi.async);
         	up.current_frame = uwsgi_malloc(sizeof(struct _frame)*uwsgi.async);
 	}
@@ -1425,15 +1459,7 @@ void *uwsgi_python_autoreloader_thread(void *foobar) {
 			int found = 0;
 			struct uwsgi_string_list *usl = up.auto_reload_ignore;
 			while(usl) {
-#ifdef PYTHREE
-				PyObject *zero = PyUnicode_AsUTF8String(mod_name);
-				char *str_mod_name = PyString_AsString(zero);
-				int ret_cmp = strcmp(usl->value, str_mod_name);
-				Py_DECREF(zero);
-				if (!ret_cmp) {
-#else
 				if (!strcmp(usl->value, PyString_AsString(mod_name))) {
-#endif
 					found = 1;
 					break;
 				}
diff --git a/plugins/python/pyutils.c b/plugins/python/pyutils.c
index f4b1ef3..400c9f4 100644
--- a/plugins/python/pyutils.c
+++ b/plugins/python/pyutils.c
@@ -289,7 +289,7 @@ int uwsgi_python_call(struct wsgi_request *wsgi_req, PyObject *callable, PyObjec
 
 	if (wsgi_req->async_result) {
 		while ( manage_python_response(wsgi_req) != UWSGI_OK) {
-			if (uwsgi.async > 1) {
+			if (uwsgi.async > 0) {
 				return UWSGI_AGAIN;
 			}
 		}
diff --git a/plugins/python/raw.c b/plugins/python/raw.c
index c577bf1..47f66d2 100644
--- a/plugins/python/raw.c
+++ b/plugins/python/raw.c
@@ -71,7 +71,7 @@ int uwsgi_request_python_raw(struct wsgi_request *wsgi_req) {
 			int ret = manage_raw_response(wsgi_req);
 			if (ret == UWSGI_AGAIN) {
 				wsgi_req->async_force_again = 1;
-				if (uwsgi.async > 1) {
+				if (uwsgi.async > 0) {
 					UWSGI_RELEASE_GIL return UWSGI_AGAIN;
 				}
 				continue;
diff --git a/plugins/python/uwsgi_pymodule.c b/plugins/python/uwsgi_pymodule.c
index 97e5da2..34f4df8 100644
--- a/plugins/python/uwsgi_pymodule.c
+++ b/plugins/python/uwsgi_pymodule.c
@@ -46,10 +46,10 @@ static PyObject *py_uwsgi_signal_wait(PyObject * self, PyObject * args) {
 	UWSGI_RELEASE_GIL;
 
 	if (wait_for_specific_signal) {
-		received_signal = uwsgi_signal_wait(uwsgi_signal);
+		received_signal = uwsgi_signal_wait(wsgi_req, uwsgi_signal);
 	}
 	else {
-		received_signal = uwsgi_signal_wait(-1);
+		received_signal = uwsgi_signal_wait(wsgi_req, -1);
 	}
 
 	if (received_signal < 0) {
@@ -893,12 +893,13 @@ PyObject *py_uwsgi_log(PyObject * self, PyObject * args) {
 }
 
 PyObject *py_uwsgi_set_user_harakiri(PyObject * self, PyObject * args) {
+	struct wsgi_request *wsgi_req = py_current_wsgi_req();
 	int sec = 0;
 	if (!PyArg_ParseTuple(args, "i:set_user_harakiri", &sec)) {
                 return NULL;
         }
 
-	set_user_harakiri(sec);
+	set_user_harakiri(wsgi_req, sec);
 
         Py_INCREF(Py_None);
         return Py_None;
@@ -1654,7 +1655,6 @@ PyObject *py_uwsgi_sharedarea_read64(PyObject * self, PyObject * args) {
         }
 
 	return PyLong_FromLongLong(value);
-
 }
 
 PyObject *py_uwsgi_sharedarea_read32(PyObject * self, PyObject * args) {
@@ -2339,14 +2339,14 @@ PyObject *py_uwsgi_parse_file(PyObject * self, PyObject * args) {
 		goto clear2;
 	}
 
-	buffer = malloc(uh.pktsize);
+	buffer = malloc(uh._pktsize);
 	if (!buffer) {
 		uwsgi_error("malloc()");
 		UWSGI_GET_GIL
 		goto clear2;
 	}
-	len = read(fd, buffer, uh.pktsize);
-	if (len != uh.pktsize) {
+	len = read(fd, buffer, uh._pktsize);
+	if (len != uh._pktsize) {
 		uwsgi_error("read()");
 		free(buffer);
 		UWSGI_GET_GIL
@@ -2356,7 +2356,7 @@ PyObject *py_uwsgi_parse_file(PyObject * self, PyObject * args) {
 	UWSGI_GET_GIL
 
 	ptrbuf = buffer;
-	bufferend = ptrbuf + uh.pktsize;
+	bufferend = ptrbuf + uh._pktsize;
 
 	if (!uh.modifier1 || uh.modifier1 == UWSGI_MODIFIER_SPOOL_REQUEST) {
 		zero = PyDict_New();
diff --git a/plugins/python/uwsgi_python.h b/plugins/python/uwsgi_python.h
index fb38565..430fde6 100644
--- a/plugins/python/uwsgi_python.h
+++ b/plugins/python/uwsgi_python.h
@@ -199,6 +199,7 @@ struct uwsgi_python {
 	struct uwsgi_string_list *sharedarea;
 
 	int call_osafterfork;
+	int pre_initialized;
 };
 
 
diff --git a/plugins/python/web3_subhandler.c b/plugins/python/web3_subhandler.c
index 231a538..48fe162 100644
--- a/plugins/python/web3_subhandler.c
+++ b/plugins/python/web3_subhandler.c
@@ -164,7 +164,7 @@ int uwsgi_response_subhandler_web3(struct wsgi_request *wsgi_req) {
 			if (!wsgi_req->async_placeholder) {
 				goto clear;
 			}
-			if (uwsgi.async > 1) {
+			if (uwsgi.async > 0) {
 				return UWSGI_AGAIN;
 			}
 		}
diff --git a/plugins/python/wsgi_handlers.c b/plugins/python/wsgi_handlers.c
index badb1ae..c9bb2db 100644
--- a/plugins/python/wsgi_handlers.c
+++ b/plugins/python/wsgi_handlers.c
@@ -326,7 +326,7 @@ int uwsgi_request_wsgi(struct wsgi_request *wsgi_req) {
 	}
 
 	/* Standard WSGI request */
-	if (!wsgi_req->uh->pktsize) {
+	if (!wsgi_req->len) {
 		uwsgi_log( "Empty python request. skip.\n");
 		return -1;
 	}
@@ -405,7 +405,7 @@ int uwsgi_request_wsgi(struct wsgi_request *wsgi_req) {
 
 
 		while (wi->response_subhandler(wsgi_req) != UWSGI_OK) {
-			if (uwsgi.async > 1) {
+			if (uwsgi.async > 0) {
 				UWSGI_RELEASE_GIL
 				wsgi_req->async_force_again = 1;
 				return UWSGI_AGAIN;
@@ -442,8 +442,8 @@ void uwsgi_after_request_wsgi(struct wsgi_request *wsgi_req) {
 	if (up.after_req_hook) {
 		if (uwsgi.harakiri_no_arh) {
 			// leave harakiri mode
-        		if (uwsgi.workers[uwsgi.mywid].harakiri > 0)
-                		set_harakiri(0);
+        		if (uwsgi.workers[uwsgi.mywid].cores[wsgi_req->async_id].harakiri > 0)
+                		set_harakiri(wsgi_req, 0);
 		}
 		UWSGI_GET_GIL
 		PyObject *arh = python_call(up.after_req_hook, up.after_req_hook_args, 0, NULL);
diff --git a/plugins/python/wsgi_subhandler.c b/plugins/python/wsgi_subhandler.c
index 7eb57b0..3112ddb 100644
--- a/plugins/python/wsgi_subhandler.c
+++ b/plugins/python/wsgi_subhandler.c
@@ -170,7 +170,7 @@ void *uwsgi_request_subhandler_wsgi(struct wsgi_request *wsgi_req, struct uwsgi_
 
 	PyDict_SetItemString(wsgi_req->async_environ, "wsgi.file_wrapper", wi->sendfile);
 
-	if (uwsgi.async > 1) {
+	if (uwsgi.async > 0) {
 		PyDict_SetItemString(wsgi_req->async_environ, "x-wsgiorg.fdevent.readable", wi->eventfd_read);
 		PyDict_SetItemString(wsgi_req->async_environ, "x-wsgiorg.fdevent.writable", wi->eventfd_write);
 		PyDict_SetItemString(wsgi_req->async_environ, "x-wsgiorg.fdevent.timeout", Py_None);
@@ -269,7 +269,7 @@ int uwsgi_response_subhandler_wsgi(struct wsgi_request *wsgi_req) {
 		if (!wsgi_req->async_placeholder) {
 			goto exception;
 		}
-		if (uwsgi.async > 1) {
+		if (uwsgi.async > 0) {
 			return UWSGI_AGAIN;
 		}
 	}
diff --git a/plugins/pyuwsgi/pyuwsgi.c b/plugins/pyuwsgi/pyuwsgi.c
index 02a0332..2f248f4 100644
--- a/plugins/pyuwsgi/pyuwsgi.c
+++ b/plugins/pyuwsgi/pyuwsgi.c
@@ -1,75 +1,325 @@
 #include "../python/uwsgi_python.h"
 
+//FIXME: [upstream:python] needs PyAPI_FUNC(void)
+extern void Py_GetArgcArgv(int *, char ***);
+
 extern struct uwsgi_server uwsgi;
 extern struct uwsgi_python up;
 
 extern char **environ;
 
-PyObject *u_run(PyObject *self, PyObject *args) {
+static int new_argc = -1;
+static int orig_argc = -1;
+static char **new_argv = NULL;
+static char **orig_argv = NULL;
+static char *new_argv_buf = NULL;
 
-        char **argv;
-        size_t size = 2;
-        int i;
 
-        if (PyTuple_Size(args) < 1) {
-		return PyErr_Format(PyExc_ValueError, "you have to specify at least one uWSGI option to run() it");
-	}
+PyObject *
+pyuwsgi_setup(PyObject *self, PyObject *args, PyObject *kwds)
+{
+    if (new_argv) {
+        PyErr_SetString(
+            PyExc_RuntimeError,
+            "uWSGI already setup"
+            );
+        return NULL;
+    }
 
-	PyObject *the_arg = PyTuple_GetItem(args, 0);
+    if (uwsgi.mywid) {
+        PyErr_SetString(
+            PyExc_RuntimeError,
+            "uWSGI must be setup by master"
+            );
+        return NULL;
+    }
 
-	if (PyList_Check(the_arg)) {
-        	size = PyList_Size(the_arg) + 2;
-	}
-	else if (PyTuple_Check(the_arg)) {
-        	size = PyTuple_Size(the_arg) + 2;
-	}
-	else if (PyString_Check(the_arg)) {
-		size = 3;
-	}
+    PyObject *iterator;
 
-        argv = uwsgi_malloc(sizeof(char *) * size);
-        memset(argv, 0, sizeof(char *) * size);
+    if (args == NULL || PyObject_Size(args) == 0) {
+        PyObject *argv = PySys_GetObject("argv");
+        if (argv == NULL)
+            return NULL;
 
-        // will be overwritten
-        argv[0] = "uwsgi";
+        // during site.py maybe
+        if (argv == Py_None) {
+            argv = PyTuple_New(0);
+            iterator = PyObject_GetIter(argv);
+            Py_DECREF(argv);
+        }
+        else {
+            iterator = PyObject_GetIter(argv);
+            if (PyObject_Size(argv) > 0) {
+                // forward past argv0
+                PyObject *item = PyIter_Next(iterator);
+                Py_DECREF(item);
+            }
+        }
+    }
+    else if (
+        PyObject_Size(args) == 1
+        && !PyString_Check(PyTuple_GetItem(args, 0))
+        ) {
+        iterator = PyObject_GetIter(PyTuple_GetItem(args, 0));
+    }
+    else {
+        iterator = PyObject_GetIter(args);
+    }
 
-	if (PyList_Check(the_arg)) {
-        	for(i=0;i<PyList_Size(the_arg);i++) {
-                	argv[i+1] = PyString_AsString( PyList_GetItem(the_arg, i) );
-        	}
-	}
-	else if (PyTuple_Check(the_arg)) {
-        	for(i=0;i<PyTuple_Size(the_arg);i++) {
-                	argv[i+1] = PyString_AsString( PyTuple_GetItem(the_arg, i) );
-        	}
-	}
-	else if (PyString_Check(the_arg)) {
-		argv[1] = PyString_AsString( the_arg );
-	}
+    if (iterator == NULL) {
+        return NULL;
+    }
+
+    size_t size = 1;
+    //FIXME: ARGS prior to and including -c/-m are REQUIRED!
+    PyObject *item = PyString_FromString(orig_argv[0]);
+    PyObject *args_li = PyList_New(0);
+    PyList_Append(args_li, item);
+    size += strlen(orig_argv[0]) + 1;
+    Py_DECREF(item);
+
+    while ((item = PyIter_Next(iterator))) {
+        //TODO: call str(...) on everything
+        PyList_Append(args_li, item);
+        size += PyObject_Length(item) + 1;
+        Py_DECREF(item);
+    }
+
+    Py_DECREF(iterator);
+
+    new_argc = PyObject_Length(args_li);
+    new_argv = uwsgi_calloc(sizeof(char *) * (new_argc + 1));
+    new_argv_buf = uwsgi_calloc(size);
+
+    int i = 0;
+    char *new_argv_ptr = new_argv_buf;
+    for(i=0; i < new_argc; i++) {
+        PyObject *arg = PyList_GetItem(args_li, i);
+        char *arg_str = PyString_AsString(arg);
+        new_argv[i] = new_argv_ptr;
+        strcpy(new_argv_ptr, arg_str);
+        new_argv_ptr += strlen(arg_str) + 1;
+    }
+
+    PyObject *args_tup = PyList_AsTuple(args_li);
+    PyObject_SetAttrString(self, "NEW_ARGV", args_tup);
+    Py_DECREF(args_tup);
+    Py_DECREF(args_li);
+
+    // TODO: convention here is a goto methinks?
+    if (PyErr_Occurred()) {
+        free(new_argv_buf);
+        free(new_argv);
+        new_argv = 0;
+        new_argc = 0;
+        return NULL;
+    }
 
-        uwsgi_init(size-1, argv, environ);
+    //TODO: ...???
+    // actually do the thing!
+    PyThreadState *_tstate = PyThreadState_Get();
+    uwsgi_setup(orig_argc, orig_argv, environ);
+    PyThreadState_Swap(_tstate);
 
-        Py_INCREF(Py_None);
-        return Py_None;
+    Py_INCREF(self);
+    return self;
 }
 
+
+PyObject *
+pyuwsgi_init(PyObject *self, PyObject *args, PyObject *kwds)
+{
+    if (pyuwsgi_setup(self, args, kwds) == NULL) {
+        return NULL;
+    }
+
+    int rc = uwsgi_run();
+
+    // never(?) here
+    return Py_BuildValue("i", rc);
+}
+
+
+PyObject *
+pyuwsgi_run(PyObject *self, PyObject *args, PyObject *kwds)
+{
+    // backcompat
+    if (new_argv == NULL &&
+        pyuwsgi_setup(self, args, kwds) == NULL) {
+        return NULL;
+    }
+
+    int rc = uwsgi_run();
+
+    // never(?) here
+    return Py_BuildValue("i", rc);
+}
+
+
 PyMethodDef methods[] = {
-    {"run", u_run, METH_VARARGS, "run the uWSGI server"},
+    {"run",
+        (PyCFunction) pyuwsgi_run,
+        METH_VARARGS | METH_KEYWORDS,
+     "run(...)"
+     "\n>>> 0"
+     "\n"
+     "\n * Call setup(...) if not configured"
+     "\n * Begin uWSGI mainloop"
+     "\n   NOTE: will not return"
+     "\n"
+    },
+    {"init",
+        (PyCFunction) pyuwsgi_init,
+        METH_VARARGS | METH_KEYWORDS,
+     "init(...)"
+     "\n>>> 0"
+     "\n"
+     "\n * Call setup(...)"
+     "\n * Begin uWSGI mainloop"
+     "\n   NOTE: will not return"
+     "\n"
+    },
+    {"setup",
+        (PyCFunction) pyuwsgi_setup,
+        METH_VARARGS | METH_KEYWORDS,
+     "setup('--master', ...)"
+     "\n>>> <module 'uwsgi' from \"uwsgi.so\">"
+     "\n"
+     "\n * Initialize uWSGI core with (...)"
+     "\n   MUST only call once          [RuntimeException]"
+     "\n   MUST only call from master   [RuntimeException]"
+     "\n"
+    },
     {NULL, NULL, 0, NULL}
 };
 
+
+static void
+pyuwsgi_set_orig_argv(PyObject *self)
+{
+
+    //  ask python for the original argc/argv saved in Py_Main()
+    Py_GetArgcArgv(&orig_argc, &orig_argv);
+
+    //  [re?]export to uwsgi.orig_argv
+    PyObject *m_orig_argv;
+    m_orig_argv = PyTuple_New(orig_argc);
+
+    int i = 0;
+    int i_cm = -1;
+
+    for(i=0; i < orig_argc; i++) {
+        char *arg = orig_argv[i];
+        //XXX: _PyOS_optarg != 0 also indicates python quit early...
+        //FIXME: [upstream:python] orig_argv could be mangled; reset
+        // rel: http://bugs.python.org/issue8202
+        orig_argv[i + 1] = arg + strlen(arg) + 1;
+
+        // look for -c or -m and record the offset
+        if (i_cm < 0) {
+            if (strcmp(arg, "-c") || strcmp(arg, "-m")) {
+                // python's getopt would've failed had + 1 not exist
+                i_cm = i + 1;
+            }
+            else if (!uwsgi_startswith(arg, "-c", 2) ||
+                     !uwsgi_startswith(arg, "-m", 2)) {
+                //FIXME: ARGS prior to and including -c/-m are REQUIRED,
+                // but NOT a part of the uWSGI argv! Needed to make
+                // exec*() self-referential: exec*(...) -> uwsgi
+                //
+                // want: uwsgi.binary_argv[:] + uwsgi.argv[:]!
+                //       binary_argv = [binary_path] + args
+                i_cm = i;
+            }
+        }
+
+        PyTuple_SetItem(m_orig_argv, i, PyString_FromString(arg));
+    }
+
+    //TODO: howto properly detect uwsgi already running...
+    // orig_argv == uwsgi.orig_argv (?)
+    // ^^^ but if Py_Main not called, python/main.c:orig_argv unset
+    // howto interact/detect things in general
+    PyObject *m_new_argv = PyTuple_New(0);
+    PyObject_SetAttrString(self, "NEW_ARGV", m_new_argv);
+    PyObject_SetAttrString(self, "ORIG_ARGV", m_orig_argv);
+    Py_DECREF(m_new_argv);
+    Py_DECREF(m_orig_argv);
+}
+
+
+static PyObject *
+pyuwsgi_init_as(char *mod_name)
+{
+
+    PyObject *m;
+
+    m = PyImport_GetModuleDict();
+    if (m == NULL) {
+        return NULL;
+    }
+
+    m = PyDict_GetItemString(m, mod_name);
+    if (!m) {
+        m = Py_InitModule(mod_name, NULL);
+	}
+
+    if (orig_argc < 0) {
+        pyuwsgi_set_orig_argv(m);
+    }
+
+    int i;
+    for (i=0; methods[i].ml_name != NULL; i++) {
+        PyObject *fun = PyObject_GetAttrString(m, methods[i].ml_name);
+        if (fun != NULL) {
+            // already exists
+            Py_DECREF(fun);
+            continue;
+        }
+
+        PyErr_Clear();
+
+        //  rel: Python/modsupport.c:Py_InitModule4
+        PyObject* name = PyString_FromString(methods[i].ml_name);
+        //  fun(self, ...)
+        fun = PyCFunction_NewEx(&methods[i], m, name);
+        Py_DECREF(name);
+        //  module.fun
+        PyObject_SetAttrString(m, methods[i].ml_name, fun);
+        Py_DECREF(fun);
+    }
+
+    return m;
+}
+
+
 PyMODINIT_FUNC
 initpyuwsgi()
 {
-    (void) Py_InitModule("pyuwsgi", methods);
+    (void) pyuwsgi_init_as("pyuwsgi");
 }
 
 
-int pyuwsgi_init() { return 0; }
+// allow the module to be called `uwsgi`
+PyMODINIT_FUNC
+inituwsgi()
+{
+    (void) pyuwsgi_init_as("uwsgi");
+}
+
+
+void pyuwsgi_load()
+{
+    if (new_argc > -1) {
+        uwsgi.new_argc = new_argc;
+        uwsgi.new_argv = new_argv;
+    }
+}
+
 
 struct uwsgi_plugin pyuwsgi_plugin = {
 
         .name = "pyuwsgi",
-        .init = pyuwsgi_init,
+        .on_load = pyuwsgi_load,
 };
 
diff --git a/plugins/rack/rack_api.c b/plugins/rack/rack_api.c
index befebeb..6a1396e 100644
--- a/plugins/rack/rack_api.c
+++ b/plugins/rack/rack_api.c
@@ -110,7 +110,8 @@ static VALUE rack_uwsgi_warning(VALUE *class, VALUE rbmessage) {
 
 static VALUE rack_uwsgi_user_harakiri(VALUE *class, VALUE sec) {
         Check_Type(sec, T_FIXNUM);
-	set_user_harakiri(NUM2INT(sec));
+	struct wsgi_request *wsgi_req = current_wsgi_req();
+	set_user_harakiri(wsgi_req, NUM2INT(sec));
         return Qnil;
 }
 
@@ -765,10 +766,10 @@ static VALUE uwsgi_ruby_signal_wait(int argc, VALUE *argv, VALUE *class) {
         }
 
         if (wait_for_specific_signal) {
-                received_signal = uwsgi_signal_wait(uwsgi_signal);
+                received_signal = uwsgi_signal_wait(wsgi_req, uwsgi_signal);
         }
         else {
-                received_signal = uwsgi_signal_wait(-1);
+                received_signal = uwsgi_signal_wait(wsgi_req, -1);
         }
 
 	if (received_signal < 0) {
diff --git a/plugins/rack/rack_plugin.c b/plugins/rack/rack_plugin.c
index bab2e2a..2719db7 100644
--- a/plugins/rack/rack_plugin.c
+++ b/plugins/rack/rack_plugin.c
@@ -814,7 +814,7 @@ int uwsgi_rack_request(struct wsgi_request *wsgi_req) {
 	}
 
 	/* Standard RACK request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log("Empty RACK request. skip.\n");
                 return -1;
         }
diff --git a/plugins/rados/rados.c b/plugins/rados/rados.c
index 55ca93e..b8eb390 100644
--- a/plugins/rados/rados.c
+++ b/plugins/rados/rados.c
@@ -46,6 +46,7 @@ struct uwsgi_rados_mountpoint {
 	char *allow_put;
 	char *allow_delete;
 	char *allow_mkcol;
+	char *allow_propfind;
 };
 
 static struct uwsgi_option uwsgi_rados_options[] = {
@@ -89,7 +90,7 @@ static void uwsgi_rados_read_async_cb(rados_completion_t comp, void *data) {
 }
 
 static int uwsgi_rados_delete(struct wsgi_request *wsgi_req, rados_ioctx_t ctx, char *key, int timeout) {
-	if (uwsgi.async <= 1) {
+	if (uwsgi.async < 1) {
 		return rados_remove(ctx, key); 
 	}
 	struct uwsgi_rados_io *urio = &urados.urio[wsgi_req->async_id];
@@ -133,7 +134,6 @@ static int uwsgi_rados_delete(struct wsgi_request *wsgi_req, rados_ioctx_t ctx,
                 ret = rados_aio_get_return_value(comp);
         }
         rados_aio_release(comp);
-
 end:
       	return ret;
 }
@@ -146,7 +146,7 @@ static int uwsgi_rados_put(struct wsgi_request *wsgi_req, rados_ioctx_t ctx, cha
                 ssize_t body_len = 0;
                 char *body =  uwsgi_request_body_read(wsgi_req, UMIN(remains, 32768) , &body_len);
                 if (!body || body == uwsgi.empty) goto error;
-		if (uwsgi.async <= 1) {
+		if (uwsgi.async < 1) {
 			if (rados_write_full(ctx, key, body, body_len) < 0) {
 				return -1;
 			}
@@ -313,6 +313,86 @@ static int uwsgi_rados_read_async(struct wsgi_request *wsgi_req, rados_ioctx_t c
 	return ret;	
 }
 
+static void uwsgi_rados_propfind(struct wsgi_request *wsgi_req, rados_ioctx_t ctx, char *key, uint64_t size, time_t mtime, int timeout) {
+	// consume the body
+	size_t remains = wsgi_req->post_cl;
+        while(remains > 0) {
+                ssize_t body_len = 0;
+                char *body =  uwsgi_request_body_read(wsgi_req, UMIN(remains, 32768), &body_len);
+                if (!body || body == uwsgi.empty) break;
+		remains -= body_len;
+	}
+
+	if (uwsgi_response_prepare_headers(wsgi_req, "207 Multi-Status", 16)) return;
+	if (uwsgi_response_add_content_type(wsgi_req, "text/xml; charset=\"utf-8\"", 25)) return;
+	struct uwsgi_buffer *ub = uwsgi_webdav_multistatus_new();
+	if (!ub) return;
+	if (key) {
+		size_t mime_type_len = 0;
+        	char *mime_type = uwsgi_get_mime_type(key, strlen(key), &mime_type_len);
+		char *slashed = uwsgi_concat2("/", key);
+		if (uwsgi_webdav_propfind_item_add(ub, slashed, strlen(key)+1, size, mtime, mime_type, mime_type_len, NULL, 0, NULL, 0)) {
+			free(slashed);
+			goto end;
+		}
+		free(slashed);
+		if (uwsgi_webdav_multistatus_close(ub)) goto end;
+		uwsgi_response_write_body_do(wsgi_req, ub->buf, ub->pos);
+		goto end;
+	}
+	// request for /
+	size_t depth = 0;
+	uint16_t http_depth_len = 0;
+        char *http_depth = uwsgi_get_var(wsgi_req, "HTTP_DEPTH", 10, &http_depth_len);
+        if (http_depth) {
+                depth = uwsgi_str_num(http_depth, http_depth_len);
+        }
+
+	if (depth == 0) {
+		if (uwsgi_webdav_propfind_item_add(ub, "/", 1, 0, 0, NULL, 0, NULL, 0, NULL, 0)) {
+                        goto end;
+                }
+                if (uwsgi_webdav_multistatus_close(ub)) goto end;
+                uwsgi_response_write_body_do(wsgi_req, ub->buf, ub->pos);
+		goto end;
+	}
+
+	struct uwsgi_rados_io *urio = &urados.urio[wsgi_req->async_id];
+	rados_list_ctx_t ctx_list;
+	if (rados_objects_list_open(ctx, &ctx_list) < 0) {
+		goto end;
+	}
+
+	char *entry = NULL;
+	while(rados_objects_list_next(ctx_list, (const char **)&entry, NULL) == 0) {
+		uint64_t stat_size = 0;
+		time_t stat_mtime = 0;
+		if (uwsgi.async > 0) {
+        		if (uwsgi_rados_async_stat(urio, ctx, entry, &stat_size, &stat_mtime, timeout) < 0) goto end;
+        	}
+        	else {
+                	if (rados_stat(ctx, entry, &stat_size, &stat_mtime) < 0) goto end;
+        	}
+
+		size_t mime_type_len = 0;
+                char *mime_type = uwsgi_get_mime_type(entry, strlen(entry), &mime_type_len);
+                char *slashed = uwsgi_concat2("/", entry);
+                if (uwsgi_webdav_propfind_item_add(ub, slashed, strlen(entry)+1, stat_size, stat_mtime, mime_type, mime_type_len, NULL, 0, NULL, 0)) {
+                        free(slashed);
+                        goto end;
+                }
+                free(slashed);
+                if (uwsgi_response_write_body_do(wsgi_req, ub->buf, ub->pos)) goto end;
+		// reset buffer;
+		ub->pos = 0;
+	}
+	rados_objects_list_close(ctx_list);
+        if (uwsgi_webdav_multistatus_close(ub)) goto end;
+        uwsgi_response_write_body_do(wsgi_req, ub->buf, ub->pos);
+
+end:
+	uwsgi_buffer_destroy(ub);
+}
 
 static void uwsgi_rados_add_mountpoint(char *arg, size_t arg_len) {
 	struct uwsgi_rados_mountpoint *urmp = uwsgi_calloc(sizeof(struct uwsgi_rados_mountpoint));
@@ -324,6 +404,7 @@ static void uwsgi_rados_add_mountpoint(char *arg, size_t arg_len) {
 			"allow_put", &urmp->allow_put,
 			"allow_delete", &urmp->allow_delete,
 			"allow_mkcol", &urmp->allow_mkcol,
+			"allow_propfind", &urmp->allow_propfind,
 			NULL)) {
 				uwsgi_log("unable to parse rados mountpoint definition\n");
 				exit(1);
@@ -431,7 +512,7 @@ static void uwsgi_rados_setup() {
 	}
 
 	// now initialize a pthread_mutex for each async core
-	if (uwsgi.async > 1) {
+	if (uwsgi.async > 0) {
 		int i;
 		urados.urio = uwsgi_calloc(sizeof(struct uwsgi_rados_io) * uwsgi.async);
 		for(i=0;i<uwsgi.async;i++) {
@@ -448,7 +529,7 @@ static void uwsgi_rados_setup() {
 
 static int uwsgi_rados_request(struct wsgi_request *wsgi_req) {
 	char filename[PATH_MAX+1];
-	if (!wsgi_req->uh->pktsize) {
+	if (!wsgi_req->len) {
 		uwsgi_log( "Empty request. skip.\n");
 		return -1;
 	}
@@ -502,7 +583,7 @@ static int uwsgi_rados_request(struct wsgi_request *wsgi_req) {
 
 	struct uwsgi_rados_io *urio = &urados.urio[wsgi_req->async_id];
 
-	if (uwsgi.async > 1) {
+	if (uwsgi.async > 0) {
 	// no need to lock here (the rid protect us)
         	if (pipe(urio->fds)) {
                 	uwsgi_error("uwsgi_rados_read_async()/pipe()");
@@ -540,12 +621,28 @@ static int uwsgi_rados_request(struct wsgi_request *wsgi_req) {
 				goto end;
 			}
 		}
+		if (urmp->allow_propfind) {
+			if (uwsgi_buffer_append(ub_allow, ", PROPFIND", 10)) {
+				uwsgi_buffer_destroy(ub_allow);
+				goto end;
+			}
+		}
 
 		uwsgi_response_add_header(wsgi_req, "Allow", 5, ub_allow->buf, ub_allow->pos);
 		uwsgi_buffer_destroy(ub_allow);
                 goto end;
 	}
 
+	// empty paths are mapped to propfind
+	if (wsgi_req->path_info_len == 1 && wsgi_req->path_info[0] == '/') {
+		if (urmp->allow_propfind && !uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "PROPFIND", 8)) {
+			uwsgi_rados_propfind(wsgi_req, ctx, NULL, 0, 0, timeout);
+			goto end;
+		}
+                uwsgi_405(wsgi_req);
+		goto end;
+	}
+
 	// MKCOL does not require stat
 	if (!uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "MKCOL", 5)) {
                 if (!urmp->allow_mkcol) {
@@ -566,7 +663,7 @@ static int uwsgi_rados_request(struct wsgi_request *wsgi_req) {
                 goto end;
 	}
 
-	if (uwsgi.async > 1) {
+	if (uwsgi.async > 0) {
 		ret = uwsgi_rados_async_stat(urio, ctx, filename, &stat_size, &stat_mtime, timeout);	
 	}
 	else {
@@ -613,6 +710,15 @@ static int uwsgi_rados_request(struct wsgi_request *wsgi_req) {
 		goto end;
 	}
 
+	if (!uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "PROPFIND", 8)) {
+		if (!urmp->allow_propfind) {
+			uwsgi_405(wsgi_req);
+                        goto end;
+		}
+		uwsgi_rados_propfind(wsgi_req, ctx, filename, stat_size, stat_mtime, timeout);
+		goto end;
+	}
+
 	if (uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "HEAD", 4) && uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "GET", 3)) {
 		uwsgi_405(wsgi_req);
 		goto end;
@@ -631,7 +737,7 @@ static int uwsgi_rados_request(struct wsgi_request *wsgi_req) {
 	// skip body on HEAD
 	if (uwsgi_strncmp(wsgi_req->method, wsgi_req->method_len, "HEAD", 4)) {
 		size_t remains = stat_size;
-		if (uwsgi.async > 1) {
+		if (uwsgi.async > 0) {
 			if (uwsgi_rados_read_async(wsgi_req, ctx, filename, remains, timeout)) goto end;
 		}
 		else {
@@ -640,7 +746,7 @@ static int uwsgi_rados_request(struct wsgi_request *wsgi_req) {
 	}
 
 end:
-	if (uwsgi.async > 1) {
+	if (uwsgi.async > 0) {
 		close(urio->fds[0]);
 		close(urio->fds[1]);
 	}
diff --git a/plugins/rawrouter/rawrouter.c b/plugins/rawrouter/rawrouter.c
index dd433f2..d3b4ad5 100644
--- a/plugins/rawrouter/rawrouter.c
+++ b/plugins/rawrouter/rawrouter.c
@@ -245,7 +245,7 @@ static int rawrouter_alloc_session(struct uwsgi_corerouter *ucr, struct uwsgi_ga
 	peer->last_hook_read = rr_instance_read;
 
 	// use the address as hostname
-        memcpy(peer->key, cs->ugs->name, cs->ugs->name_len);
+        peer->key = cs->ugs->name;
         peer->key_len = cs->ugs->name_len;
 
         // the mapper hook
diff --git a/plugins/router_http/router_http.c b/plugins/router_http/router_http.c
index 156868d..701dd75 100644
--- a/plugins/router_http/router_http.c
+++ b/plugins/router_http/router_http.c
@@ -30,9 +30,6 @@ static int uwsgi_routing_func_http(struct wsgi_request *wsgi_req, struct uwsgi_r
 	if (ur->custom & 0x02) {
 		ub = uwsgi_buffer_new(uwsgi.page_size);
 	}
-	else if (ur->custom & 0x04) {
-		ub = uwsgi_to_http_dumb(wsgi_req, ur->data2, ur->data2_len, ub_url ? ub_url->buf : NULL, ub_url ? ub_url->pos : 0);
-	}
 	else {
 		ub = uwsgi_to_http(wsgi_req, ur->data2, ur->data2_len, ub_url ? ub_url->buf : NULL, ub_url ? ub_url->pos : 0);	
 	}
@@ -136,16 +133,10 @@ static int uwsgi_router_http_connect(struct uwsgi_route *ur, char *args) {
         return uwsgi_router_http(ur, args);
 }
 
-static int uwsgi_router_httpdumb(struct uwsgi_route *ur, char *args) {
-        ur->custom = 0x04;
-        return uwsgi_router_http(ur, args);
-}
-
 
 static void router_http_register(void) {
 
 	uwsgi_register_router("http", uwsgi_router_http);
-	uwsgi_register_router("httpdumb", uwsgi_router_httpdumb);
 	uwsgi_register_router("proxyhttp", uwsgi_router_proxyhttp);
 	uwsgi_register_router("httpconnect", uwsgi_router_http_connect);
 	uwsgi_register_router("proxyhttpconnect", uwsgi_router_proxyhttp_connect);
diff --git a/plugins/router_uwsgi/router_uwsgi.c b/plugins/router_uwsgi/router_uwsgi.c
index 9fca031..7387c3e 100644
--- a/plugins/router_uwsgi/router_uwsgi.c
+++ b/plugins/router_uwsgi/router_uwsgi.c
@@ -39,6 +39,11 @@ static int uwsgi_routing_func_uwsgi_remote(struct wsgi_request *wsgi_req, struct
 	char **subject = (char **) (((char *)(wsgi_req))+ur->subject);
         uint16_t *subject_len = (uint16_t *)  (((char *)(wsgi_req))+ur->subject_len);
 
+	// only 64k can be serialized in a uwsgi packet
+	if (wsgi_req->len > 0xffff) {
+		return UWSGI_ROUTE_BREAK;
+	}
+
         struct uwsgi_buffer *ub_addr = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, addr, strlen(addr));
         if (!ub_addr) return UWSGI_ROUTE_BREAK;
 
@@ -52,10 +57,11 @@ static int uwsgi_routing_func_uwsgi_remote(struct wsgi_request *wsgi_req, struct
 
 	size_t remains = wsgi_req->post_cl - wsgi_req->proto_parser_remains;
 
-	struct uwsgi_buffer *ub = uwsgi_buffer_new(4 + wsgi_req->uh->pktsize + wsgi_req->proto_parser_remains);
-	uh->pktsize = wsgi_req->uh->pktsize;
+
+	struct uwsgi_buffer *ub = uwsgi_buffer_new(4 + wsgi_req->len + wsgi_req->proto_parser_remains);
+	uh->_pktsize = wsgi_req->len;
 	if (uwsgi_buffer_append(ub, (char *) uh, 4)) goto end;
-	if (uwsgi_buffer_append(ub, wsgi_req->buffer, wsgi_req->uh->pktsize)) goto end;
+	if (uwsgi_buffer_append(ub, wsgi_req->buffer, wsgi_req->len)) goto end;
 	if (wsgi_req->proto_parser_remains > 0) {
                 if (uwsgi_buffer_append(ub, wsgi_req->proto_parser_remains_buf, wsgi_req->proto_parser_remains)) {
 			goto end;
diff --git a/plugins/rpc/rpc_plugin.c b/plugins/rpc/rpc_plugin.c
index 8724a5f..b8a14a2 100644
--- a/plugins/rpc/rpc_plugin.c
+++ b/plugins/rpc/rpc_plugin.c
@@ -142,7 +142,7 @@ static int uwsgi_rpc_request(struct wsgi_request *wsgi_req) {
 	size_t content_len = 0;
 
 	/* Standard RPC request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log("Empty RPC request. skip.\n");
                 return -1;
         }
@@ -226,7 +226,7 @@ static int uwsgi_rpc_request(struct wsgi_request *wsgi_req) {
 	}
 #endif
 
-	if (uwsgi_parse_array(wsgi_req->buffer, wsgi_req->uh->pktsize, argv, argvs, &argc)) {
+	if (uwsgi_parse_array(wsgi_req->buffer, wsgi_req->uh->_pktsize, argv, argvs, &argc)) {
                 uwsgi_log("Invalid RPC request. skip.\n");
                 return -1;
 	}
@@ -247,7 +247,7 @@ static int uwsgi_rpc_request(struct wsgi_request *wsgi_req) {
 				return -1;	
 			}
 			// fix uwsgi header
-			wsgi_req->uh->pktsize = ub->pos;
+			wsgi_req->uh->_pktsize = ub->pos;
 			if (uwsgi_response_write_body_do(wsgi_req, (char *) wsgi_req->uh, 4)) {
 				uwsgi_buffer_destroy(ub);
 				free(response_buf);	
@@ -261,7 +261,7 @@ static int uwsgi_rpc_request(struct wsgi_request *wsgi_req) {
 			uwsgi_buffer_destroy(ub);
 		}
 		else {
-			wsgi_req->uh->pktsize = content_len;
+			wsgi_req->uh->_pktsize = content_len;
 			if (uwsgi_response_write_body_do(wsgi_req, (char *) wsgi_req->uh, 4)) {
 				free(response_buf);	
 				return -1;
@@ -279,37 +279,54 @@ sendbody:
 }
 
 #ifdef UWSGI_ROUTING
-static int uwsgi_routing_func_rpc(struct wsgi_request *wsgi_req, struct uwsgi_route *ur) {
-	int ret = -1;
-	// this is the list of args
-        char *argv[UMAX8];
-        // this is the size of each argument
-        uint16_t argvs[UMAX8];
-	// this is a placeholder for tmp uwsgi_buffers
-	struct uwsgi_buffer *ubs[UMAX8];
-
+static int uwsgi_rpc_apply_translations(struct wsgi_request *wsgi_req, struct uwsgi_route *ur, struct uwsgi_buffer **ubs, uint64_t *ubs_len, char **argv, uint16_t *argvs) {
+	uint64_t i;
 	char **r_argv = (char **) ur->data2;
 	uint16_t *r_argvs = (uint16_t *) ur->data3;
 
 	char **subject = (char **) (((char *)(wsgi_req))+ur->subject);
-        uint16_t *subject_len = (uint16_t *)  (((char *)(wsgi_req))+ur->subject_len);
+	uint16_t *subject_len = (uint16_t *)  (((char *)(wsgi_req))+ur->subject_len);
 
-	uint64_t i;
 	for(i=0;i<ur->custom;i++) {
 		ubs[i] = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, r_argv[i], r_argvs[i]);
-		if (!ubs[i]) goto end;
+		if (!ubs[i]) {
+			*ubs_len = i;
+			return 0;
+		}
 		argv[i] = ubs[i]->buf;
 		argvs[i] = ubs[i]->pos;
 	}
 
-	// ok we now need to check it it is a local call or a remote one
-	char *func = uwsgi_str(ur->data);
+	*ubs_len = i;
+	return 1;
+}
+
+static char *uwsgi_rpc_get_remote(char *func) {
 	char *remote = NULL;
 	char *at = strchr(func, '@');
 	if (at) {
 		*at = 0;
 		remote = at+1;
 	}
+	return remote;
+}
+
+static int uwsgi_routing_func_rpc(struct wsgi_request *wsgi_req, struct uwsgi_route *ur) {
+	int ret = -1;
+	// this is the list of args
+        char *argv[UMAX8];
+        // this is the size of each argument
+        uint16_t argvs[UMAX8];
+	// this is a placeholder for tmp uwsgi_buffers
+	struct uwsgi_buffer *ubs[UMAX8];
+
+	uint64_t i;
+	if (!uwsgi_rpc_apply_translations(wsgi_req, ur, ubs, &i, argv, argvs))
+		goto end;
+
+	// ok we now need to check it it is a local call or a remote one
+	char *func = uwsgi_str(ur->data);
+	char *remote = uwsgi_rpc_get_remote(func);
 	uint64_t size;
 	char *response = uwsgi_do_rpc(remote, func, ur->custom, argv, argvs, &size);
 	free(func);
@@ -340,28 +357,13 @@ static int uwsgi_routing_func_rpc_blob(struct wsgi_request *wsgi_req, struct uws
         // this is a placeholder for tmp uwsgi_buffers
         struct uwsgi_buffer *ubs[UMAX8];
 
-        char **r_argv = (char **) ur->data2;
-        uint16_t *r_argvs = (uint16_t *) ur->data3;
-
-        char **subject = (char **) (((char *)(wsgi_req))+ur->subject);
-        uint16_t *subject_len = (uint16_t *)  (((char *)(wsgi_req))+ur->subject_len);
-
         uint64_t i;
-        for(i=0;i<ur->custom;i++) {
-                ubs[i] = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, r_argv[i], r_argvs[i]);
-                if (!ubs[i]) goto end;
-                argv[i] = ubs[i]->buf;
-                argvs[i] = ubs[i]->pos;
-        }
+	if (!uwsgi_rpc_apply_translations(wsgi_req, ur, ubs, &i, argv, argvs))
+		goto end;
 
         // ok we now need to check it it is a local call or a remote one
         char *func = uwsgi_str(ur->data);
-        char *remote = NULL;
-        char *at = strchr(func, '@');
-        if (at) {
-                *at = 0;
-                remote = at+1;
-        }
+	char *remote = uwsgi_rpc_get_remote(func);
         uint64_t size;
         char *response = uwsgi_do_rpc(remote, func, ur->custom, argv, argvs, &size);
         free(func);
@@ -396,28 +398,13 @@ static int uwsgi_routing_func_rpc_raw(struct wsgi_request *wsgi_req, struct uwsg
         // this is a placeholder for tmp uwsgi_buffers
         struct uwsgi_buffer *ubs[UMAX8];
 
-        char **r_argv = (char **) ur->data2;
-        uint16_t *r_argvs = (uint16_t *) ur->data3;
-
-        char **subject = (char **) (((char *)(wsgi_req))+ur->subject);
-        uint16_t *subject_len = (uint16_t *)  (((char *)(wsgi_req))+ur->subject_len);
-
         uint64_t i;
-        for(i=0;i<ur->custom;i++) {
-                ubs[i] = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, r_argv[i], r_argvs[i]);
-                if (!ubs[i]) goto end;
-                argv[i] = ubs[i]->buf;
-                argvs[i] = ubs[i]->pos;
-        }
+	if (!uwsgi_rpc_apply_translations(wsgi_req, ur, ubs, &i, argv, argvs))
+		goto end;
 
         // ok we now need to check it it is a local call or a remote one
         char *func = uwsgi_str(ur->data);
-        char *remote = NULL;
-        char *at = strchr(func, '@');
-        if (at) {
-                *at = 0;
-                remote = at+1;
-        }
+	char *remote = uwsgi_rpc_get_remote(func);
         uint64_t size;
         response = uwsgi_do_rpc(remote, func, ur->custom, argv, argvs, &size);
         free(func);
@@ -452,28 +439,13 @@ static int uwsgi_routing_func_rpc_var(struct wsgi_request *wsgi_req, struct uwsg
         // this is a placeholder for tmp uwsgi_buffers
         struct uwsgi_buffer *ubs[UMAX8];
 
-        char **r_argv = (char **) ur->data2;
-        uint16_t *r_argvs = (uint16_t *) ur->data3;
-
-        char **subject = (char **) (((char *)(wsgi_req))+ur->subject);
-        uint16_t *subject_len = (uint16_t *)  (((char *)(wsgi_req))+ur->subject_len);
-
         uint64_t i;
-        for(i=0;i<ur->custom;i++) {
-                ubs[i] = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, r_argv[i], r_argvs[i]);
-                if (!ubs[i]) goto end;
-                argv[i] = ubs[i]->buf;
-                argvs[i] = ubs[i]->pos;
-        }
+	if (!uwsgi_rpc_apply_translations(wsgi_req, ur, ubs, &i, argv, argvs))
+		goto end;
 
         // ok we now need to check it it is a local call or a remote one
         char *func = uwsgi_str(ur->data);
-        char *remote = NULL;
-        char *at = strchr(func, '@');
-        if (at) {
-                *at = 0;
-                remote = at+1;
-        }
+	char *remote = uwsgi_rpc_get_remote(func);
         uint64_t size;
         response = uwsgi_do_rpc(remote, func, ur->custom, argv, argvs, &size);
         free(func);
@@ -509,28 +481,13 @@ static int uwsgi_routing_func_rpc_ret(struct wsgi_request *wsgi_req, struct uwsg
         // this is a placeholder for tmp uwsgi_buffers
         struct uwsgi_buffer *ubs[UMAX8];
 
-        char **r_argv = (char **) ur->data2;
-        uint16_t *r_argvs = (uint16_t *) ur->data3;
-
-        char **subject = (char **) (((char *)(wsgi_req))+ur->subject);
-        uint16_t *subject_len = (uint16_t *)  (((char *)(wsgi_req))+ur->subject_len);
-
         uint64_t i;
-        for(i=0;i<ur->custom;i++) {
-                ubs[i] = uwsgi_routing_translate(wsgi_req, ur, *subject, *subject_len, r_argv[i], r_argvs[i]);
-                if (!ubs[i]) goto end;
-                argv[i] = ubs[i]->buf;
-                argvs[i] = ubs[i]->pos;
-        }
+	if (!uwsgi_rpc_apply_translations(wsgi_req, ur, ubs, &i, argv, argvs))
+		goto end;
 
         // ok we now need to check it it is a local call or a remote one
         char *func = uwsgi_str(ur->data);
-        char *remote = NULL;
-        char *at = strchr(func, '@');
-        if (at) {
-                *at = 0;
-                remote = at+1;
-        }
+	char *remote = uwsgi_rpc_get_remote(func);
         uint64_t size;
         char *response = uwsgi_do_rpc(remote, func, ur->custom, argv, argvs, &size);
         free(func);
diff --git a/plugins/signal/signal_plugin.c b/plugins/signal/signal_plugin.c
index 15a7ae5..a22a855 100644
--- a/plugins/signal/signal_plugin.c
+++ b/plugins/signal/signal_plugin.c
@@ -13,7 +13,7 @@ int uwsgi_request_signal(struct wsgi_request *wsgi_req) {
 	}
 
         uh.modifier1 = 255;
-       	uh.pktsize = 0;
+       	uh._pktsize = 0;
        	uh.modifier2 = ret_status;
 	
 	if (uwsgi_response_write_body_do(wsgi_req, (char *) &uh, 4)) {
diff --git a/plugins/spooler/spooler_plugin.c b/plugins/spooler/spooler_plugin.c
index 3caa2aa..3ec9576 100644
--- a/plugins/spooler/spooler_plugin.c
+++ b/plugins/spooler/spooler_plugin.c
@@ -17,15 +17,15 @@ int uwsgi_request_spooler(struct wsgi_request *wsgi_req) {
         if (uwsgi.spoolers == NULL) {
                 uwsgi_log("the spooler is inactive !!!...skip\n");
 		uh.modifier1 = 255;
-		uh.pktsize = 0;
+		uh._pktsize = 0;
 		uh.modifier2 = 0;
 		uwsgi_response_write_body_do(wsgi_req, (char *) &uh, 4);
                 return -1;
         }
 
-        char *filename = uwsgi_spool_request(NULL, wsgi_req->buffer, wsgi_req->uh->pktsize, NULL, 0);
+        char *filename = uwsgi_spool_request(NULL, wsgi_req->buffer, wsgi_req->uh->_pktsize, NULL, 0);
         uh.modifier1 = 255;
-        uh.pktsize = 0;
+        uh._pktsize = 0;
         if (filename) {
                 uh.modifier2 = 1;
 		if (uwsgi_response_write_body_do(wsgi_req, (char *) &uh, 4)) {
diff --git a/plugins/sslrouter/sslrouter.c b/plugins/sslrouter/sslrouter.c
index 8bfcfdb..6bb8845 100644
--- a/plugins/sslrouter/sslrouter.c
+++ b/plugins/sslrouter/sslrouter.c
@@ -288,15 +288,15 @@ static ssize_t sr_read(struct corerouter_peer *main_peer) {
         		// set default peer hook
         		peer->last_hook_read = sr_instance_read;
         		// use the address as hostname
-        		memcpy(peer->key, cs->ugs->name, cs->ugs->name_len);
+        		peer->key = cs->ugs->name;
         		peer->key_len = cs->ugs->name_len;
 
 #ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME
 			if (usr.sni) {
 				const char *servername = SSL_get_servername(sr->ssl, TLSEXT_NAMETYPE_host_name);
-				if (servername && strlen(servername) <= 0xff) {
+				if (servername) {
+        				peer->key = (char *) servername;
         				peer->key_len = strlen(servername);
-        				memcpy(peer->key, servername, peer->key_len);
 				}
 			}
 #endif
diff --git a/plugins/stackless/stackless.c b/plugins/stackless/stackless.c
index 94cfd67..0516c9f 100644
--- a/plugins/stackless/stackless.c
+++ b/plugins/stackless/stackless.c
@@ -84,7 +84,7 @@ static void stackless_init_apps(void) {
 
 	if (!usl.enabled) return;
 
-	if (uwsgi.async <= 1) {
+	if (uwsgi.async < 1) {
                 uwsgi_log("the stackless suspend engine requires async mode\n");
                 exit(1);
         }
diff --git a/plugins/systemd_logger/systemd_logger.c b/plugins/systemd_logger/systemd_logger.c
index 9185720..66a61d3 100644
--- a/plugins/systemd_logger/systemd_logger.c
+++ b/plugins/systemd_logger/systemd_logger.c
@@ -10,7 +10,7 @@ ssize_t uwsgi_systemd_logger(struct uwsgi_logger *ul, char *message, size_t len)
 	for(i=0;i<len;i++) {
 		if (message[i] == '\n') {
 			message[i] = 0;
-			sd_journal_print(LOG_INFO, "%s", base);
+			sd_journal_print(LOG_INFO, base);
 			base = message+i+1;
 		}
 	}
diff --git a/plugins/tornado/tornado.c b/plugins/tornado/tornado.c
index cc01c1a..d733510 100644
--- a/plugins/tornado/tornado.c
+++ b/plugins/tornado/tornado.c
@@ -235,7 +235,7 @@ PyObject *py_uwsgi_tornado_accept(PyObject *self, PyObject *args) {
 
         // enter harakiri mode
         if (uwsgi.harakiri_options.workers > 0) {
-                set_harakiri(uwsgi.harakiri_options.workers);
+                set_harakiri(wsgi_req, uwsgi.harakiri_options.workers);
         }
 
 	uwsgi.async_proto_fd_table[wsgi_req->fd] = wsgi_req;
@@ -342,7 +342,7 @@ static void tornado_loop() {
 
 	uwsgi.schedule_fix = uwsgi_tornado_schedule_fix;
 
-	if (uwsgi.async < 2) {
+	if (uwsgi.async < 1) {
 		uwsgi_log("the tornado loop engine requires async mode (--async <n>)\n");
 		exit(1);
 	}
diff --git a/plugins/v8/v8_jsgi.cc b/plugins/v8/v8_jsgi.cc
index dd9ce9b..491f06c 100644
--- a/plugins/v8/v8_jsgi.cc
+++ b/plugins/v8/v8_jsgi.cc
@@ -62,7 +62,7 @@ extern "C" int uwsgi_v8_request(struct wsgi_request *wsgi_req) {
 	v8::Handle<v8::Function> forEach;
 
 	/* Standard JSGI 3.0 request */
-        if (!wsgi_req->uh->pktsize) {
+        if (!wsgi_req->len) {
                 uwsgi_log( "Empty JSGI request. skip.\n");
                 return -1;
         }
diff --git a/proto/base.c b/proto/base.c
index 0702aaa..d48e7c9 100644
--- a/proto/base.c
+++ b/proto/base.c
@@ -9,11 +9,11 @@ int uwsgi_proto_raw_parser(struct wsgi_request *wsgi_req) {
 	return UWSGI_OK;
 }
 
-uint16_t proto_base_add_uwsgi_header(struct wsgi_request *wsgi_req, char *key, uint16_t keylen, char *val, uint16_t vallen) {
+uint64_t proto_base_add_uwsgi_header(struct wsgi_request *wsgi_req, char *key, uint16_t keylen, char *val, uint16_t vallen) {
 
 
 	int i;
-	char *buffer = wsgi_req->buffer + wsgi_req->uh->pktsize;
+	char *buffer = wsgi_req->buffer + wsgi_req->len;
 	char *watermark = wsgi_req->buffer + uwsgi.buffer_size;
 	char *ptr = buffer;
 
@@ -64,10 +64,10 @@ uint16_t proto_base_add_uwsgi_header(struct wsgi_request *wsgi_req, char *key, u
 
 
 
-uint16_t proto_base_add_uwsgi_var(struct wsgi_request * wsgi_req, char *key, uint16_t keylen, char *val, uint16_t vallen) {
+uint64_t proto_base_add_uwsgi_var(struct wsgi_request * wsgi_req, char *key, uint16_t keylen, char *val, uint16_t vallen) {
 
 
-	char *buffer = wsgi_req->buffer + wsgi_req->uh->pktsize;
+	char *buffer = wsgi_req->buffer + wsgi_req->len;
 	char *watermark = wsgi_req->buffer + uwsgi.buffer_size;
 	char *ptr = buffer;
 
diff --git a/proto/fastcgi.c b/proto/fastcgi.c
index 647b98c..2a0b246 100644
--- a/proto/fastcgi.c
+++ b/proto/fastcgi.c
@@ -60,7 +60,7 @@ int fastcgi_to_uwsgi(struct wsgi_request *wsgi_req, char *buf, size_t len) {
 		uint16_t pktsize = proto_base_add_uwsgi_var(wsgi_req, buf + j, keylen, buf + j + keylen, vallen);
 		if (pktsize == 0)
 			return -1;
-		wsgi_req->uh->pktsize += pktsize;
+		wsgi_req->len += pktsize;
 		// -1 here as the for() will increment j again
 		j += (keylen + vallen) - 1;
 	}
diff --git a/proto/http.c b/proto/http.c
index dd2b0f8..9097e96 100644
--- a/proto/http.c
+++ b/proto/http.c
@@ -38,9 +38,9 @@ static char * http_header_to_cgi(char *hh, size_t hhlen, size_t *keylen, size_t
 	return val;
 }
 
-static uint16_t http_add_uwsgi_header(struct wsgi_request *wsgi_req, char *hh, size_t hhlen, char *hv, size_t hvlen, int has_prefix) {
+static uint64_t http_add_uwsgi_header(struct wsgi_request *wsgi_req, char *hh, size_t hhlen, char *hv, size_t hvlen, int has_prefix) {
 
-	char *buffer = wsgi_req->buffer + wsgi_req->uh->pktsize;
+	char *buffer = wsgi_req->buffer + wsgi_req->len;
 	char *watermark = wsgi_req->buffer + uwsgi.buffer_size;
 	char *ptr = buffer;
 	size_t keylen = hhlen;
@@ -48,11 +48,16 @@ static uint16_t http_add_uwsgi_header(struct wsgi_request *wsgi_req, char *hh, s
 	if (has_prefix) keylen += 5;
 
 	if (buffer + keylen + hvlen + 2 + 2 >= watermark) {
-		if (has_prefix) {
-			uwsgi_log("[WARNING] unable to add HTTP_%.*s=%.*s to uwsgi packet, consider increasing buffer size\n", keylen-5, hh, hvlen, hv);
+		if (keylen <= 0xff && hvlen <= 0xff) {
+			if (has_prefix) {
+				uwsgi_log("[WARNING] unable to add HTTP_%.*s=%.*s to uwsgi packet, consider increasing buffer size\n", keylen - 5, hh, hvlen, hv);
+			}
+			else {
+				uwsgi_log("[WARNING] unable to add %.*s=%.*s to uwsgi packet, consider increasing buffer size\n", keylen, hh, hvlen, hv);
+			}
 		}
 		else {
-			uwsgi_log("[WARNING] unable to add %.*s=%.*s to uwsgi packet, consider increasing buffer size\n", keylen, hh, hvlen, hv);
+			uwsgi_log("[WARNING] unable to build uwsgi packet from http request, consider increasing buffer size\n");
 		}
 		return 0;
 	}
@@ -194,7 +199,7 @@ static int http_parse(struct wsgi_request *wsgi_req, char *watermark) {
 	// REQUEST_METHOD 
 	while (ptr < watermark) {
 		if (*ptr == ' ') {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_METHOD", 14, base, ptr - base);
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_METHOD", 14, base, ptr - base);
 			ptr++;
 			break;
 		}
@@ -206,10 +211,11 @@ static int http_parse(struct wsgi_request *wsgi_req, char *watermark) {
 	while (ptr < watermark) {
 		if (*ptr == '?' && !query_string) {
 			if (watermark + (ptr - base) < (char *)(wsgi_req->proto_parser_buf + uwsgi.buffer_size)) {
+				if (ptr - base > 0xffff) return -1;
 				uint16_t path_info_len = ptr - base;
 				char *path_info = uwsgi_malloc(path_info_len);
 				http_url_decode(base, &path_info_len, path_info);
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "PATH_INFO", 9, path_info, path_info_len);
+				wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "PATH_INFO", 9, path_info, path_info_len);
 				free(path_info);
 			}
 			else {
@@ -219,24 +225,25 @@ static int http_parse(struct wsgi_request *wsgi_req, char *watermark) {
 			query_string = ptr + 1;
 		}
 		else if (*ptr == ' ') {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, base, ptr - base);
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REQUEST_URI", 11, base, ptr - base);
 			
 			if (!query_string) {
 				if (watermark + (ptr - base) < (char *)(wsgi_req->proto_parser_buf + uwsgi.buffer_size)) {
+					if (ptr - base > 0xffff) return -1;
                                 	uint16_t path_info_len = ptr - base;
 					char *path_info = uwsgi_malloc(path_info_len);
                                 	http_url_decode(base, &path_info_len, path_info);
-                                	wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "PATH_INFO", 9, path_info, path_info_len);
+                                	wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "PATH_INFO", 9, path_info, path_info_len);
 					free(path_info);
                         	}
 				else {
 					uwsgi_log("not enough space in wsgi_req http proto_parser_buf to decode PATH_INFO, consider tuning it with --buffer-size\n");
 					return -1;
 				}
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, "", 0);
+				wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, "", 0);
 			}
 			else {
-				wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, query_string, ptr - query_string);
+				wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "QUERY_STRING", 12, query_string, ptr - query_string);
 			}
 			ptr++;
 			break;
@@ -252,7 +259,8 @@ static int http_parse(struct wsgi_request *wsgi_req, char *watermark) {
 				return -1 ;
 			if (*(ptr + 1) != '\n')
 				return -1;
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PROTOCOL", 15, base, ptr - base);
+			if (ptr - base > 0xffff) return -1;
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PROTOCOL", 15, base, ptr - base);
 			ptr += 2;
 			break;
 		}
@@ -261,42 +269,42 @@ static int http_parse(struct wsgi_request *wsgi_req, char *watermark) {
 
 	// SCRIPT_NAME
 	if (!uwsgi.manage_script_name) {
-		wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SCRIPT_NAME", 11, "", 0);
+		wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SCRIPT_NAME", 11, "", 0);
 	}
 	
 
 	// SERVER_NAME
-	wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_NAME", 11, uwsgi.hostname, uwsgi.hostname_len);
+	wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_NAME", 11, uwsgi.hostname, uwsgi.hostname_len);
 
 	// SERVER_PORT / SERVER_ADDR
 	if (proxy_dst) {
-		wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_ADDR", 11, proxy_dst, proxy_dst_len);
+		wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_ADDR", 11, proxy_dst, proxy_dst_len);
                 if (proxy_dst_port) {
-                        wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, proxy_dst_port, proxy_dst_port_len);
+                        wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, proxy_dst_port, proxy_dst_port_len);
                 }
 	}
 	else {
 		char *server_port = strchr(wsgi_req->socket->name, ':');
 		if (server_port) {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, server_port+1, strlen(server_port+1));
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, server_port+1, strlen(server_port+1));
 		}
 		else {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, "80", 2);
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "SERVER_PORT", 11, "80", 2);
 		}
 	}
 
 	// REMOTE_ADDR
 	if (proxy_src) {
-		wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, proxy_src, proxy_src_len);
+		wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, proxy_src, proxy_src_len);
 		if (proxy_src_port) {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_PORT", 11, proxy_src_port, proxy_src_port_len);
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_PORT", 11, proxy_src_port, proxy_src_port_len);
 		}
 	}
 	else {
 		// TODO add ipv6 support
 		memset(ip, 0, INET_ADDRSTRLEN+1);
 		if (inet_ntop(AF_INET, (void *) &http_sin->sin_addr.s_addr, ip, INET_ADDRSTRLEN)) {
-			wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, ip, strlen(ip));
+			wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "REMOTE_ADDR", 11, ip, strlen(ip));
 		}
 		else {
 			uwsgi_error("inet_ntop()");
@@ -305,7 +313,7 @@ static int http_parse(struct wsgi_request *wsgi_req, char *watermark) {
 	}
 
 	if (wsgi_req->https_len > 0) {
-		wsgi_req->uh->pktsize += proto_base_add_uwsgi_var(wsgi_req, "HTTPS", 5, wsgi_req->https, wsgi_req->https_len);
+		wsgi_req->len += proto_base_add_uwsgi_var(wsgi_req, "HTTPS", 5, wsgi_req->https, wsgi_req->https_len);
 	}
 
 	//HEADERS
@@ -330,6 +338,7 @@ static int http_parse(struct wsgi_request *wsgi_req, char *watermark) {
 			int has_prefix = 0;
 			// last line, do not waste time
 			if (ptr - base == 0) break;
+			if (ptr - base > 0xffff) return -1;
 			char *value = http_header_to_cgi(base, ptr - base, &key_len, &value_len, &has_prefix);
 			if (!value) {
 				uwsgi_log_verbose("invalid HTTP request\n");
@@ -363,10 +372,10 @@ static int http_parse(struct wsgi_request *wsgi_req, char *watermark) {
 	int broken = 0;
 	while(usl) {
 		if (!broken) {
-			uint16_t old_pktsize = wsgi_req->uh->pktsize;
-			wsgi_req->uh->pktsize += http_add_uwsgi_header(wsgi_req, usl->value, usl->len, usl->custom_ptr, (size_t) usl->custom, usl->custom2 & 0x02);
+			uint64_t old_len = wsgi_req->len;
+			wsgi_req->len += http_add_uwsgi_header(wsgi_req, usl->value, usl->len, usl->custom_ptr, (size_t) usl->custom, usl->custom2 & 0x02);
 			// if the packet remains unchanged, the buffer is full, mark the request as broken
-			if (old_pktsize == wsgi_req->uh->pktsize) {
+			if (old_len == wsgi_req->len) {
 				broken = 1;
 			}
 		}
@@ -480,96 +489,6 @@ static void uwsgi_httpize_var(char *buf, size_t len) {
 	}
 }
 
-struct uwsgi_buffer *uwsgi_to_http_dumb(struct wsgi_request *wsgi_req, char *host, uint16_t host_len, char *uri, uint16_t uri_len) {
-
-        struct uwsgi_buffer *ub = uwsgi_buffer_new(4096);
-
-        if (uwsgi_buffer_append(ub, wsgi_req->method, wsgi_req->method_len)) goto clear;
-        if (uwsgi_buffer_append(ub, " ", 1)) goto clear;
-
-        if (uri_len && uri) {
-                if (uwsgi_buffer_append(ub, uri, uri_len)) goto clear;
-        }
-        else {
-                if (uwsgi_buffer_append(ub, wsgi_req->uri, wsgi_req->uri_len)) goto clear;
-        }
-
-        if (uwsgi_buffer_append(ub, " ", 1)) goto clear;
-        if (uwsgi_buffer_append(ub, wsgi_req->protocol, wsgi_req->protocol_len)) goto clear;
-        if (uwsgi_buffer_append(ub, "\r\n", 2)) goto clear;
-
-        int i;
-        char *x_forwarded_for = NULL;
-        size_t x_forwarded_for_len = 0;
-
-        // start adding headers
-        for(i=0;i<wsgi_req->var_cnt;i++) {
-                if (!uwsgi_starts_with(wsgi_req->hvec[i].iov_base, wsgi_req->hvec[i].iov_len, "HTTP_", 5)) {
-
-                        char *header = wsgi_req->hvec[i].iov_base+5;
-                        size_t header_len = wsgi_req->hvec[i].iov_len-5;
-
-                        if (host && !uwsgi_strncmp(header, header_len, "HOST", 4)) goto next;
-
-                        if (!uwsgi_strncmp(header, header_len, "X_FORWARDED_FOR", 15)) {
-                                x_forwarded_for = wsgi_req->hvec[i+1].iov_base;
-                                x_forwarded_for_len = wsgi_req->hvec[i+1].iov_len;
-                                goto next;
-                        }
-
-                        if (uwsgi_buffer_append(ub, header, header_len)) goto clear;
-
-                        // transofmr uwsgi var to http header
-                        uwsgi_httpize_var((ub->buf+ub->pos) - header_len, header_len);
-
-                        if (uwsgi_buffer_append(ub, ": ", 2)) goto clear;
-                        if (uwsgi_buffer_append(ub, wsgi_req->hvec[i+1].iov_base, wsgi_req->hvec[i+1].iov_len)) goto clear;
-                        if (uwsgi_buffer_append(ub, "\r\n", 2)) goto clear;
-
-                }
-next:
-                i++;
-        }
-
-
-        // append custom Host (if needed)
-        if (host) {
-                if (uwsgi_buffer_append(ub, "Host: ", 6)) goto clear;
-                if (uwsgi_buffer_append(ub, host, host_len)) goto clear;
-                if (uwsgi_buffer_append(ub, "\r\n", 2)) goto clear;
-        }
-
-        if (wsgi_req->content_type_len > 0) {
-                if (uwsgi_buffer_append(ub, "Content-Type: ", 14)) goto clear;
-                if (uwsgi_buffer_append(ub, wsgi_req->content_type, wsgi_req->content_type_len)) goto clear;
-                if (uwsgi_buffer_append(ub, "\r\n", 2)) goto clear;
-        }
-
-        if (wsgi_req->post_cl > 0) {
-                if (uwsgi_buffer_append(ub, "Content-Length: ", 16)) goto clear;
-                if (uwsgi_buffer_num64(ub, (int64_t) wsgi_req->post_cl)) goto clear;
-                if (uwsgi_buffer_append(ub, "\r\n", 2)) goto clear;
-        }
-
-        // append required headers
-        if (uwsgi_buffer_append(ub, "X-Forwarded-For: ", 17)) goto clear;
-
-        if (x_forwarded_for_len > 0) {
-                if (uwsgi_buffer_append(ub, x_forwarded_for, x_forwarded_for_len)) goto clear;
-                if (uwsgi_buffer_append(ub, ", ", 2)) goto clear;
-        }
-
-        if (uwsgi_buffer_append(ub, wsgi_req->remote_addr, wsgi_req->remote_addr_len)) goto clear;
-
-        if (uwsgi_buffer_append(ub, "\r\n\r\n", 4)) goto clear;
-
-        return ub;
-clear:
-        uwsgi_buffer_destroy(ub);
-        return NULL;
-}
-
-
 struct uwsgi_buffer *uwsgi_to_http(struct wsgi_request *wsgi_req, char *host, uint16_t host_len, char *uri, uint16_t uri_len) {
 
         struct uwsgi_buffer *ub = uwsgi_buffer_new(4096);
@@ -603,8 +522,14 @@ struct uwsgi_buffer *uwsgi_to_http(struct wsgi_request *wsgi_req, char *host, ui
 			// remove dangerous headers
 			if (!uwsgi_strncmp(header, header_len, "CONNECTION", 10)) goto next;
 			if (!uwsgi_strncmp(header, header_len, "KEEP_ALIVE", 10)) goto next;
+			if (!uwsgi_strncmp(header, header_len, "ACCEPT_ENCODING", 15)) goto next;
 			if (!uwsgi_strncmp(header, header_len, "TE", 2)) goto next;
 			if (!uwsgi_strncmp(header, header_len, "TRAILER", 7)) goto next;
+			if (!uwsgi_strncmp(header, header_len, "IF_MATCH", 8)) goto next;
+			if (!uwsgi_strncmp(header, header_len, "IF_MODIFIED_SINCE", 17)) goto next;
+			if (!uwsgi_strncmp(header, header_len, "IF_RANGE", 8)) goto next;
+			if (!uwsgi_strncmp(header, header_len, "IF_UNMODIFIED_SINCE", 19)) goto next;
+			if (!uwsgi_strncmp(header, header_len, "IF_NONE_MATCH", 13)) goto next;
 			if (!uwsgi_strncmp(header, header_len, "X_FORWARDED_FOR", 15)) {
 				x_forwarded_for = wsgi_req->hvec[i+1].iov_base;
 				x_forwarded_for_len = wsgi_req->hvec[i+1].iov_len;
@@ -723,6 +648,62 @@ void uwsgi_proto_http_setup(struct uwsgi_socket *uwsgi_sock) {
 
 }
 
+/*
+close the connection on errors, incomplete parsing, HTTP/1.0,  pipelined or offloaded requests
+NOTE: Connection: close is not honoured
+*/
+void uwsgi_proto_http11_close(struct wsgi_request *wsgi_req) {
+        // check for errors or incomplete packets
+        if (wsgi_req->write_errors || wsgi_req->proto_parser_status != 3 || wsgi_req->proto_parser_remains > 0
+		|| wsgi_req->post_pos < wsgi_req->post_cl || wsgi_req->via == UWSGI_VIA_OFFLOAD
+		|| !uwsgi_strncmp("HTTP/1.0", 8, wsgi_req->protocol, wsgi_req->protocol_len)) {
+                close(wsgi_req->fd);
+                wsgi_req->socket->retry[wsgi_req->async_id] = 0;
+                wsgi_req->socket->fd_threads[wsgi_req->async_id] = -1;
+        }
+        else {
+                wsgi_req->socket->retry[wsgi_req->async_id] = 1;
+                wsgi_req->socket->fd_threads[wsgi_req->async_id] = wsgi_req->fd;
+        }
+}
+
+int uwsgi_proto_http11_accept(struct wsgi_request *wsgi_req, int fd) {
+        if (wsgi_req->socket->retry[wsgi_req->async_id]) {
+                wsgi_req->fd = wsgi_req->socket->fd_threads[wsgi_req->async_id];
+		wsgi_req->c_len = sizeof(struct sockaddr_un);
+		getsockname(wsgi_req->fd, (struct sockaddr *) &wsgi_req->c_addr, (socklen_t *) &wsgi_req->c_len);
+                int ret = uwsgi_wait_read_req(wsgi_req);
+                if (ret <= 0) {
+                        close(wsgi_req->fd);
+                        wsgi_req->socket->retry[wsgi_req->async_id] = 0;
+                        wsgi_req->socket->fd_threads[wsgi_req->async_id] = -1;
+                        return -1;
+                }
+                return wsgi_req->socket->fd_threads[wsgi_req->async_id];
+        }
+        return uwsgi_proto_base_accept(wsgi_req, fd);
+}
+
+void uwsgi_proto_http11_setup(struct uwsgi_socket *uwsgi_sock) {
+        uwsgi_sock->proto = uwsgi_proto_http_parser;
+        uwsgi_sock->proto_accept = uwsgi_proto_http11_accept;
+        uwsgi_sock->proto_prepare_headers = uwsgi_proto_base_prepare_headers;
+        uwsgi_sock->proto_add_header = uwsgi_proto_base_add_header;
+        uwsgi_sock->proto_fix_headers = uwsgi_proto_base_fix_headers;
+        uwsgi_sock->proto_read_body = uwsgi_proto_base_read_body;
+        uwsgi_sock->proto_write = uwsgi_proto_base_write;
+        uwsgi_sock->proto_writev = uwsgi_proto_base_writev;
+        uwsgi_sock->proto_write_headers = uwsgi_proto_base_write;
+        uwsgi_sock->proto_sendfile = uwsgi_proto_base_sendfile;
+        uwsgi_sock->proto_close = uwsgi_proto_http11_close;
+        if (uwsgi.offload_threads > 0)
+        	uwsgi_sock->can_offload = 1;
+	uwsgi_sock->fd_threads = uwsgi_malloc(sizeof(int) * uwsgi.cores);
+        memset(uwsgi_sock->fd_threads, -1, sizeof(int) * uwsgi.cores);
+        uwsgi_sock->retry = uwsgi_calloc(sizeof(int) * uwsgi.cores);
+        uwsgi.is_et = 1;
+}
+
 #ifdef UWSGI_SSL
 static int uwsgi_proto_https_parser(struct wsgi_request *wsgi_req) {
 
diff --git a/proto/puwsgi.c b/proto/puwsgi.c
index 72840be..0a9fb08 100644
--- a/proto/puwsgi.c
+++ b/proto/puwsgi.c
@@ -22,10 +22,11 @@ int uwsgi_proto_puwsgi_parser(struct wsgi_request *wsgi_req) {
 			wsgi_req->proto_parser_pos += len;
 			if (wsgi_req->proto_parser_pos == 4) {
 #ifdef __BIG_ENDIAN__
-                        	wsgi_req->uh->pktsize = uwsgi_swap16(wsgi_req->uh->pktsize);
+                        	wsgi_req->len = uwsgi_swap16(wsgi_req->len);
 #endif
-				if (wsgi_req->uh->pktsize > uwsgi.buffer_size) {
-                                	uwsgi_log("invalid request block size: %u (max %u)...skip\n", wsgi_req->uh->pktsize, uwsgi.buffer_size);
+				wsgi_req->len = wsgi_req->len;
+				if (wsgi_req->len > uwsgi.buffer_size) {
+                                	uwsgi_log("invalid request block size: %u (max %u)...skip\n", wsgi_req->len, uwsgi.buffer_size);
 					wsgi_req->write_errors++;		
                                 	return -1;
                         	}
@@ -34,10 +35,10 @@ int uwsgi_proto_puwsgi_parser(struct wsgi_request *wsgi_req) {
 		}
 		goto negative;
 	}
-	len = read(wsgi_req->fd, ptr + wsgi_req->proto_parser_pos, wsgi_req->uh->pktsize - (wsgi_req->proto_parser_pos-4));
+	len = read(wsgi_req->fd, ptr + wsgi_req->proto_parser_pos, wsgi_req->len - (wsgi_req->proto_parser_pos-4));
 	if (len > 0) {
 		wsgi_req->proto_parser_pos += len;
-		if ((wsgi_req->proto_parser_pos-4) == wsgi_req->uh->pktsize) {
+		if ((wsgi_req->proto_parser_pos-4) == wsgi_req->len) {
 			return UWSGI_OK;	
 		}
 		return UWSGI_AGAIN;
@@ -64,7 +65,7 @@ close the connection on errors, otherwise force edge triggering
 */
 void uwsgi_proto_puwsgi_close(struct wsgi_request *wsgi_req) {
 	// check for errors or incomplete packets
-	if (wsgi_req->write_errors || (size_t) (wsgi_req->uh->pktsize + 4) != wsgi_req->proto_parser_pos) {
+	if (wsgi_req->write_errors || (size_t) (wsgi_req->len + 4) != wsgi_req->proto_parser_pos) {
 		close(wsgi_req->fd);
 		wsgi_req->socket->retry[wsgi_req->async_id] = 0;
 		wsgi_req->socket->fd_threads[wsgi_req->async_id] = -1;
diff --git a/proto/scgi.c b/proto/scgi.c
index a5afec4..707fe3e 100644
--- a/proto/scgi.c
+++ b/proto/scgi.c
@@ -43,7 +43,7 @@ keyval:
 				vallen = (buf+i) - value;
 				uint16_t pktsize = proto_base_add_uwsgi_var(wsgi_req, key, keylen, value, vallen);
                 		if (pktsize == 0) return -1;
-                		wsgi_req->uh->pktsize += pktsize;
+                		wsgi_req->len += pktsize;
 				key = NULL;
 				value = NULL;
 				keylen = 0;
diff --git a/proto/uwsgi.c b/proto/uwsgi.c
index 07f3aaa..e07f7a0 100644
--- a/proto/uwsgi.c
+++ b/proto/uwsgi.c
@@ -11,18 +11,19 @@ static int uwsgi_proto_uwsgi_parser(struct wsgi_request *wsgi_req) {
 		wsgi_req->proto_parser_pos += len;
 		if (wsgi_req->proto_parser_pos >= 4) {
 #ifdef __BIG_ENDIAN__
-			wsgi_req->uh->pktsize = uwsgi_swap16(wsgi_req->uh->pktsize);
+			wsgi_req->uh->_pktsize = uwsgi_swap16(wsgi_req->uh->_pktsize);
 #endif
-			if ((wsgi_req->proto_parser_pos - 4) == wsgi_req->uh->pktsize) {
+			wsgi_req->len = wsgi_req->uh->_pktsize;
+			if ((wsgi_req->proto_parser_pos - 4) == wsgi_req->uh->_pktsize) {
 				return UWSGI_OK;
 			}
-			if ((wsgi_req->proto_parser_pos - 4) > wsgi_req->uh->pktsize) {
-				wsgi_req->proto_parser_remains = wsgi_req->proto_parser_pos - (4 + wsgi_req->uh->pktsize);
-				wsgi_req->proto_parser_remains_buf = wsgi_req->buffer + wsgi_req->uh->pktsize;
+			if ((wsgi_req->proto_parser_pos - 4) > wsgi_req->uh->_pktsize) {
+				wsgi_req->proto_parser_remains = wsgi_req->proto_parser_pos - (4 + wsgi_req->uh->_pktsize);
+				wsgi_req->proto_parser_remains_buf = wsgi_req->buffer + wsgi_req->uh->_pktsize;
 				return UWSGI_OK;
 			}
-			if (wsgi_req->uh->pktsize > uwsgi.buffer_size) {
-				uwsgi_log("invalid request block size: %u (max %u)...skip\n", wsgi_req->uh->pktsize, uwsgi.buffer_size);
+			if (wsgi_req->uh->_pktsize > uwsgi.buffer_size) {
+				uwsgi_log("invalid request block size: %u (max %u)...skip\n", wsgi_req->uh->_pktsize, uwsgi.buffer_size);
 				return -1;
 			}
 		}
@@ -52,18 +53,18 @@ retry:
                 wsgi_req->proto_parser_pos += len;
                 if (wsgi_req->proto_parser_pos >= 4) {
 #ifdef __BIG_ENDIAN__
-                        wsgi_req->uh->pktsize = uwsgi_swap16(wsgi_req->uh->pktsize);
+                        wsgi_req->uh->_pktsize = uwsgi_swap16(wsgi_req->uh->_pktsize);
 #endif
-                        if ((wsgi_req->proto_parser_pos - 4) == wsgi_req->uh->pktsize) {
+                        if ((wsgi_req->proto_parser_pos - 4) == wsgi_req->uh->_pktsize) {
                                 return UWSGI_OK;
                         }
-                        if ((wsgi_req->proto_parser_pos - 4) > wsgi_req->uh->pktsize) {
-                                wsgi_req->proto_parser_remains = wsgi_req->proto_parser_pos - (4 + wsgi_req->uh->pktsize);
-                                wsgi_req->proto_parser_remains_buf = wsgi_req->buffer + wsgi_req->uh->pktsize;
+                        if ((wsgi_req->proto_parser_pos - 4) > wsgi_req->uh->_pktsize) {
+                                wsgi_req->proto_parser_remains = wsgi_req->proto_parser_pos - (4 + wsgi_req->uh->_pktsize);
+                                wsgi_req->proto_parser_remains_buf = wsgi_req->buffer + wsgi_req->uh->_pktsize;
                                 return UWSGI_OK;
                         }
-                        if (wsgi_req->uh->pktsize > uwsgi.buffer_size) {
-                                uwsgi_log("invalid request block size: %u (max %u)...skip\n", wsgi_req->uh->pktsize, uwsgi.buffer_size);
+                        if (wsgi_req->uh->_pktsize > uwsgi.buffer_size) {
+                                uwsgi_log("invalid request block size: %u (max %u)...skip\n", wsgi_req->uh->_pktsize, uwsgi.buffer_size);
                                 return -1;
                         }
                 }
@@ -144,18 +145,18 @@ int uwsgi_proto_uwsgi_parser_unix(struct wsgi_request *wsgi_req) {
 			wsgi_req->proto_parser_status = PROTO_STATUS_RECV_VARS;
 			wsgi_req->proto_parser_pos = 0;
 #ifdef __BIG_ENDIAN__
-			wsgi_req->uh->pktsize = uwsgi_swap16(wsgi_req->uh->pktsize);
+			wsgi_req->uh->_pktsize = uwsgi_swap16(wsgi_req->uh->_pktsize);
 #endif
 
 #ifdef UWSGI_DEBUG
-			uwsgi_debug("uwsgi payload size: %d (0x%X) modifier1: %d modifier2: %d\n", wsgi_req->uh.pktsize, wsgi_req->uh.pktsize, wsgi_req->uh.modifier1, wsgi_req->uh.modifier2);
+			uwsgi_debug("uwsgi payload size: %d (0x%X) modifier1: %d modifier2: %d\n", wsgi_req->uh._pktsize, wsgi_req->uh._pktsize, wsgi_req->uh.modifier1, wsgi_req->uh.modifier2);
 #endif
 
-			if (wsgi_req->uh->pktsize > uwsgi.buffer_size) {
+			if (wsgi_req->uh->_pktsize > uwsgi.buffer_size) {
 				return -1;
 			}
 
-			if (!wsgi_req->uh->pktsize)
+			if (!wsgi_req->uh->_pktsize)
 				return UWSGI_OK;
 
 		}
@@ -163,7 +164,7 @@ int uwsgi_proto_uwsgi_parser_unix(struct wsgi_request *wsgi_req) {
 	}
 
 	else if (wsgi_req->proto_parser_status == PROTO_STATUS_RECV_VARS) {
-		len = read(wsgi_req->fd, wsgi_req->buffer + wsgi_req->proto_parser_pos, wsgi_req->uh->pktsize - wsgi_req->proto_parser_pos);
+		len = read(wsgi_req->fd, wsgi_req->buffer + wsgi_req->proto_parser_pos, wsgi_req->uh->_pktsize - wsgi_req->proto_parser_pos);
 		if (len <= 0) {
 			uwsgi_error("read()");
 			return -1;
@@ -171,7 +172,7 @@ int uwsgi_proto_uwsgi_parser_unix(struct wsgi_request *wsgi_req) {
 		wsgi_req->proto_parser_pos += len;
 
 		// body ready ?
-		if (wsgi_req->proto_parser_pos >= wsgi_req->uh->pktsize) {
+		if (wsgi_req->proto_parser_pos >= wsgi_req->uh->_pktsize) {
 
 			// older OSX versions make mess with CMSG_FIRSTHDR
 #ifdef __APPLE__
diff --git a/setup.cpyext.py b/setup.cpyext.py
new file mode 100644
index 0000000..ee89dbc
--- /dev/null
+++ b/setup.cpyext.py
@@ -0,0 +1,131 @@
+# encoding: utf-8
+
+"""
+This is a hack allowing you installing
+uWSGI and uwsgidecorators via pip and easy_install
+since 1.9.11 it automatically detects pypy
+"""
+
+import os
+import sys
+import errno
+import shlex
+import shutil
+import uwsgiconfig
+
+from setuptools import setup
+from setuptools.dist import Distribution
+from setuptools.command.install import install
+from setuptools.command.install_lib import install_lib
+from setuptools.command.build_ext import build_ext
+from distutils.core import Extension
+
+
+class uWSGIBuildExt(build_ext):
+
+    UWSGI_NAME = 'uwsgi'
+    UWSGI_PLUGIN = 'pyuwsgi'
+
+    def build_extensions(self):
+        self.uwsgi_setup()
+        #XXX: needs uwsgiconfig fix
+        self.uwsgi_build()
+        if 'UWSGI_USE_DISTUTILS' not in os.environ:
+            #XXX: needs uwsgiconfig fix
+            #uwsgiconfig.build_uwsgi(self.uwsgi_config)
+            return
+
+        else:
+            #XXX: needs uwsgiconfig fix
+            os.unlink(self.uwsgi_config.get('bin_name'))
+
+        #FIXME: else build fails :(
+        for baddie in set(self.compiler.compiler_so) & set((
+            '-Wstrict-prototypes',
+            )):
+            self.compiler.compiler_so.remove(baddie)
+
+        build_ext.build_extensions(self)
+
+    def uwsgi_setup(self):
+        default = (
+            '__pypy__' in sys.builtin_module_names
+                and 'pypy'
+                or 'default'
+                )
+        profile = (
+            os.environ.get('UWSGI_PROFILE')
+                or 'buildconf/%s.ini' % default
+                )
+
+        if not profile.endswith('.ini'):
+            profile = profile + '.ini'
+        if not '/' in profile:
+            profile = 'buildconf/' + profile
+
+        #FIXME: update uwsgiconfig to properly set _EVERYTHING_!
+        config = uwsgiconfig.uConf(profile)
+        # insert in the beginning so UWSGI_PYTHON_NOLIB is exported
+        # before the python plugin compiles
+        ep = config.get('embedded_plugins').split(',')
+        if self.UWSGI_PLUGIN in ep:
+            ep.remove(self.UWSGI_PLUGIN)
+        ep.insert(0, self.UWSGI_PLUGIN)
+        config.set('embedded_plugins', ','.join(ep))
+        config.set('as_shared_library', 'true')
+        config.set('bin_name', self.get_ext_fullpath(self.UWSGI_NAME))
+        try:
+            os.makedirs(os.path.dirname(config.get('bin_name')))
+        except OSError as e:
+            if e.errno != errno.EEXIST:
+                raise
+
+        self.uwsgi_profile = profile
+        self.uwsgi_config = config
+
+    def uwsgi_build(self):
+        uwsgiconfig.build_uwsgi(self.uwsgi_config)
+
+        #XXX: merge uwsgi_setup (see other comments)
+        for ext in self.extensions:
+            if ext.name == self.UWSGI_NAME:
+                ext.sources = [s + '.c' for s in self.uwsgi_config.gcc_list]
+                ext.library_dirs = self.uwsgi_config.include_path[:]
+                ext.libraries = list()
+                ext.extra_compile_args = list()
+
+                for x in uwsgiconfig.uniq_warnings(
+                    self.uwsgi_config.ldflags + self.uwsgi_config.libs,
+                    ):
+                    for y in shlex.split(x):
+                        if y.startswith('-l'):
+                            ext.libraries.append(y[2:])
+                        elif y.startswith('-L'):
+                            ext.library_dirs.append(y[2:])
+
+                for x in self.uwsgi_config.cflags:
+                    for y in shlex.split(x):
+                        if y:
+                            ext.extra_compile_args.append(y)
+
+
+setup(
+    name='uWSGI',
+    license='GPL2',
+    version=uwsgiconfig.uwsgi_version,
+    author='Unbit',
+    author_email='info@unbit.it',
+    description='The uWSGI server',
+    cmdclass={
+        'build_ext': uWSGIBuildExt,
+        },
+    py_modules=[
+        'uwsgidecorators',
+        ],
+    ext_modules=[
+        Extension(uWSGIBuildExt.UWSGI_NAME, sources=[]),
+        ],
+    entry_points={
+        'console_scripts': ['uwsgi=%s:run' % uWSGIBuildExt.UWSGI_NAME],
+        },
+    )
diff --git a/t/perl/active_workers_signal.pl b/t/perl/active_workers_signal.pl
deleted file mode 100644
index 563cd2f..0000000
--- a/t/perl/active_workers_signal.pl
+++ /dev/null
@@ -1,10 +0,0 @@
-#uwsgi --psgi t/perl/active_workers_signal.pl -s :3031 --perl-no-plack --timer "17 3" -p 8 --cheap --idle 10
-my $handler = sub {
-	print "hello i am the signal handler on worker ".uwsgi::worker_id()."\n";
-};
-
-uwsgi::register_signal(17, 'active-workers', $handler);
-
-my $app = sub {
-};
-
diff --git a/t/perl/test_harakiri.psgi b/t/perl/test_harakiri.psgi
deleted file mode 100644
index 7680944..0000000
--- a/t/perl/test_harakiri.psgi
+++ /dev/null
@@ -1,19 +0,0 @@
-use strict;
-use warnings;
-
-{
-    package psgix::harakiri::tester;
-    sub DESTROY { print STDERR "$$: Calling DESTROY\n" }
-}
-
-sub {
-    my $env = shift;
-
-    die "PANIC: We should support psgix.harakiri here" unless $env->{'psgix.harakiri'};
-
-    $env->{'psgix.harakiri.tester'} = bless {} => 'psgix::harakiri::tester';
-    my $harakiri = $env->{QUERY_STRING};
-    $env->{'psgix.harakiri.commit'} = $harakiri ? 1 : 0;
-
-    return [200, [], [ $harakiri ? "We are about to destroy ourselves\n" : "We will live for another request\n" ]];
-}
diff --git a/t/python/manage_script_name/manage_script_name_test.ini b/t/python/manage_script_name/manage_script_name_test.ini
deleted file mode 100644
index f228776..0000000
--- a/t/python/manage_script_name/manage_script_name_test.ini
+++ /dev/null
@@ -1,13 +0,0 @@
-[uwsgi]
-http-socket = :8080
-
-master = 1
-
-; Three apps on three mountpoints
-wsgi-file = %d/useless_app.py
-
-mount = /foo=%d/useless_app.py
-mount = /foobis/=%d/useless_app.py
-mount = /footris/=%d/useless_app.py
-
-manage-script-name = 1
diff --git a/t/python/manage_script_name/test_manage_script_name.py b/t/python/manage_script_name/test_manage_script_name.py
deleted file mode 100644
index 0908b0f..0000000
--- a/t/python/manage_script_name/test_manage_script_name.py
+++ /dev/null
@@ -1,59 +0,0 @@
-#! /usr/bin/env python3
-# coding = utf-8
-# author = Adriano Di Luzio
-
-# I require requests!
-
-"""
-First run:
-    $ ./uwsgi t/python/manage_script_name/manage_script_name_test.ini
-
-Then run me!
-"""
-
-import unittest
-import requests
-
-HOST = "http://127.0.0.1:8080"
-
-
-class ManageScriptNameTest(unittest.TestCase):
-
-    def test_classic_mountpoints(self):
-        mps = {
-            "/foo",
-            "/foobis/",
-            "/footris/"
-        }
-
-        for mp in mps:
-            # Requests to /foo should kick-in the managed script name.
-            r = requests.get(HOST + mp)
-            self.assertEqual(r.text, mp)
-
-            ends = mp.endswith("/")
-
-            # And equally requests to /foo/
-            r = requests.get(
-                HOST + mp + "/") if not ends else requests.get(HOST + mp[:-1])
-            self.assertEqual(r.text, mp)
-
-            # Or correct requests (/foo/resource)
-            r = requests.get(
-                HOST + mp + "/" + "resource") if not ends else requests.get(HOST + mp + "resource")
-            self.assertEqual(r.text, mp)
-
-    def test_intriguing_mountpoints(self):
-        mps = {
-            "/fooanything",
-            "/foobisis/",
-            "/foofighters",
-        }
-
-        for mp in mps:
-            r = requests.get(HOST + mp)
-            self.assertEqual(r.text, "")
-
-
-if __name__ == '__main__':
-    unittest.main(verbosity=2)
diff --git a/t/python/manage_script_name/useless_app.py b/t/python/manage_script_name/useless_app.py
deleted file mode 100644
index b19c081..0000000
--- a/t/python/manage_script_name/useless_app.py
+++ /dev/null
@@ -1,3 +0,0 @@
-def application(env, start_response):
-    start_response('200 OK', [('Content-Type', 'text/html')])
-    return env['SCRIPT_NAME']
diff --git a/t/python/spooler_decorators/spooler_decorator_test.ini b/t/python/spooler_decorators/spooler_decorator_test.ini
new file mode 100644
index 0000000..352f1ae
--- /dev/null
+++ b/t/python/spooler_decorators/spooler_decorator_test.ini
@@ -0,0 +1,18 @@
+[uwsgi]
+socket = /tmp/temporary_socket
+
+; Spooler!
+
+spooler-import = %d/spooler_handlers.py
+; Specify the spooler
+spooler = $(SPOOLER_DIR)
+; And the number of processes
+spooler-processes = 1
+; Spooler ordered scanning (only works with "numbered" dirs)
+spooler-ordered = 1
+; Spooler frequency
+spooler-frequency = 1
+
+pyrun = %d/spooler_decorator_tests.py
+master = 1
+
diff --git a/t/python/spooler_decorators/spooler_decorator_tests.py b/t/python/spooler_decorators/spooler_decorator_tests.py
new file mode 100644
index 0000000..ec72e39
--- /dev/null
+++ b/t/python/spooler_decorators/spooler_decorator_tests.py
@@ -0,0 +1,31 @@
+# run it with:
+# export SPOOLER_DIR=t/python/spooler_priority/temporary_spooler; # or your spooler dir
+# ./uwsgi t/python/spooler_decorators/spooler_decorator_test.ini
+
+import unittest
+import uwsgi
+import spooler_handlers
+from os import remove, path
+
+
+class BitmapTest(unittest.TestCase):
+
+    def setUp(self):
+        try:
+            remove(spooler_handlers.ghostpath)
+        except OSError:  # file does not exist
+            pass
+
+        spooler_handlers.controlled_task.spool(arg='alive', ghost='world')
+        spooler_handlers.controlled_task.spool(arg='barbis')
+        spooler_handlers.controlled_raw_task.spool(arg='alive', ghost='world')
+        spooler_handlers.controlled_raw_task.spool(arg='barbis')
+
+        for i in range(4):
+            uwsgi.signal_wait(20)
+        print("Signal received!")
+
+    def test_spooler(self):
+        self.assertFalse(path.exists(spooler_handlers.ghostpath))
+
+unittest.main()
diff --git a/t/python/spooler_decorators/spooler_handlers.py b/t/python/spooler_decorators/spooler_handlers.py
new file mode 100644
index 0000000..5298f91
--- /dev/null
+++ b/t/python/spooler_decorators/spooler_handlers.py
@@ -0,0 +1,23 @@
+# See spooler_decorator_tests
+
+from uwsgidecorators import *
+import uwsgi
+
+ghostpath = "/tmp/ghost"
+
+
+@spool
+def controlled_task(arguments):
+    if arguments['arg'] != 'alive' and 'ghost' in arguments:
+        print("We have a problem!")
+        open(ghostpath, 'w').close()
+    uwsgi.signal(20)
+
+
+@spoolraw
+def controlled_raw_task(arguments):
+    if arguments['arg'] != 'alive' and 'ghost' in arguments:
+        print("We have a problem!")
+        open(ghostpath, 'w').close()
+    uwsgi.signal(20)
+    return uwsgi.SPOOL_OK
diff --git a/t/python/spooler_handler.py b/t/python/spooler_handler.py
new file mode 100644
index 0000000..dfaa46e
--- /dev/null
+++ b/t/python/spooler_handler.py
@@ -0,0 +1,34 @@
+#! /usr/bin/env python2
+# coding = utf-8
+
+from __future__ import print_function
+from constants import tasks, LOGFILE
+from os import remove
+import uwsgi
+
+counter = 0
+
+
+def spoolerHandler(env):
+	global counter
+	# Spooler is handling a task
+	with open(LOGFILE, "a") as log:
+		print("%s" % (env['name']), file=log)
+
+	counter += 1
+
+	if counter == len(tasks):
+		# Each task has been processed.
+		uwsgi.signal(17)
+
+	# Spooler has done handling the task
+	return uwsgi.SPOOL_OK
+
+uwsgi.spooler = spoolerHandler
+
+# Clear the logfile
+try:
+	remove(LOGFILE)
+except OSError, e:  # log does not exist
+	pass
+	# print(e)
diff --git a/t/python/spooler_priority/spooler_priority_constants.py b/t/python/spooler_priority/spooler_priority_constants.py
new file mode 100644
index 0000000..4e77d15
--- /dev/null
+++ b/t/python/spooler_priority/spooler_priority_constants.py
@@ -0,0 +1,22 @@
+#! /usr/bin/env python2
+# coding = utf-8
+
+tasks = [
+	(101, "101"),
+	(101, "101Bis"),
+	(2, "2"),
+	(1, "1"),
+	(0, "0"),
+	(None, "NoPriority")
+]
+
+ordered_tasks = [
+	"0",
+	"1",
+	"2",
+	"101",
+	"101Bis",
+	"NoPriority"
+]
+
+LOGFILE = "/tmp/spoolerlog"
diff --git a/t/python/spooler_priority/spooler_priority_handler.py b/t/python/spooler_priority/spooler_priority_handler.py
new file mode 100644
index 0000000..97d9a7d
--- /dev/null
+++ b/t/python/spooler_priority/spooler_priority_handler.py
@@ -0,0 +1,33 @@
+#! /usr/bin/env python
+# coding = utf-8
+
+from __future__ import print_function
+from spooler_priority_constants import tasks, LOGFILE
+from os import remove
+import uwsgi
+
+counter = 0
+
+
+def spoolerHandler(env):
+	global counter
+	# Spooler is handling a task
+	with open(LOGFILE, "a") as log:
+		print("%s" % (env['name']), file=log)
+
+	counter += 1
+
+	if counter == len(tasks):
+		# Each task has been processed.
+		uwsgi.signal(17)
+
+	# Spooler has done handling the task
+	return uwsgi.SPOOL_OK
+
+uwsgi.spooler = spoolerHandler
+
+# Clear the logfile
+try:
+	remove(LOGFILE)
+except OSError, e:  # log does not exist
+	print(e)
diff --git a/t/python/spooler_priority/spooler_priority_test.ini b/t/python/spooler_priority/spooler_priority_test.ini
new file mode 100644
index 0000000..0076fe6
--- /dev/null
+++ b/t/python/spooler_priority/spooler_priority_test.ini
@@ -0,0 +1,17 @@
+[uwsgi]
+socket = /tmp/temporary-socket
+
+; Specify the spooler
+spooler = %d/temporary_spooler
+; Spooler handler
+spooler-import = %d/spooler_priority_handler.py
+; And the number of processes
+spooler-processes = 1
+; Spooler ordered scanning (only works with "numbered" dirs)
+spooler-ordered = 1
+; Spooler scans folder each second
+spooler-frequency = 1
+
+pyrun = %d/spooler_priority_test.py
+master = 1
+
diff --git a/t/python/spooler_priority/spooler_priority_test.py b/t/python/spooler_priority/spooler_priority_test.py
new file mode 100644
index 0000000..a30dc88
--- /dev/null
+++ b/t/python/spooler_priority/spooler_priority_test.py
@@ -0,0 +1,82 @@
+#! /usr/bin/env python
+# coding = utf-8
+
+import uwsgi
+import unittest
+import os
+import fcntl
+from shutil import rmtree
+import time
+from signal import *
+import spooler_priority_constants
+
+
+def spoolersTaskList():
+	# Get the list of tasks
+	tasks = [
+			os.path.join(s, fn)
+			for s in uwsgi.spoolers
+			for fn in os.listdir(s)
+		]
+
+	for t in tasks[:]:
+		if os.path.isdir(t):
+			tasks += [os.path.join(t, fn) for fn in os.listdir(t)]
+			tasks.remove(t)
+
+	return tasks
+
+
+def is_locked(filepath):
+	# Check if file is locked
+	with open(filepath, "a+") as f:
+		try:
+			fcntl.lockf(f.fileno(), fcntl.LOCK_EX | fcntl.LOCK_NB)
+			is_locked = False
+		except IOError:
+			is_locked = True
+	return is_locked
+
+
+def lockedTasks(tasklist):
+	# List of locked tasks
+	return [fp for fp in spoolersTaskList() if is_locked(fp)]
+
+
+def taskParameters(filepath):
+	# Retrieve parameters
+	return uwsgi.parsefile(filepath)
+
+
+def cleanTasks():
+	# Clean any remaining task
+	for s in uwsgi.spoolers:
+		for f in os.listdir(s):
+			path = os.path.join(s, f)
+			if os.path.isdir(path):
+				rmtree(os.path.join(s, f))
+			else:
+				os.remove(path)
+
+
+class BitmapTest(unittest.TestCase):
+
+	def setUp(self):
+		for priority, name in spooler_priority_constants.tasks:
+			task = {'name': name, 'at': int(time.time() + 10)}
+			if priority is not None:
+				task['priority'] = str(priority)
+			uwsgi.spool(task)
+
+	def test_priority(self):
+		uwsgi.signal_wait(17)
+		print("Signal received.")
+
+		with open(spooler_priority_constants.LOGFILE, "r") as log:
+			# Check logging ordering.
+			loglines = [line.rstrip() for line in log]
+			self.assertEqual(loglines, spooler_priority_constants.ordered_tasks)
+
+signal(SIGINT, cleanTasks)
+unittest.main()
+
diff --git a/uwsgi.gemspec b/uwsgi.gemspec
index ecb4bf0..c7753c5 100644
--- a/uwsgi.gemspec
+++ b/uwsgi.gemspec
@@ -2,7 +2,7 @@ Gem::Specification.new do |s|
   s.name        = 'uwsgi'
   s.license     = 'GPL-2'
   s.version     = `python -c "import uwsgiconfig as uc; print uc.uwsgi_version"`.sub(/-dev-.*/,'')
-  s.date        = '2014-12-30'
+  s.date        = '2014-09-05'
   s.summary     = "uWSGI"
   s.description = "The uWSGI server for Ruby/Rack"
   s.authors     = ["Unbit"]
diff --git a/uwsgi.h b/uwsgi.h
index fdcfe05..40c0646 100644
--- a/uwsgi.h
+++ b/uwsgi.h
@@ -6,9 +6,9 @@
 extern "C" {
 #endif
 
-#define UWSGI_PLUGIN_API	1
+#define UWSGI_PLUGIN_API	2
 
-#define UWSGI_HAS_OFFLOAD_UBUFS	1
+#define UWSGI_HAS_OFFLOAD_UBUFS 1
 
 #define UMAX16	65536
 #define UMAX8	256
@@ -838,9 +838,6 @@ struct uwsgi_cache {
 	uint64_t lru_tail;
 
 	int store_delete;
-	int lazy_expire;
-	uint64_t sweep_on_full;
-	int clear_on_full;
 };
 
 struct uwsgi_option {
@@ -1068,7 +1065,7 @@ struct uwsgi_plugin {
         void (*exception_log)(struct wsgi_request *);
 
 	void (*vassal)(struct uwsgi_instance *);
-	void (*vassal_before_exec)(struct uwsgi_instance *);
+	void (*vassal_before_exec)(struct uwsgi_instance *, char **);
 };
 
 #ifdef UWSGI_PCRE
@@ -1286,7 +1283,7 @@ struct uwsgi_alarm_log {
 
 struct __attribute__ ((packed)) uwsgi_header {
 	uint8_t modifier1;
-	uint16_t pktsize;
+	uint16_t _pktsize;
 	uint8_t modifier2;
 };
 
@@ -1587,6 +1584,9 @@ struct wsgi_request {
 	int do_not_account_avg_rt;
 	// used for protocol parsers requiring EOF signaling
 	int proto_parser_eof;
+
+	// uWSGI 2.1
+	uint64_t len;
 };
 
 
@@ -1702,6 +1702,8 @@ struct uwsgi_fsmon {
 	struct uwsgi_fsmon *next;
 };
 
+struct uwsgi_subscription_client;
+
 struct uwsgi_server {
 
 	// store the machine hostname
@@ -2374,7 +2376,8 @@ struct uwsgi_server {
 
 	int udp_fd;
 
-	uint16_t buffer_size;
+	// removed in 2.1, here for ABI compatibility
+	uint16_t __buffer_size;
 	int signal_bufsize;
 
 	// post buffering
@@ -2651,7 +2654,7 @@ struct uwsgi_server {
 	struct uwsgi_string_list *subscriptions;
 	struct uwsgi_string_list *subscriptions2;
 
-	struct uwsgi_subscribe_node *(*subscription_algo) (struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *);
+	struct uwsgi_subscribe_node *(*subscription_algo) (struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *);
 	int subscription_dotsplit;
 
 	int never_swap;
@@ -2732,7 +2735,6 @@ struct uwsgi_server {
 
 	int mule_reload_mercy;
 	int alarm_cheap;
-
 	int emperor_no_blacklist;
 	int metrics_no_cores;
 	int stats_no_cores;
@@ -2747,16 +2749,30 @@ struct uwsgi_server {
 	struct uwsgi_string_list *wait_for_file;
 	int wait_for_fs_timeout;
 	struct uwsgi_string_list *wait_for_mountpoint;
-#ifdef UWSGI_SSL
-	int sslv3;
-	struct uwsgi_string_list *ssl_options;
-#endif
-	struct uwsgi_string_list *hook_post_fork;
-
-	// uWSGI 2.0.9
-	char *subscribe_with_modifier1;
-	struct uwsgi_string_list *pull_headers;
 
+	// uWSGI 2.1
+	char *fork_socket;
+	int new_argc;
+	char **new_argv;
+	char *emperor_use_fork_server;
+	struct uwsgi_string_list *vassal_fork_base;
+	struct uwsgi_string_list *emperor_collect_attributes;
+	char *emperor_fork_server_attr;
+	char *emperor_wrapper_attr;
+	int emperor_subreaper;
+        struct uwsgi_string_list *hook_as_on_demand_vassal;
+	uint64_t max_requests_delta;
+	char *emperor_chdir_attr;
+	struct uwsgi_string_list *subscription_algos;
+	int subscription_mountpoints;
+	struct uwsgi_string_list *hook_as_emperor_before_vassal;
+	struct uwsgi_string_list *hook_as_vassal_before_drop;
+	struct uwsgi_string_list *hook_as_emperor_setns;
+	int emperor_force_config_pipe;
+	struct uwsgi_string_list *hook_as_on_config_vassal;
+	int async_warn_if_queue_full;
+	char *zeus;
+	uint64_t buffer_size;
 };
 
 struct uwsgi_rpc {
@@ -2884,7 +2900,6 @@ struct uwsgi_shared {
 
 struct uwsgi_core {
 
-	//time_t harakiri;
 
 	uint64_t requests;
 	uint64_t failed_requests;
@@ -2910,6 +2925,10 @@ struct uwsgi_core {
 	char *post_buf;
 
 	struct wsgi_request req;
+
+	// uWSGI 2.1
+	time_t harakiri;
+	time_t user_harakiri;
 };
 
 struct uwsgi_worker {
@@ -2925,8 +2944,10 @@ struct uwsgi_worker {
 	uint64_t delta_requests;
 	uint64_t failed_requests;
 
-	time_t harakiri;
-	time_t user_harakiri;
+	// renamed in 2.1 (was 'harakiri')
+	time_t harakiri_unused;
+	// renamed in 2.1 (was 'user_harakiri')
+	time_t user_harakiri_unused;
 	uint64_t harakiri_count;
 	int pending_harakiri;
 
@@ -3060,15 +3081,21 @@ char *uwsgi_spool_request(struct wsgi_request *, char *, size_t, char *, size_t)
 void spooler(struct uwsgi_spooler *);
 pid_t spooler_start(struct uwsgi_spooler *);
 
+#ifdef _GNU_SOURCE
+#define uwsgi_versionsort versionsort
+#else
+int uwsgi_versionsort(const struct dirent **da, const struct dirent **db);
+#endif
+
 void uwsgi_curse(int, int);
 void uwsgi_curse_mule(int, int);
 void uwsgi_destroy_processes(void);
 
-void set_harakiri(int);
-void set_user_harakiri(int);
+void set_harakiri(struct wsgi_request *, int);
+void set_user_harakiri(struct wsgi_request *, int);
 void set_mule_harakiri(int);
 void set_spooler_harakiri(int);
-void inc_harakiri(int);
+void inc_harakiri(struct wsgi_request *, int);
 
 #ifdef __BIG_ENDIAN__
 uint16_t uwsgi_swap16(uint16_t);
@@ -3257,7 +3284,7 @@ int uwsgi_register_signal(uint8_t, char *, void *, uint8_t);
 int uwsgi_add_file_monitor(uint8_t, char *);
 int uwsgi_add_timer(uint8_t, int);
 int uwsgi_signal_add_rb_timer(uint8_t, int, int);
-int uwsgi_signal_handler(uint8_t);
+int uwsgi_signal_handler(struct wsgi_request *, uint8_t);
 
 void uwsgi_route_signal(uint8_t);
 
@@ -3346,6 +3373,13 @@ struct uwsgi_subscribe_req {
 
 	char *notify;
 	uint16_t notify_len;
+
+	uint64_t backup_level;
+
+	char *proto;
+	uint16_t proto_len;
+
+	struct uwsgi_subscribe_node *(*algo) (struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *);
 };
 
 void uwsgi_nuclear_blast();
@@ -3427,14 +3461,15 @@ void uwsgi_proto_base_close(struct wsgi_request *);
 int uwsgi_proto_ssl_accept(struct wsgi_request *, int);
 void uwsgi_proto_ssl_close(struct wsgi_request *);
 #endif
-uint16_t proto_base_add_uwsgi_header(struct wsgi_request *, char *, uint16_t, char *, uint16_t);
-uint16_t proto_base_add_uwsgi_var(struct wsgi_request *, char *, uint16_t, char *, uint16_t);
+uint64_t proto_base_add_uwsgi_header(struct wsgi_request *, char *, uint16_t, char *, uint16_t);
+uint64_t proto_base_add_uwsgi_var(struct wsgi_request *, char *, uint16_t, char *, uint16_t);
 
 // protocols
 void uwsgi_proto_uwsgi_setup(struct uwsgi_socket *);
 void uwsgi_proto_puwsgi_setup(struct uwsgi_socket *);
 void uwsgi_proto_raw_setup(struct uwsgi_socket *);
 void uwsgi_proto_http_setup(struct uwsgi_socket *);
+void uwsgi_proto_http11_setup(struct uwsgi_socket *);
 #ifdef UWSGI_SSL
 void uwsgi_proto_https_setup(struct uwsgi_socket *);
 void uwsgi_proto_suwsgi_setup(struct uwsgi_socket *);
@@ -3575,6 +3610,11 @@ struct uwsgi_mule_farm *uwsgi_mule_farm_new(struct uwsgi_mule_farm **, struct uw
 int uwsgi_farm_has_mule(struct uwsgi_farm *, int);
 struct uwsgi_farm *get_farm_by_name(char *);
 
+struct uwsgi_subscription_client {
+	int fd;
+	union uwsgi_sockaddr *sockaddr;
+	char *cookie;
+};
 
 struct uwsgi_subscribe_node {
 
@@ -3614,6 +3654,11 @@ struct uwsgi_subscribe_node {
 	struct uwsgi_subscribe_slot *slot;
 
 	struct uwsgi_subscribe_node *next;
+
+	// uWSGI 2.1
+	uint64_t backup_level;
+	//here the solution is a bit hacky, we take the first letter of the proto ('u','\0' -> uwsgi, 'h' -> http, 'f' -> fastcgi, 's' -> scgi)
+	char proto;
 };
 
 struct uwsgi_subscribe_slot {
@@ -3636,6 +3681,9 @@ struct uwsgi_subscribe_slot {
 	uint8_t sni_enabled;
 #endif
 
+	// uWSGI 2.1 (algo is required)
+        struct uwsgi_subscribe_node *(*algo) (struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *);
+
 };
 
 void mule_send_msg(int, char *, size_t);
@@ -3645,13 +3693,13 @@ void create_signal_pipe(int *);
 void create_msg_pipe(int *, int);
 struct uwsgi_subscribe_slot *uwsgi_get_subscribe_slot(struct uwsgi_subscribe_slot **, char *, uint16_t);
 struct uwsgi_subscribe_node *uwsgi_get_subscribe_node_by_name(struct uwsgi_subscribe_slot **, char *, uint16_t, char *, uint16_t);
-struct uwsgi_subscribe_node *uwsgi_get_subscribe_node(struct uwsgi_subscribe_slot **, char *, uint16_t);
+struct uwsgi_subscribe_node *uwsgi_get_subscribe_node(struct uwsgi_subscribe_slot **, char *, uint16_t, struct uwsgi_subscription_client *);
 int uwsgi_remove_subscribe_node(struct uwsgi_subscribe_slot **, struct uwsgi_subscribe_node *);
 struct uwsgi_subscribe_node *uwsgi_add_subscribe_node(struct uwsgi_subscribe_slot **, struct uwsgi_subscribe_req *);
 
 ssize_t uwsgi_mule_get_msg(int, int, char *, size_t, int);
 
-int uwsgi_signal_wait(int);
+int uwsgi_signal_wait(struct wsgi_request *, int);
 struct uwsgi_app *uwsgi_add_app(int, uint8_t, char *, int, void *, void *);
 int uwsgi_signal_send(int, uint8_t);
 int uwsgi_remote_signal_send(char *, uint8_t);
@@ -3913,7 +3961,7 @@ int uwsgi_is_file2(char *, struct stat *);
 int uwsgi_is_dir(char *);
 int uwsgi_is_link(char *);
 
-void uwsgi_receive_signal(int, char *, int);
+void uwsgi_receive_signal(struct wsgi_request *, int, char *, int);
 void uwsgi_exec_atexit(void);
 
 struct uwsgi_stats {
@@ -4108,6 +4156,11 @@ struct uwsgi_instance {
 	int on_demand_fd;
 	char *socket_name;
 	time_t cursed_at;
+
+	int adopted;
+
+	// uWSGI 2.1 (vassal's attributes)
+	struct uwsgi_dyn_dict *attrs;
 };
 
 struct uwsgi_instance *emperor_get_by_fd(int);
@@ -4116,6 +4169,7 @@ void emperor_stop(struct uwsgi_instance *);
 void emperor_curse(struct uwsgi_instance *);
 void emperor_respawn(struct uwsgi_instance *, time_t);
 void emperor_add(struct uwsgi_emperor_scanner *, char *, time_t, char *, uint32_t, uid_t, gid_t, char *);
+void emperor_add_with_attrs(struct uwsgi_emperor_scanner *, char *, time_t, char *, uint32_t, uid_t, gid_t, char *, struct uwsgi_dyn_dict *);
 void emperor_back_to_ondemand(struct uwsgi_instance *);
 
 void uwsgi_exec_command_with_args(char *);
@@ -4186,7 +4240,6 @@ struct uwsgi_buffer *uwsgi_buffer_from_file(char *);
 ssize_t uwsgi_buffer_write_simple(struct wsgi_request *, struct uwsgi_buffer *);
 
 struct uwsgi_buffer *uwsgi_to_http(struct wsgi_request *, char *, uint16_t, char *, uint16_t);
-struct uwsgi_buffer *uwsgi_to_http_dumb(struct wsgi_request *, char *, uint16_t, char *, uint16_t);
 
 ssize_t uwsgi_pipe(int, int, int);
 ssize_t uwsgi_pipe_sized(int, int, size_t, int);
@@ -4197,6 +4250,7 @@ void uwsgi_master_cleanup_hooks(void);
 pid_t uwsgi_daemonize2();
 
 void uwsgi_emperor_simple_do(struct uwsgi_emperor_scanner *, char *, char *, time_t, uid_t, gid_t, char *);
+void uwsgi_emperor_simple_do_with_attrs(struct uwsgi_emperor_scanner *, char *, char *, time_t, uid_t, gid_t, char *, struct uwsgi_dyn_dict *);
 
 #if defined(__linux__)
 #define UWSGI_ELF
@@ -4629,6 +4683,7 @@ int uwsgi_umount(char *, char *);
 int uwsgi_mount_hook(char *);
 int uwsgi_umount_hook(char *);
 
+int uwsgi_hooks_run_and_return(struct uwsgi_string_list *, char *, char *, int);
 void uwsgi_hooks_run(struct uwsgi_string_list *, char *, int);
 void uwsgi_register_hook(char *, int (*)(char *));
 struct uwsgi_hook *uwsgi_hook_by_name(char *);
@@ -4662,7 +4717,7 @@ void uwsgi_go_cheap();
 
 char **uwsgi_split_quoted(char *, size_t, char *, size_t *);
 
-void uwsgi_master_manage_emperor_proxy();
+void uwsgi_master_manage_emperor_proxy(int, int, int, int);
 struct uwsgi_string_list *uwsgi_register_scheme(char *, char * (*)(char *, size_t *, int));
 void uwsgi_setup_schemes(void);
 
@@ -4847,9 +4902,40 @@ int uwsgi_notify_socket_manage(int);
 int uwsgi_notify_msg(char *, char *, size_t);
 void vassal_sos();
 
+int uwsgi_send_fds_and_body(int, int *, int, char *, size_t);
+ssize_t uwsgi_recv_cred_and_fds(int, char *, size_t buf_len, pid_t *, uid_t *, gid_t *, int *, int *);
+void uwsgi_fork_server(char *);
+
+void uwsgi_emperor_ini_attrs(char *, char *, struct uwsgi_dyn_dict **);
+
+int uwsgi_buffer_httpdate(struct uwsgi_buffer *, time_t);
+int uwsgi_buffer_append_xml(struct uwsgi_buffer *, char *, size_t);
+
+struct uwsgi_buffer *uwsgi_webdav_multistatus_new();
+int uwsgi_webdav_propfind_item_add(struct uwsgi_buffer *, char *, uint16_t, uint64_t, time_t, char *, uint16_t, char *, uint16_t, char *, uint16_t);
+int uwsgi_webdav_multistatus_close(struct uwsgi_buffer *);
+int uwsgi_webdav_multistatus_response_new(struct uwsgi_buffer *);
+int uwsgi_webdav_multistatus_response_close(struct uwsgi_buffer *);
+int uwsgi_webdav_multistatus_propstat_new(struct uwsgi_buffer *);
+int uwsgi_webdav_multistatus_propstat_close(struct uwsgi_buffer *);
+int uwsgi_webdav_multistatus_prop_new(struct uwsgi_buffer *);
+int uwsgi_webdav_multistatus_prop_close(struct uwsgi_buffer *);
+
+struct uwsgi_subscribe_node *(*uwsgi_subscription_algo_get(char * , size_t))(struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *);
+
+void uwsgi_subscription_init_algos(void);
+void uwsgi_register_subscription_algo(char *, struct uwsgi_subscribe_node *(*) (struct uwsgi_subscribe_slot *, struct uwsgi_subscribe_node *, struct uwsgi_subscription_client *));
+char *uwsgi_subscription_algo_name(void *);
+
 int uwsgi_wait_for_fs(char *, int);
 int uwsgi_wait_for_mountpoint(char *);
+void uwsgi_hooks_setns_run(struct uwsgi_string_list *, pid_t, uid_t, gid_t);
+char *vassal_attr_get(struct uwsgi_instance *, char *);
+int vassal_attr_get_multi(struct uwsgi_instance *, char *, int (*)(struct uwsgi_instance *, char *, void *), void *);
+
+int uwsgi_zeus_spawn_instance(struct uwsgi_instance *);
 
+time_t uwsgi_parse_http_date(char *, uint16_t);
 #ifdef __cplusplus
 }
 #endif
diff --git a/uwsgiconfig.py b/uwsgiconfig.py
index 84e8ef1..3b35616 100644
--- a/uwsgiconfig.py
+++ b/uwsgiconfig.py
@@ -615,7 +615,7 @@ class uConf(object):
             'core/setup_utils', 'core/clock', 'core/init', 'core/buffer', 'core/reader', 'core/writer', 'core/alarm', 'core/cron', 'core/hooks',
             'core/plugins', 'core/lock', 'core/cache', 'core/daemons', 'core/errors', 'core/hash', 'core/master_events', 'core/chunked',
             'core/queue', 'core/event', 'core/signal', 'core/strings', 'core/progress', 'core/timebomb', 'core/ini', 'core/fsmon', 'core/mount',
-            'core/metrics', 'core/plugins_builder', 'core/sharedarea',
+            'core/metrics', 'core/plugins_builder', 'core/sharedarea', 'core/fork_server', 'core/webdav', 'core/zeus',
             'core/rpc', 'core/gateway', 'core/loop', 'core/cookie', 'core/querystring', 'core/rb_timers', 'core/transformations', 'core/uwsgi']
         # add protocols
         self.gcc_list.append('proto/base')
@@ -1171,8 +1171,6 @@ class uConf(object):
                 else:
                     jsonconf = spcall("pkg-config --cflags yajl")
                     if jsonconf:
-                        if jsonconf.endswith('include/yajl'):
-                            jsonconf = jsonconf.rstrip('yajl')
                         self.cflags.append(jsonconf)
                         self.cflags.append("-DUWSGI_JSON")
                         self.gcc_list.append('core/json')
diff --git a/uwsgidecorators.py b/uwsgidecorators.py
index 659af7a..290ee66 100644
--- a/uwsgidecorators.py
+++ b/uwsgidecorators.py
@@ -72,6 +72,7 @@ uwsgi.post_fork_hook = postfork_chain_hook
 
 
 class postfork(object):
+
     def __init__(self, f):
         if callable(f):
             self.wid = 0
@@ -80,6 +81,7 @@ class postfork(object):
             self.f = None
             self.wid = f
         postfork_chain.append(self)
+
     def __call__(self, *args, **kwargs):
         if self.f:
             if self.wid > 0 and self.wid != uwsgi.worker_id():
@@ -259,6 +261,7 @@ class mule_brainloop(mule_brain):
 
 
 class mule(object):
+
     def __init__(self, num):
         self.num = num
 
@@ -267,6 +270,7 @@ class mule(object):
 
 
 class muleloop(mule):
+
     def __call__(self, f):
         postfork_chain.append(mule_brainloop(f, self.num))
 
@@ -286,6 +290,7 @@ class mulemsg_loop(object):
 
 
 class mulemsg(object):
+
     def __init__(self, num):
         self.num = num
 
@@ -331,7 +336,7 @@ class cron(object):
     def __call__(self, f):
         uwsgi.register_signal(self.num, self.target, f)
         uwsgi.add_cron(self.num, self.minute, self.hour,
-            self.day, self.month, self.dayweek)
+                       self.day, self.month, self.dayweek)
         return f
 
 
@@ -372,6 +377,7 @@ class erlang(object):
 
 
 class lock(object):
+
     def __init__(self, f):
         self.f = f
 
